[[c_ds]]
= Data Structures through C
:page-aliases: ds/index.adoc
:doctype: book
:sectnums: 7
:sectnumlevels: 7
:icons: font
:include_dir: example$ds
:imagedir: ds/

== Data Structures

=== Definition

* Data structures is the concept of set of algorithms used to structure the information.
* These algorithms are implemented in different programming languages like c, c++, java, python, etc.
* Structure the information means store and process data in an efficient manner.
* To store and process data, we may use the following operations:
. create()
. insert()
. delete()
. display()
. search()
. sort()
. merge()
. split()
. traverse()
* So the data structure may contain algorithms, used for different operations implement these algorithms by a programming language.
* For example, for stack data structure, write algorithms for different operations
. push
. pop
. display
* Implement these algorithms in a particular language say C.

=== Classification of Data Structures

Data Structures are normally classified into 2 types

. Primitive Data Structures
. Non-Primitive Data Structures

==== Primitive Data Structures

Primitive data structures are built-in types in most programming languages. They are:

Integer:: It is whole numbers i.e. negative value, 0, positive value.
Float:: It is fractional numbers.
Character:: It is character values.
Boolean:: It represents true or false values.

==== Non-Primitive Data Structures

These are derived from primitive data structures. They are

* Array
* Structure
* Union
* Files
etc.

Non-Primitive data type is further divided into Linear and Non-Linear data structures:

===== Linear Data Structures:

Here the data elements are connected in a sequence manner.
Examples are:

. Arrays
. Linked List
. Stacks
. Queues

====== Array

It is collection of elements of same type.

a[5] = {10, 20, 30, 40, 50}

|====
|0|1|2|3|4
|10|20|30|40|50
|====

====== Linked List

* Linked list or single linked list is a sequence of elements in which every element has link to its next element in the sequence.
* Every element is called as a `node`. 
Every `node` contains two fields, `data` and `link`. 
The `data` is a value or string and 
`link` is an address of next `node`.
* The first `node`` is called as `HEAD` which is an empty node contains an address of the first node so it link to the first `node`.
* The first `node` link to second `node` and so on.
* The last `node` does not link to address but link to `NULL`. 
Let `ptr` be a `pointer` to the linked list. 
THe example is given below:

image::{imagedir}linked_list.png[Linked List]

====== Stack

A `stack` is a data structure in which additions and deletions are made at the top of the `stack`. 
So we can perform two operations on `stack`.

. Adding elements into the stack known as `push`.
. Removing elements from the stack known as `pop`.

image::{imagedir}stack.png[Stack]

====== Queue

A `queue` is a data structure in which additions are made at one end and deletions are made at the other end. 
We can represent a `queue` in an array.

Here we can perform two operations on `queue`.

. Adding elements into the queue known as insertion at rear.
. Removing elements from the queue known as deletion at front.

image::{imagedir}queue.png[Queue]

===== Non-Linear Data Structures

Here the data elements are not connected in a sequence manner.

Examples are:

. Trees
. Graphs

====== Tree

A `tree` is defined as a finite set of one or more `nodes` such that

. One `node` is called a root node and
. Remaining `nodes` are partitioned into sub trees of the root.

image::{imagedir}tree.png[Tree]

====== Graph

* A `graph` is a pictorial representation of a set of `points` or `nodes` termed as `vertices` and the `links` that connect the vertices are called `edges`.
* A `graph`(G) consists of two sets `V` and `E` where `V` is called vertices and `E` is called edges. 
We also write G = (V, E) to represent the graph.
* A `graph` may be directed graph or undirected graph.

image::{imagedir}graph.png[Graph]

* Fig(a), Fig(b) are called undirected graph and Fig(c) is called directed graph.

===== Differences between Linear and Non-Linear Data Structures

[cols="1,1"]
|===
|Linear Data Structure | Non-Linear Data Structure 

|Every data element is connected to its previous and next element.
|Every data element is connected with many other data elements.

|Data is arranged in a sequence manner.
|Data is not arranged in a sequence manner.

|Data can be traversed in a single run.
|Data cannot be traversed in a single run.

|Ex: Arrays, Linked List, Stacks, Queues
|Ex: Trees, Graphs

|Implementation is easy.
|Implementation is difficult.
|===

=== Operations on Data Structures

The different operations on data structures are:

. Create:
+
Here we reserve memory for program elements: This can be done using `malloc()` or `calloc()` function. 
We can create a data structure with giving different elements.

. Insert:
+
Here we reserve memory for program element: This can be done using `malloc()` or `calloc()` function. 
We can insert a data element into a data structure.

. Delete:
+
It delete memory space allocated for specified data structure using `free()` function.

. Display:
+
It deals with accessing a particular data element within a data structure.

. Search:
+
* It finds the data element in the list of data elements.
* It also find the location of all elements.

. Sort:
+
It is the process of arranging all the data elements in a data structure in a particular order say either in ascending or descending order.

. Merge:
+
It is the process of combining the data elements of two different sorted list into a single sorted list.

. Split:
+
It is the process of partitioning single list to multiple list.

. Traversal:
+
It is the process of visiting each and every node of a list in systematic manner.

=== Abstract Data Types (ADT)

An `Abstract Data Type (ADT)` is a collection of values and a set of operations without specifying its implementation.

For example in Array ADT, set of values are index and item & set of operations are create(), retrieval() and store().

:sectnums!:

==== Purpose

* The purpose of the ADT is to hide the implementation details of a data structure thus improving software maintenance, reuse and portability.
* The developers of ADT will adapt changing requirements and save time.
* The users of ADT are concerned with the interface, but not the implementation.
* The different ADTs
** String ADT, List ADT, Stack ADT (last-in, first-out(LIFO))
** Queue ADT (first-in, first-out(FIFO))
** Binary Search Tree ADT
etc.

==== Example

* A `List ADT` contain operations known as add element, remove element, etc.
* A `List ADT` can be represented by an `array-based` implementation or a `linked-list` based implementation. 
In this the `linked-list` based implementation is so commonly used.
* Similarly a `Biney Search Tree ADT` can be represented in different ways with the same operations known as insert, remove, display, etc.

:sectnums:

==== Array as an Abstract Data Type

The `Array ADT` is a set of values (index, element) and a set of operations known as `Array create()`, `Item Retrieve()` and `Array Store()`.

The `Array ADT` algorithm is given by

----
`Array ADT` is

objects: A set of pairs<index, element> where for each index, there is a corresponding element.

functions: for all A€Array, i € index, x € element:

Array create() := It creates a new empty array.

Item retrieve(A, i) := It returns the element with particular index, if the index is valid or an error if the inded is invalid.

Array Strore(A, i, x) := It stores the element

end Array.
----

==== Stack as an Abstract Data Type

----
ADT stack is 

objects: a finite ordered list with zero or more elements.

functions: S € Stack, item € element

Stack create() := creates a new empty stack.

Stack push(S, item) := adds item to the top of the stack.

Element pop(S) := removes the top element of the stack and returns it.

end Stack.
----

==== Queue as an Abstract Data Type

----
ADT queue is

objects: a finite ordered list with zero or more elements.

functions: Q € Queue, item € element

Queue create() := creates a new empty queue.

Queue addq(Q, item) := adds item to the end of the queue.

Element deleteq(Q) := removes and return the item from the queue.

end Queue.
----

==== Binary Tree as an Abstract Data Type

----
ADT BinaryTree is

objects: a finite set of nodes.

functions: for all bt, bt1, bt2 € BinaryTree, item € element

BinaryTree create() := creates a new empty binary tree.

Boolean IsEmpty := if(bt == empty binary tree) return `TRUE` else return `FALSE`

BinaryTree MakeBT(bt1, item, bt2) := return a binary tree whose left subtree is bt1, whose right subtree is bt2 and whose root node contains the date item.

BinaryTree LeftChild(bt) := returns the left subtree of bt.

Element Data(bt) := returns the data of the root node of bt.

BinaryTree RightChild(bt) := returns the right subtree of bt.

End BinaryTree.
----

==== Graph as an Abstract Data Type

----
ADT Graph is

objects: a set of vertices and edges.

functions: for all graph € Graph, v, v1 and v2 € Vertices

Graph create() := creates a new empty Graph.

Boolean IsEmpty() := if(graph == empty graph) return `TRUE` else return `FALSE`

Graph InsertVertex(graph, v) := returns a graph with vertex v inserted.

Graph InsertEdge(graph, v1, v2) := returns a graph with edge (v1, v2) inserted.

Graph DeleteVertex(graph, v) := returns a graph with vertex v removed.

Graph DeleteEdge(graph, v1, v2) := returns a graph with edge (v1, v2) removed.

End ADT Graph.
----

=== Preliminaries of algorithms

Algorithm is step-by-step process or sequence of steps for solving a problem.

:sectnums!:
==== Properties of an Algorithm

* The properties of an algorithm are:
Input::
The algorithm must have input values from a specified set.

Output::
The algorithm must produce the output values from a specified set of input values. 
The output values are the solution to a problem.

Finiteness::
For any input the algorithm must terminate after a finite number of steps.

Definiteness::
All the steps of an algorithm must be precisely defined.

Effectiveness::
It must be possible to perform each step of the algorithm correctly and in a finite amount of time.

* Each step should be well defined. 
It can be divided into 3 types

. Sequence
** In an algorithm if all steps are shown then it is known as sequence.
** for example an algorithm for adding two values.
+
----
Ex:
Step 1: start
Step 2: read a, b
Step 3: r = a + b
Step 4: print r
Step 5: stop
----

. Selection
** Here we use if condition and the condition is checked only one time.
** if a condition is satisfied then next statement is executed otherwise else statement is executed.
** For example an algorithm to check whether the given number is even or odd.
+
----
Ex:
Step 1: start
Step 2: read n
Step 3: if (n % 2 == 0) goto step 4
        if not goto step 6
Step 4: print "n is even" goto step 7
Step 5: else
Step 6: print "n is odd"
Step 7: stop
----

. Iteration

** Here we use while, do-while and for loop & the condition is checked number of times.
** i.e. The statements in an iteration block are executed no. of times based on some condition.
** For example an algorithm to print 1 to n numbers using while loop.
+
----
Ex:
Step 1: start
Step 2: read n
Step 3: initialize i = 1
Step 4: while (i <= 10) goto step 5
        otherwise goto step 7
Step 5: print i
Step 6: compute i++ goto Step 4
Step 7: stop
----

* When an algorithm get coded in a specified programming language such as C, C++ or Java, it becomes a program that can be executed on a computer.
* Multiple algorithm can exist to solve the same problem or complete the the same task.
* The appropriate algorithm can be determined based on an number of factors:
+
. How long the algorithm takes to run
. What resources are required to execute the algorithm
. How much space or memory is required.
. How exact is the solution provided by the algorithm.

:sectnums:
=== Time and Space Complexity

* Step by step process of solving a problem is called an algorithm. 
The complexity of an algorithm is a function describing the efficiency of the algorithm in terms of the amount of data the algorithm must process. 
There are 2 main complexity measures of the efficiency of an algorithm.

. Time Complexity
** Time complexity is a function describing the amount of time an algorithm takes in terms of amount of input to algorithm.
** Time means the number of memory accesses performed, the number of comparisons between integers, the number of times some inner loop is executed or some other natural unit related to the amount of real time the algorithm will take.

. Space Complexity
** Space complexity is a function describing the amount of memory an algorithm takes in terms of amount of input to algorithm. 
We often speak of extra memory needed, not counting the memory needed to store the input itself. 
We can use bytes, but it's easier to use say number of integers used, number of fixed-sized structures etc.
** In the end the function will be independent of the actual number of bytes needed to represent the unit. 
Space complexity is sometimes ignored because the space used is minimal.

* The complexity of an algorithm is studied with respect to the following 3 cases.
a. Worst case analysis
** In the worst case analysis, we calculate upper bound on running time of an algorithm.
** We must know the case that causes maximum number of operations to be executed.
** For linear search the worst case happens when the element to be searched is not present in the array.

b. Average case analysis
** In the average case analysis, we calculate the average running time of an algorithm. 
We must know the average number of operations to be executed.
** In the linear search problem, the average case occurs when x is present at average of its location.

c. Best case analysis
** In the best case analysis, we calculate lower bound on running time of an algorithm.
** We must know the case that causes minimum number of operations to be executed.
** In the linear search problem, the best case occurs when x is present at the first location.

== Searching

Searching is the process of finding an element in a list of values.

It is the algorithmic process of finding a particular element in a collection of elements.

. Linear Search

Definition::
* It starts at the beginning of the list and checks each element of the list.
* i.e. It sequentially checks each element of the list until a match is found or the whole list has been searched.
So it is called sequential search.

Example::

* Let the elements are: 10, 6, 3, 8, 9, 12, 14
* The search element is 12
* Now it compares 12 with each and every element.
* The 12 is available at the 6th position.
* So the searching process is success and element is found.

Algorithm::
+
----
Step 1: Read elements in array
Step 2: Read the element to be searched
Step 3: Compare the element with each element of the array sequentially
Step 4: If match is found then the search is success
Step 5: If match is not found then the search is unsuccess.
----

Program::
+
[source, c]
----
include::{include_dir}/linear_search.c[]
----

. Binary Search
+
Definition::
* Binary search is the most popular search algorithm. 
It is efficient and also one of the most commonly used techniques that are used to solve problems.

* Binary search sorts the records either in ascending or descending order to gain much better performance than linear search.

* Now suppose we have an ascending order record. At the time of search it takes the middle record/element, if the searching element is greater than middle element then the element must be located in the second part else it is in the first half. 
In this way this search algorithm divides the records into two parts in each iteration and thus called binary search.

Example::

* Let the elements in ascending order are: 2, 4, 6, 8, 10, 12, 15
* The search element is 12
* For searching it compare first middle element.
* The middle element is 8 and is not equal to 12. 
Since 12 is greater than 8 search on right side part of 8. 
12 is equal to right side part middle. 
So element is found.

Algorithm::
+
----
Step 1: Read sorted elements in array
Step 2: Read the element to be searched
Step 3: Compare the element to search and middle element in array. 
Step 4: If search element is greater than middle element then search in right side of middle element otherwise search on left.
Step 5: This process is repeated for all elements in array. 
If not match is found upto the end then the search is not success.
----

Program::
+
[source, c]
----
include::{include_dir}/binary_search.c[]
----

. Fibonacci Search

* Fibonacci search uses Fibonacci numbers to find the element in the sorted array.
* Fibonacci numbers are: 0, 1, 1, 2, 3, 5, 8...
* Fibonacci series generates the subsequent number by adding two previous numbers.
* For example:
Let the elements are give by:
10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100
arr[] = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100}
* Fibonacci numbers are: 0, 1, 1, 2, 3, 5, 8, 13, 21...
Target element x is 85. 
Length of array n = 11.
* Find the smallest Fibonacci number greater than or equal to 11 is 13.
* As per our step, a=5, b=8, c=a+b=13.
* Let offset = -1
* First compute i = min (offset+a, n-1)
* If x is greater than the element, move the 3 Fibonacci variables one Fibonacci down. 
Reset offset to index. 
Else if x is less than the element, move the 3 Fibonacci variables two Fibonacci down. 
Else (or when b = 1) return i - this is the case element found.
* If element not found return -1
* These steps are shown in the following table
+
[%header, COl="1,1,1,1,1,1,6"]
|====
|a|b|c|offset|i=min(offset+a, n-1)|arr[i]|Consequence
|5|8|13|-1|4|45|Move one down, reset offset
|3|5|8|4|7|82|Move one down, reset offset
|2|3|5|7|9|90|Move two down
|1|1|2|7|8|85|Return i
|====
+
Let arr[0..n-1] be the input array and element to be searched be x.
+
.Algorithm
----
Step 1: Find the smallest Fibonacci number greater thatn or equal to n. 
        Let this number be c. 
        Let the 2 Fibonacci numbers preceding it be a, b.
Step 2: While the array has elements to be inspected such as:
Step 2.1: Compute i = min (offset+a, n-1)
Step 2.2: If x is greater than the element, move the 3 Fibonacci variables one Fibonacci down. 
                Reset offset to index.
Step 2.3: Else if x is less than the element, move the 3 Fibonacci variables two Fibonacci down.
Step 2.4: Else (or when b = 1) return i - this is the case element found.
Step 3: If element not found return -1
----
+
.Program
+
[source, c]
----
include::{include_dir}/fibonacci_search.c[]
----

== Sorting

* Sorting is a process of placing a list of elements from a collection of dats in some order.

* It is nothing but storage of data in sorted order. 
Sorting can be done in ascending or descending order. 
It arranges the data in a sequence which makes searching easier.

. Insertion Sort
** In this sorting technique first elements are stored in an array.
** The process of sorting starts with second element.
** First the second element is picked and is placed in specified order. 
Next third element is picked and is placed in specified order. 
Similarly the fourth, fifth, ...nth element is placed in specified order.
** Finally we get the sorting elements.

Example::
Let us consider the elements of an array: 12, 3, 1, 5, 8
+
1. Checking second element of array with element before it and inserting it in proper position. 
In this case 3 is inserted in position of 12.
+
image::{imagedir}insertion_sort-1.png[]
2. Checking third element of array with elements before it and inserting it in proper position. 
In this case 3 is inserted in position 12.
+
image::{imagedir}insertion_sort-2.png[]
3. Checking fourth element of array with elements before it and inserting it in proper position. 
In this case 5 is inserted in position of 12.
+
image::{imagedir}insertion_sort-3.png[]
4. Checking fifth element of array with elements before it and inserting it in proper position. 
In this case 8 is inserted in position of 12.
+
image::{imagedir}insertion_sort-4.png[]
5. Sorted array in ascending order.
+
image::{imagedir}insertion_sort-5.png[]

Algorithm::
+
----
Step 1: Check second element of array with element before it and insert it in proper position.
Step 2: Checking third element of array with element before it and inserting it in proper position.
Step 3: Repeat this till all elements are checked.
Step 4: Stop
----

Program::
+
[source, c]
----
include::{include_dir}/insertion_sort.c[]
----

. Selection Sort
+
Selection sort is an algorithm that selects the smallest element from an unsorted list in each iteration and places it at the beginning of the unsorted list.

Example::
** The following figure shows the first pass of a selection sort.
+
image::{imagedir}selection_sort.png[]

** In first pass the first element is compared with all remaining elements and exchange element if first one is greater than second so that the smallest value is in first place. 
Leave this element.
** In second pass compare second element to all elements put the next smallest value, in second place. 
Leave this element. 
This process is repeated till all the elements are placed.
** Now we get the sorted elements.

Algorithm::
+
----
Step 1: Set min to the first location.
Step 2: Search the minimum element in the array.
Step 3: Swap the first location with the minimum value in the array.
Step 4: Assign the second element as min.
Step 5: Repeat this process until we get a sorted array.
----

Program::
+
[source, c]
----
include::{include_dir}/selection_sort.c[]
----

. Exchange Sort
+
The exchange sort is almost similar as the bubble sort. 
The exchange sort compares each element of an array and swap those elements that are not in their proper position, just like a bubble sort does. 
The only difference between the two sorting algorithms is the manner in which they compare the elements.

.. Bubble Sort
+
Bubble sort is based on the idea of repeatedly comparing pairs of adjacent elements and then swapping positions if they exist in the wrong order.

Example::

** The following figure shows the first pass of a bubble sort. 
In first pass the first element is compared with second and exchange element if first one is greater than second.

** Similarly second element is compared with third and exchange element if second one is greater than third.
** Repeat this so that at the end of first pass the largest element is in the last position. 
Leave this element.
+
image::{imagedir}bubble_sort.png[]

** In second pass compare up to before last place value and put the next largest value, that before last place. 
Leave this element.

** This process is repeated till all the elements are placed. 
Now we get the sorted elements.

Algorithm::
+
----
Step 1: The first element is compared with second and exchange element if first one is greater than second.
Step 2: The second element is compared with third and exchange element if second one is greater than third.
Step 3: Repeat this so that at the end the largest value is in last place.
Step 4: Likewise sorting is repeated for all elements.
----

Program::
+
[source, c]
----
include::{include_dir}/bubble_sort.c[]
----

.. Quick Sort

** Quick sort is also one of the exchange sort.
** In a quick sort we take pivot element, then we place all the smaller elements are on one side of pivot, and greater elements on other side of pivot.
** After partitioning we have pivot in the final position. 
After repeatedly partitioning, we get the sorted elements.

Example::

*** Let us consider the elements: 35, 50, 15, 25, 80, 20, 90, 45
*** Let us consider the first element 35 as pivot or i. 
The last element 45 as j.
+
image::{imagedir}quick_sort-1.png[]
*** 50 which is greater than pivot taken as i and 20 smaller than pivot taken as j.
+
image::{imagedir}quick_sort-2.png[]
*** Now i is less than j so swap the elements in i and j.
+
image::{imagedir}quick_sort-3.png[]
*** Find greater than 35 (80) is i and less than 35 (25) is j.
+
image::{imagedir}quick_sort-4.png[]
*** Now i is not less than j. 
Swap 35 and j. 
So 35 comes at j place.
+
image::{imagedir}quick_sort-5.png[]
*** Now 35 is in correct position.
*** On left side and right side of 35 repeat the process. Consider on left side of 35
+
image::{imagedir}quick_sort-6.png[]
*** Let 25 as pivot. 
The lesser of 25 that is 15 as j and there is no greater. 
So bring i after j. 
i > j so swap pivot and j.
+
image::{imagedir}quick_sort-7.png[]
*** After swaping
+
image::{imagedir}quick_sort-8.png[]
*** Now the left part is sorted. 
Consider right part.
+
image::{imagedir}quick_sort-9.png[]
*** Here 80 as pivot. 
Greater than 80 is i and less than to 80 is j.
+
image::{imagedir}quick_sort-10.png[]
*** Here i is less than j, so swap i and j elements.
+
image::{imagedir}quick_sort-11.png[]
*** first find greater to 80 is i and lesser to 80 is j. 
i > j so swap 80 and j.
+
image::{imagedir}quick_sort-12.png[]
*** After swaping, the sorting elements are given by
+
image::{imagedir}quick_sort-13.png[]
*** Now join all left part j and right part j to get the sorted elements.
+
image::{imagedir}quick_sort-14.png[]

Algorithm::
+
----
Step 1: Let the first element taken as pivot.

Step 2: Find lesser of pivot say i and greater of pivot say j.

Step 3: if i is less than j then swap i and j elements. 
Repeat step 2.

Step 4: Repeat step 3 until i > j. 
Now swap j and pivot.

Step 5: Now the pivot element is in final position. 
Repeat the above procedure for left and right side of pivot elements until all elements are sorted.

Step 6: Stop
----

Program::
+
[source, c]
----
include::{include_dir}/quick_sort.c[]
----

. Distribution Sort or Radix Sort

** Randix sort is one of the sorting algorithms used to sort a list integer numbers in ascending order or descending order.

** In randix sort algorithm, a list of integer numbers will be sorted based on the digits of individual numbers. 
Sorting is performed from least significant digit to the most significant digit.

** Randix sort algorithm requires the number of passes which are equal to the number of digits present in the largest number among the list of numbers.

** For example, if the largest number is a 3 digit number then that list is sorted with 3 passes.

Example::

Consider the following list of unsorted integers:
+
82, 901, 100, 12, 150, 77, 55, 23
+
Step 1: Define 10 queues each represents a bucket for digits from 0 to 9.
+
image::{imagedir}randix-1.png[]
+
Step 2: Insert all the numbers of the list into respective queue based on the least significant digit (ones placed digit) of every number.
+
image::{imagedir}randix-2.png[]
+
Group all the numbers from queue 0 to 9 in the order they halved inserted & consider the list for next step as input list.
100, 150, 901, 82, 12, 23, 55, 77
+
Step 3: Insert all the numbers of the list into respective queue based on the next least significant digit (tens placed digit) of every number.
+
image::{imagedir}randix-3.png[]
+
Group all the numbers from queue 0 to 9 in the order they halved inserted & consider the list for next step as input list.
100, 901, 12, 23, 150, 55, 77, 82
+
Step 4: Insert all the numbers of the list into respective queue based on the next least significant digit (hundreds placed digit) of every number.
+
image::{imagedir}randix-4.png[]
+
Group all the numbers from queue 0 to 9 in the order they halved inserted & consider the list for next step as input list.
12, 23, 55, 77, 82, 100, 150, 901
List got sorted in the increasing order.

Algorithm::
+
----
Step 1 - Define 10 queues each represents a bucket for digits from 0 to 9.

Step 2 - Consider the least significant digit of every number in the list which is to be sorted.

Step 3 - Insert each number into respective queue based on the least significant digit.

Step 4 - Group all the numbers from queue 0 to 9 in the order they have inserted into their respective queues.

Step 5 - Repeat from step 3 based on the next least significant digit.

Step 6 - Repeat from step 2 until all the numbers are grouped based on the most significant digit.
----

Program::
+
[source, c]
----
include::{include_dir}/distribution_sort.c[]
----

. Merge Sort
+
It divides input array into two halves, calls itself for the two halves and then sorted and merged that two halves.

Example::
** For example consider the array of elements: 38, 27, 43, 3, 9, 82, 10

** Now the array is recursively divided into two halves till the size becomes one which is shown in the following figure.
+
image::{imagedir}merge_sort-1.png[]

** Once the size becomes one, the merge process comes into action and starts merging with sorted array till the complete array is merged.
+
image::{imagedir}merge_sort-2.png[]

Algorithm::
+
----
Step 1: If it is only one element in the list then it is already sorted.

Step 2: Divide the list recursively into two halves till the size becomes one.

Step 3: Once the size becomes 1, the merge process comes into action and starts merging with sorted array till the complete array is merged.
----
+
image::{imagedir}merge_sort-3.png[]

Program::
+
[source, c]
----
include::{include_dir}/merge_sort.c[]
----

=== Time Complexity

O(n^2) means that for every insert, it takes n*n operations. i.e. 1 operation for 1 item, 4 operations for 2 items, 9 operations for 3 items.

.Comparison of Sorting Algorithms
[cols="1,1,1,1,1"]
|===
|Algorithm|Data Structure 3+^.^|Time Complexity

|
|
|Best
|Average
|Worst

|Quick sort
|Array
|O(n log n)
|O(n log n)
|O(n^2)

|Merge sort
|Array
|O(n log n)
|O(n log n)
|O(n log n)

|Bubble sort
|Array
|O(n)
|O(n^2)
|O(n^2)

|Insertion sort
|Array
|O(n)
|O(n^2)
|O(n^2)

|Selection sort
|Array
|O(n^2)
|O(n^2)
|O(n^2)
|===

==== Complexity of Randix Sord

* Randix sort is a non-comparative sorting algorithm, it has advantages over comparative sorting algorithms.
* For the randix sort that uses counting sort as an intermediate sort, the time complexity is O(d(n+k)).
+
Here, d is the number cycle and O(n+k) is the time complexity of counting sort.
+
Thus, randix sort has linear time complexity which is than O(n log n) of comparative sorting algorithm.
* If we take very large digit numbers or the number of other bases like 32 bit and 64 bit numbers then it can perform in linear time however the intermediate sort takes large space. 
This makes randix sort space inefficient. 
This is the reason why this sort is not used in software libraries.

==== Best case, Worst case and Average case of Randix Sort
* Randix sort complexity is O(kn) for n keys which are integers of word size k.
* For all these cases time i.e best, worst and average time complexity is O(kn).

== Linked Lists

=== Introduction

A linked list is a collection of data elements called nodes in which the linear representation is given by links from one node to the next node. 
A linked list does not store its elements in consecutive memory locations and the user can add any number of nodes to the list.

The elements in a linked list can be accessed only in a sequential manner. 
But like an array, insertions and deletions can be done at any point in the list in a constant time.

A linked list, in simple terms, is a linear collection of data elements. 
These data elements are called nodes. 
Linked list a data structure which in turn can be used to implement other data structures.

Thus, it acts as a building block to implement data structures like stacks, queues and their variations.

:sectnums!:
==== Basic Terminology

A linked list can be perceived as a train or a sequence of nodes in which each node contains one or more data fields and a pointer to the next node.

image::{imagedir}linked_lists.png[]

We can see a linked list in which every node contains two parts, an integer and a pointer to the next node. 
The last node will have no next node connected to it, so it will store a special value called `NULL`.

Since in a linked list, every node contains a pointer to another node which is of the same type, it is also called a self-referential data type.

Let us see how a linked list is maintained in the memory. 
When we traverse `DATA` and `NEXT` in this manner, we finally see that the linked list in the above example stores characters that when put together form the `HELLO`.

image::{imagedir}linked_list-memory.png[]

==== Linked List vs. Array

Both arrays and linked lists are a linear collection of data elements. 
But unlike an array, a linked list does not stores its nodes in consecutive memory locations. 
Another point of difference between an array and a linked list is that a linked list does not allow random access to data. 
Nodes in a linked list can be accessed only in a sequential manner.

Another advantage of a linked list over an array is that we can add any number of elements in the list. 
This is not possible in case of an array.

==== Memory Allocation and De-allocation for a Linked List

If we want to add a node to an already existing linked list in the memory, we first find free space in the memory and then use it to store the information.

Now, the question is which part of the memory is available and which part is occupied? 
When we delete a node from a linked list, then who changes the status of the memory occupied by it from occupied to available? 
The answer is the operating system.

The operating system scans through all the memory cells and marks those cells that are being used by some program. 
Then it collects all the cells which are not being used adds their address to the free pool, so that these cells can be reused by other programs. 
The process is called garbage collection.

:sectnums:
=== Single Linked Lists

A singly linked list is the simplest type of linked list in which every node contains some data and a pointer to the next node of the same data type.

image::{imagedir}single_linked_lists.png[]

Traversing a linked list means accessing the nodes of the list in order to perform some processing on them. 
Remember a linked list always contains a pointer variable `START` which stores the address of the first node of the list. 
End of the list is marked by storing `NULL` or -1 in the `NEXT` field of the last node.

==== Operations

===== Traversing a Linked List

For traversing a linked list, we also make use of another pointer variable `PTR` which points to the node that is currently being accessed. 
Algorithm for traversing a linked list.

----
Step 1: [INITIALIZE] SET `PTR` to `START`
Step 2: Repeat Steps 3 & 4 [LOOP] WHILE `PTR` is not `NULL`
Step 3: [PROCESS] PROCESS `PTR` -> `DATA`
Step 4: [UPDATE] SET `PTR` to `NEXT`
Step 5: [TERMINATE] END
----

image::{imagedir}linked_lists.png[]

===== Searching for a value in a Linked List

Searching a linked list means to find a particular element in the linked list. 
So searching means finding whether a given value is present in the information part of the node or not. 
If it is present, the algorithm returns the address of the node that contains the value. 
However, if the search is unsuccessful, `POS` is set to `NULL` which indicates that `VAL` is not present in the linked list.

Consider the linked list shown below. 
If we have `VAL = 4`, then the flow of algorithm can be explained as shown in the figure.

image::{imagedir}linked_list-search.png[]

.Algorithm
----
Step 1: [INITIALIZE] SET `PTR` to `START`
Step 2: Repeat Steps 3  [LOOP] WHILE `PTR` is not `NULL`
Step 3: [PROCESS]                       IF `PTR` -> `DATA` = `VAL`
        [UPDATE]                                SET `POS` to `PTR`
                                                GOTO Step 5
                                        ELSE
                                                SET `PTR` to `NEXT`
                                        [END OF IF]
                                [END OF LOOP]
Step 4: [UPDATE] SET `POS` to `NULL`
Step 5: [TERMINATE] EXIT
----

===== Inserting a new node in a Linked List

We will see how a new node is added into an existing linked list. 
We will take four cases and then see how insertion is done in each.

* Case 1: New node is inserted at the beginning
* Case 2: New node is inserted at the end
* Case 3: New node is inserted after given node
* Case 4: New node is inserted before given node

Let us first discuss an important term called `OVERFLOW`. 
Overflow is a condition that occurs when AVAIL = NULL or no free memory cell is present in the system. 
when this condition occurs, the program must give an appropriate message.

====== Case 1: New node is inserted at the beginning

Inserting a node at the beginning of a Linked List. 
Consider the linked list shown in the below figure. 
Suppose we want to add a new node with data 9 and add it as the first node of the list.

image::{imagedir}linked_list-insert-case1.png[]

.Algorithm
----
Step 1: IF AVAIL = NULL
                [PROCESS] Write OVERFLOW
                [TERMINATE] GOTO Step 7
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET NEW_NODE -> NEXT = START
Step 6: SET START = NEW_NODE
Step 7: [TERMINATE] EXIT
----
====== Case 2: New node is inserted at the end
image::{imagedir}linked_list-insert-case2.png[]
.Algorithm
----
Step 1: IF AVAIL = NULL
                [PROCESS] Write OVERFLOW
                [TERMINATE] GOTO Step 9
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET NEW_NODE -> NEXT = NULL
Step 6: SET PTR = START
Step 7: WHILE PTR -> NEXT != NULL
                [PROCESS] SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 8: SET PTR -> NEXT = NEW_NODE
Step 9: [TERMINATE] EXIT
----

====== Case 3: New node is inserted after given node
Consider the liked list shown in the below figure. 
Suppose we want to add a new node with value 9 after the node with value 3.
image::{imagedir}linked_list-insert-case3.png[]
.Algorithm
----
Step 1: IF AVAIL = NULL
                [PROCESS] Write OVERFLOW
                [TERMINATE] GOTO Step 12
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET PTR = START
Step 6: SET PREPTR = PTR
Step 7: WHILE PREPTR -> DATA != NUM
Step 8:         [PROCESS] SET PREPTR = PTR
Step 9:         [PROCESS] SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 10: SET NEW_NODE -> NEXT = PREPTR -> NEXT
Step 11: SET PREPTR -> NEXT = NEW_NODE
Step 12: [TERMINATE] EXIT
----

====== Case 4: New node is inserted before given node

Consider the linked list shown in the below figure. 
Suppose we want to add a new node with value 9 before the node with value 3.
image::{imagedir}linked_list-insert-case4.png[]
.Algorithm
----
Step 1: IF AVAIL = NULL
                [PROCESS] Write OVERFLOW
                [TERMINATE] GOTO Step 12
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET PTR = START
Step 6: SET PREPTR = PTR
Step 7: WHILE PTR -> DATA != NUM
Step 8:         [PROCESS] SET PREPTR = PTR
Step 9:         [PROCESS] SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 10: SET PREPTR -> NEXT = NEW_NODE
Step 11: SET NEW_NODE -> NEXT = PTR
Step 12: [TERMINATE] EXIT
----

===== Deleting a node from a Linked List

We will discuss how a node is deleted from an already existing linked list. 
We will consider 3 cases and then see how deletion is done in each case.

* Case 1: Delete the first node
* Case 2: Delete the last node
* Case 3: Delete a node after a given node

====== Case 1: Deleting a First Node from a Linked List
image::{imagedir}linked_list-delete-case1.png[]
.Algorithm
----
Step 1: IF START = NULL
                [PROCESS] Write UNDERFLOW
                [TERMINATE] GOTO Step 5
        [END OF IF]
Step 2: SET PTR = START
Step 3: SET START = START -> NEXT
Step 4: FREE PTR
Step 5: [TERMINATE] EXIT
----

====== Case 2: Deleting the Last Node from a Linked List
image::{imagedir}linked_list-delete-case2_1.png[]
image::{imagedir}linked_list-delete-case2_2.png[]
.Algorithm
----
Step 1: IF START = NULL
                [PROCESS] Write UNDERFLOW
                [TERMINATE] GOTO Step 8
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> NEXT != NULL
Step 4:         [PROCESS] SET PREPTR = PTR
Step 5:         [PROCESS] SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 6: SET PREPTR -> NEXT = NULL
Step 7: FREE PTR
Step 8: [TERMINATE] EXIT
----

====== Case 3: Deleting After a Given Node in a Linked List

Consider the linked list shown in the below figure. 
Suppose we want to delete the node that succeeds the node with value 4.
image::{imagedir}linked_list-delete-case3.png[]
.Algorithm
----
Step 1: IF START = NULL
                [PROCESS] Write UNDERFLOW
                [TERMINATE] GOTO Step 
        [END OF IF]
Step 2: SET PTR = START
Step 3: SET PREPTR = PTR
Step 4: WHILE PREPTR -> DATA != NUM
Step 5:         [PROCESS] SET PREPTR = PTR
Step 6:         [PROCESS] SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 7: SET PREPTR -> NEXT = PTR -> NEXT
Step 8: FREE PTR
Step 9: [TERMINATE] EXIT
----

===== Reversing Single Linked Lists

image::{imagedir}linked_list-reverse.png[]

.Program
+
[source, c]
----
include::{include_dir}/reverse-single_linked_list.c[]
----

==== Applications on Single Linked List

* Implementations of stacks and queues.
* Implementation of graphs: Adjacency list representation of graphs is most popular which uses linked list to store adjacent vertices.
* Dynamic memory allocation: we use linked list of free blocks.
* Maintaining directory of names. 
Performing arithmetic operations on long integers.
* Manipulation of polynomials by storing constants in the nodes of a linked list. 
Representing sparse matrices.

===== Polynomial Expression Representation

A polynomial is composed of different terms where each of them holds a coefficient and an exponent. 
An essential characteristic of the polynomial is that each term in the polynomial expression consists of two parts: one is the coefficient and other is the exponent.

Example::
10x^2 + 26x, here 10 and 26 are coefficients and 2, 1 are its exponential values.

image::{imagedir}polynomial.png[]

===== Addition of two polynomials

----
Input:
        poly1 = 5x^2 + 4x^1 + 2x^0
        poly2 = 5x^1 + 5x^0
Output:
        Sum = 5x^2 + 9x^1 + 7x^0

Input:
        poly2 = 5x^3 + 4x^2 + 2x^0
        poly2 = 5x^1 + 5x^0
Output:
        Sum = 5x^3 + 4x^2 + 5x^1 + 7x^0
----

image::{imagedir}poly-addition.png[]

===== Multiplication of two polynomials

----
Input:
        poly1 = 3x^2 + 5x^1 + 6
        poly2 = 6x^1 + 8
Output: 
        Product = 18x^3 + 54x^2 + 76x^1 + 48
On multiplying each element of poly1 with elements of poly2, we get:
        18x^3 + 30x^2 + 36x^1 + 24x^2 + 40x^1 + 48
        On adding values with same power of x, we get:
        18x^3 + 54x^2 + 76x^1 + 48

Input:
        poly1 = 3x^3 + 6x^1 + 9
        poly2 = 9x^3 + 8x^2 + 7x^1 + 2
Output: 
        Product = 27x^6 + 24x^5 + 75x^4 + 135x^3 + 114x^2 + 75x^1 + 18
----
image::{imagedir}poly-multiplication.png[]

===== Sparse Matrix Representation using Linked List

A matrix is a two-dimensional data object made of m rows and n columns, therefore having total m x n elements. 
If most of the elements of the matrix have 0 value, then it is called a sparse matrix.

Example:
----
0 0 3 0 4
0 0 5 7 0
0 0 0 0 0
0 2 6 0 0
----

====== Sparse Matrix Representation using arrays

Method 1: Using Arrays

2D array is used to represent a sparse matrix in which there are 3 rows named as
Row: Index of row, where non-zero element is located.
Column: Index of column, where non-zero element is located.
Value: Value of non-zero element located at index - (row, column)

image::{imagedir}sparse_matrix-array.png[]

====== Sparse Matrix Representation using Linked List

Method 2: Using Linked List

In linked list, each node has four fields:
Row: Index of row, where non-zero element is located.
Column: Index of column, where non-zero element is located.
Value: Value of non-zero element located at index - (row, column)
Next node: Address of the next node.

image::{imagedir}sparse_matrix-linked_list.png[]

==== Advantages of Single Linked list

* Insertion and deletions can be done easily
* It does not need movement of elements for insertion and deletion
* Space is not wasted as we can get space according to our requirements.
* Its size is not fixed. 
It can be extended or reduced according to requirements.
* Elements may or may not be stored in consecutive memory available, even then we can store the data in computer.
* It is less expensive.

==== Disadvantages of Single Linked list

* It requires more space as pointers are also stored with information.
* Different amount of time is required to access each element.
* If we have to go to a particular element the we have to go through all those elements that come before it.
* We cannot traverse it from last and only from the beginning.
* It is not easy to sort the elements stored in the linear linked list.

=== Doubly Linked Lists

A doubly linked list or a two-way linked list is a more complex type of linked list which contains a pointer to next as well as the previous node in the sequence.

Therefore, it consists of 3 parts - data, a pointer to the next node and a pointer to the previous node.

image::{imagedir}doubly-linked_list.png[]

A doubly linked list provides the ease to manipulate the elements in the list as it maintains pointers to nodes in both the directions (forward and backward).

The main advantage of using a doubly linked list is that it makes searching twice as efficient.

Let us view how a doubly linked list is maintained in the memory.

image::{imagedir}doubly-linked_list-memory.png[]

==== Inserting a New Node in a Doubly Linked List

In this section, we will discuss how a new node is added into an already existing doubly linked list. 
We will take four cases and then see how insertion is done in each case.

* Case 1: The new node is inserted at the beginning
* Case 2: The new node is inserted at the end
* Case 3: The new node is inserted after a given node
* Case 4: The new node is inserted before a given node

===== Case 1: Inserting a Node at the Beginning of a Doubly Linked List

image::{imagedir}doubly-linked_list-insert-case1_1.png[]
image::{imagedir}doubly-linked_list-insert-case1_2.png[]

.Algorithm
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step 9
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET NEW_NODE -> PREV = NULL
Step 6: SET NEW_NODE -> NEXT = START
Step 7: SET START -> PREV = NEW_NODE
Step 8: SET START = NEW_NODE
Step 9: EXIT
----

===== Case 2: Inserting a Node at the end of a Doubly Linked List

image::{imagedir}doubly-linked_list-insert-case2.png[]

.Algorithm
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET NEW_NODE -> NEXT = NULL
Step 6: SET PTR = START
Step 7: WHILE PTR -> NEXT != NULL
Step 8:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 9: SET PTR -> NEXT = NEW_NODE
Step 10: SET NEW_NODE -> PREV = PTR
Step 11: EXIT
----

===== Case 3: Inserting a Node After a Given Node in a Doubly Linked List
image::{imagedir}doubly-linked_list-insert-case3.png[]

.Algorithm
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step 12
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET PTR = START
Step 6: WHILE PTR -> DATA != NUM
Step 7:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 8: SET NEW_NODE -> NEXT = PTR -> NEXT
Step 9: SET NEW_NODE -> PREV = PTR
Step 10: SET PTR -> NEXT -> PREV = NEW_NODE
Step 11: SET PTR -> NEXT = NEW_NODE
Step 12: EXIT
----

===== Case 4: Inserting a Node Before a Given Node in a Doubly Linked List
image::{imagedir}doubly-linked_list-insert-case4.png[]

.Algorithm
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step 12
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET PTR = START
Step 6: WHILE PTR -> DATA != NUM
Step 7:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 8: SET NEW_NODE -> NEXT = PTR
Step 9: SET NEW_NODE -> PREV = PTR -> PREV
Step 10: SET PTR -> PREV = NEW_NODE
Step 11: SET PTR -> PREV -> NEXT = NEW_NODE
Step 12: EXIT
----

==== Deleting a Node from a Doubly Linked List

In this section, we will see how a node is deleted from an already existing doubly linked list. 
We will take four cases and then see how deletion is done in each case.

* Case 1: The first node is deleted
* Case 2: The last node is deleted
* Case 3: The node after a given node is deleted
* Case 4: The node before a given node is deleted

===== Case 1: Deleting the First Node from a Doubly Linked List

image::{imagedir}doubly-linked_list-delete-case1.png[]

.Algorithm
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 6
        [END OF IF]
Step 2: SET PTR = START
Step 3: SET START = START -> NEXT
Step 4: SET START -> PREV = NULL
Step 5: FREE PTR
Step 6: EXIT
----

===== Case 2: Deleting the Last Node from a Doubly Linked List

image::{imagedir}doubly-linked_list-delete-case2_1.png[]
image::{imagedir}doubly-linked_list-delete-case2_2.png[]

.Algorithm
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 6
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> NEXT != NULL
Step 4:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 5: SET PRT -> PREV -> NEXT = NULL
Step 6: FREE PTR
Step 7: EXIT
----

===== Case 3: Deleting the Node After a Given Node in a Doubly Linked List

image::{imagedir}doubly-linked_list-delete-case3.png[]

.Algorithm
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 9
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> DATA != NUM
Step 4:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 5: SET TEMP = PTR -> NEXT
Step 6: SET PTR -> NEXT = TEMP -> NEXT
Step 7: SET TEMP -> NEXT -> PREV = PTR
Step 8: FREE TEMP
Step 9: EXIT
----

===== Case 4: Deleting the Node Before a Given Node in a Doubly Linked List

image::{imagedir}doubly-linked_list-delete-case4.png[]

.Algorithm
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 9
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> DATA != NUM
Step 4:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 5: SET TEMP = PTR -> PREV
Step 6: SET TEMP -> PREV -> NEXT = PTR
Step 7: SET PTR -> PREV = TEMP -> PREV
Step 8: FREE TEMP
Step 9: EXIT
----

=== Circular Linked Lists

In a circular linked list, the last node contains a pointer to the first node of the list. 
We can have a circular singly linked list as well as a circular doubly linked list.

While traversing a circular linked list, we can begin at any node and traverse the list in any direction, forward or backward, until we reach the same node where we started. 
Thus a circular linked list has no beginning or no ending.

Note that there are no NULL values in the NEXT part of any of the nodes of list.

==== Operation

===== Inserting a New Node in a Circular Linked List

In this section, we will see how a new node is added into an already existing linked list. 
We will take two cases and then see how insertion is done in each case.

* Case 1: The new node is inserted at the beginning of the circular linked list
* Case 2: The new node is inserted at the end of the circular linked list

====== Case 1: Inserting a Node at the Beginning of a Circular Linked List

image::{imagedir}circular-linked_list-insert-before-1.png[]
image::{imagedir}circular-linked_list-insert-before-2.png[]

.Algorithm
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step 11
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET PTR = START
Step 6: WHILE PTR -> NEXT != START
Step 7:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 8: SET NEW_NODE -> NEXT = START
Step 9: SET PTR -> NEXT = NEW_NODE
Step 10: SET START = NEW_NODE
Step 11: EXIT
----

====== Case 2: Inserting a Node at the End of a Circular Linked List

image::{imagedir}circular-linked_list-insert-end-1.png[]
image::{imagedir}circular-linked_list-insert-end-2.png[]

.Algorithm
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step 10
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET NEW_NODE -> NEXT = START
Step 6: SET PTR = START
Step 7: WHILE PTR -> NEXT != START
Step 8:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 9: SET PTR -> NEXT = NEW_NODE
Step 10: EXIT
----

===== Deleting a Node from a Circular Linked List

In this section, we will discuss how a node is deleted from an already existing circular linked list. 
We will take 2 cases and then see how deletion is done in each case. 
Rest of the cases of deletion are same as that given for singly linked lists.

* Case 1: The first node is deleted
* Case 2: The last node is deleted

====== Case 1: Deleting the First Node from a Circular Linked List

image::{imagedir}circular-linked_list-delete-first.png[]

.Algorithm
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 8
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> NEXT != START
Step 4:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 5: SET PTR -> NEXT = START -> NEXT
Step 6: FREE START
Step 7: SET START = PTR -> NEXT
Step 8: EXIT
----

====== Case 2: Deleting the Last Node from a Circular Linked List

image::{imagedir}circular-linked_list-delete-last.png[]

.Algorithm
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 8
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> NEXT != START
Step 4:         SET PREPTR = PTR
Step 5:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 6: SET PREPTR -> NEXT = START
Step 7: FREE PTR
Step 8: EXIT
----

== Queues & Stacks

=== Queues

==== Introduction to Queues

Let us explain the concept of queues using the analogies given below.

* People moving on an escalator. 
The people who got on the escalator first will be the first one to step out of it.
* People waiting for a bus. 
The first person standing in the line will be the first to get into the bus.
* People standing outside the ticketing window of a cinema hall. 
The first person in the line will get the ticket first and thus will be the first one to move out of it.
* Luggage kept on conveyor belts. 
The bag which was placed first will be the first to come out at the other end.
* Cars lined at a toll bridge. 
The first car to reach the bridge will be the first to leave.

In all these examples, we see that the element at the first position is served first. 
Same is the case with queue data structure. 
A queue is FIFO (First In First Out) data structure in which the element that is inserted first is the first one to be taken out. 
The elements in a queue are added at one end called the `REAR` and removed from the other end called the `FRONT`. 
Queues can be implemented by using either array or linked list. 
In this section we will see how queues are implemented using each of these data structures.

==== Array Representation and Implementation of Queues

Queues can be easily represented using linear arrays. 
As stated earlier, every queue has front and rear variables that point to the position from where deletions and insertions can be done, respectively.

The array representation of a queue is shown in Fig. 3.1.

image::{imagedir}queue-array.png[]

===== Operations on Queues

In Fig.3.1, FRONT = 0 and REAR = 5. 
Suppose we want to add another element with value 45, the REAR would be incremented by 1 and the value would be stored at the position pointed by REAR.

The queue after addition would be as shown in Fig. 3.2. 
Here, FRONT = 0 and REAR = 6. 
Every time  new element has to be added, we repeat the same procedure.

If we want to delete an element from the queue, then the value of FRONT will be incremented. 
Deletions are done from only this end of the queue.      
The queue after deletion would be as shown in Fig. 3.3. 
Here, FRONT = 1 and REAR = 6.

However, before inserting an element in a queue, we must check for overflow conditions. 
An overflow will occur when we try to insert an element into a queue that is already full. 
When REAR = MAX - 1, where MAX is the size of the queue, then we have an overflow condition. 
Note that we have written MAX -1 because the index starts from 0. 
Similarly, before deleting an element from a queue, we must check for underflow conditions. 
An underflow condition occurs when we try to delete an element from a queue that is already empty. 
If FRONT = -1 and REAR = -1, it means there is no element in the queue.

.Algorithm for Insertion in Queues
----
Step 1: IF REAR = MAX - 1
                Write OVERFLOW
                GOTO Step 4
        [END OF IF]
Step 2: IF FRONT = -1 and REAR = -1
                SET FRONT = REAR = 0
        ELSE
                SET REAR = REAR + 1
        [END OF IF]
Step 3: SET QUEUE[REAR] = NUM
Step 4: EXIT
----

.Algorithm for Deletion in Queues
----
Step 1: IF FRONT = -1 and FRONT > REAR
                Write UNDERFLOW
        ELSE
                SET VAL = QUEUE[FRONT]
                SET FRONT = FRONT + 1
        [END OF IF]
Step 2: EXIT
----

NOTE: The process of inserting an element in the queue is called enqueue and the process of deleting an element from the queue is called dequeue.

==== Linked List Representation and Implementation of Queues

We have seen how a queue is created using an array. 
Although this technique of creating queue is easy, its drawback is that the array must be declared to have some fixed size. 
If we allocate space for 50 elements in the queue and it hardly uses 20-25 locations, then half of the space will be wasted.

And in case we allocate less memory locations for a queue that might end up growing large and large, then a lot of re-allocations will have to be done, thereby creating a lot of overhead and consuming a lot of time.

In case the queue is a very small one or its maximum size is known in advance, then the array implementation of the queue gives an efficient implementation, 
But if the array size cannot be determined in advance, the other alternative i.e., the linked representation.

The storage requirement of linked representation of a queue with n elements is O(n) and the typical time requirement for operations is O(1).

In a linked queue, every element has two parts, one that stores the data and another that stores the address of the next element. 
The `START` pointer of the linked list is used as `FRONT`. 
Here we will also use another pointer called `REAR`, which will store the address of the last element in the queue.

All insertions will be done at the rear end and all the deletions will be done at the front end. 
If `FRONT` = `REAR` = `NULL`, then it indicates that the queue is empty. 
The linked representation of a queue is shown in Fig.3.4.

===== Insert Operation

The insert operation is used to insert an element into a queue. 
The new element is added as the last element of the queue. 
Consider the linked queue shown in Fig.3.5.

image::{imagedir}queue-linked_list-insert.png[]

To insert an element with value 9, we first check if `FRONT == NULL`. 
If the condition holds, then the queue is empty. 
So, we allocate memory for a new node, store the value in its data part and `NULL` in its next part. 
The new node will then be called both `FRONT` and `REAR`. 
However, if `FRONT != NULL`, then we will insert the new node at the `REAR` end of the linked queue and name this new node as `REAR`. 
Thus the updated queue becomes as shown in Fig.3.6.

.Algorithm to insert an element in a linked queue
----
Step 1: Allocate memory for the new node and name it as PTR
Step 2: SET PTR -> DATA = VAL
Step 3: IF FRONT = NULL
                SET = FRONT = REAR = PTR
                SET FRONT -> NEXT = REAR -> NEXT = NULL
        ELSE
                SET REAR -> NEXT = PTR
                SET REAR = PTR
                SET REAR -> NEXT = NULL
        [END OF IF]
Step 4: END
----

The algorithm shows that inserting an element in a linked queue.

In step 1, the memory is allocated for the new node. 

In step 2, the `DATA` part of the new node is initialize with the value to be stored in the node. 

In step 3, we check if the new node is the first node of the linked queue. 
This is done by checking if `FRONT = NULL`. 
If this is the case, then the new node is tagged as `FRONT` as well as `REAR`. 
Also `NULL` is stored in the `NEXT` part of the node. 
However, if the new node is not the first node in the list, then it is added at the `REAR` end of the linked queue (or the last node of the queue).

===== Delete Operation

The delete operation is used to delete the element that is first inserted in a queue, i.e., the element whose address is stored in `FRONT`. 
However, for deleting the value, we must first check if `FRONT == NULL` because if this is the case, then the queue is empty and no more deletions can be done. 
If an attempt is made to delete a value from a queue that is already empty, an underflow message is printed. 
Consider the queue shown in Fig.3.7

image::{imagedir}queue-linked_list-delete.png[]

.Algorithm to delete an element in a linked queue
----
Step 1: IF FRONT = NULL
                Write "Underflow"
                Go to Step 5
        [END OF IF]
Step 2: SET PTR = FRONT
Step 3: SET FRONT = FRONT -> NEXT
Step 4: FREE PTR
Step 5: END
----

==== Applications of Queues

* Queues are widely used as waiting lists for a single shared resource like printer, disk, CPU
* Queues are used to transfer data asynchronously (data  not necessarily received at same rate as sent) between two processes (IO buffers), e.g., pipes, file IO, sockets.
* Queues are used as buffers on MP3 players and portable CD players, iPod playlist.
* Queues are used in playlist for jukebox to add songs to the end, play from the front of the list.
* Queues are used in operating system for handling interrupts. 
When programming a real-time system that can interrupted, for example, by a mouse click, it is necessary to process the interrupts immediately, before proceeding with the current job. 
If the interrupts have to be handled in the order of arrival, then a FIFO queue is the appropriate data structure.

==== Types of Queues

A queue data structure can be classified into the following types:

. Circular Queue
. Deque
. Priority Queue
. Multiple Queue

We will discuss each of these in detail in the following sections.

===== Circular Queues

In linear queues, we have discussed so far that insertions can be done only at one end called the `REAR` and deletions are always done from the other end called the `FRONT`. 
Look at the queue shown in Fig.3.9.

image::{imagedir}queue-linear.png[]

Here, FRONT = 0 and REAR = 9

Now, if you want to insert another value, it will not be possible because the queue is completely full. 
There is no empty space where the value can be inserted. 
Consider a scenario in which two successive deletions are made. 
The queue will then be given as shown in Fig.3.10.

image::{imagedir}queue-linear-deletions.png[]

Here, FRONT = 2 and REAR = 9

Suppose we want to insert a new element in the queue shown in Fig.3.10. 
Even though there is space available, the overflow condition still exists because the condition `REAR = MAX -1` still holds true. 
This is a major drawback of a linear queue.

To resolve this problem, we have two solutions. 
First, shift the elements to the left so that the vacant space can be occupied and utilized efficiently. 
But this can be very time-consuming, especially when the queue is quite large.

The second option is to use a circular queue. 
In the circular queue, the index comes right after the last index. 
Conceptually, you can think of a circular queue as shown in Fig.3.11.

image::{imagedir}queue-circualr.png[]

The circular queue will be full only when `FRONT = 0` and `REAR = Max -1`. 
A circular queue is implemented in the same manner as a linear queue is implemented. 
The only difference will be in the code that performs insertion and deletion operations.

====== Insertion

For insertion, we now have to check for the following 3 conditions:

* If `FRONT = 0` and `REAR = MAX - 1`, then the circular queue if full. 
Look at the queue given in Fig.3.12 which illustrates this point.
* If `REAR != MAX - 1`, then `REAR` will be incremented and the value will be inserted as illustrated in Fig.3.13.
* If `FRONT != 0` and `REAR = MAX - 1`, then it means that the queue is not full. 
So, set `REAR = 0` and insert the new element there, as shown in Fig.3.14.

image::{imagedir}queue-circular-insert.png[]

.Algorithm
----
Step 1: IF FRONT = 0 and REAR = MAX -1
                Write "Overflow"
                GOTO step 4
        [END OF IF]
Step 2: IF FRONT = -1 and REAR = -1
                SET FRONT = REAR = 0
        ELSE IF REAR = MAX - 1 and FRONT != 0
                SET REAR = 0
        ELSE
                SET REAR = REAR + 1
        [END OF IF]
Step 3: SET QUEUE[REAR] = VAL
Step 4: EXIT
----

Let us look at the algorithm to insert an element in a circular queue. 

In step 1, we check for the overflow condition. 

In step 2, we make two checks. 
First to see if the queue is empty, and second to see if the `REAR` end has already reached the maximum capacity while there are certain free locations before the `FRONT` end. 

In step 3, the value is stored in the queue at the location pointed by `REAR`.

====== Deletion

Let us now discuss how deletions are performed in this case. 
To delete an element, again we check for 3 conditions.

* Look at Fig.3.15. 
If `FRONT = -1`, then there are no elements in the queue. 
So, an underflow condition will be reported.
* If the queue is not empty and `FRONT = REAR`, then after deleting the element at the front the queue becomes empty and so `FRONT` and `REAR` are set to -1. 
This is illustrated in Fig.3.16.
* If the queue is not empty and `FRONT = MAX - 1`, then after deleting the element at the `FRONT`, `FRONT` is set to 0. 
This is shown in Fig.3.17.

image::{imagedir}queue-circular-delete.png[]

.Algorithm
----
Step 1: IF FRONT = -1
                Write "Underflow"
                GOTO step 4
        [END OF IF]
Step 2: SET VAL = QUEUE[FRONT]
Step 3: IF FRONT = REAR
                SET FRONT = REAR = -1
        ELSE
                IF FRONT = MAX - 1
                        SET FRONT = 0
                ELSE
                        SET FRONT = FRONT + 1
                [END OF IF]
        [END OF IF]
Step 4: Exit
----

Let us look at the algorithm to delete an element form a circular queue. 

In step 1, we check for the underflow condition. 

In step 2, the value of the queue at the location point by `FRONT` is stored in VAL. 

In step 3, we make 2 checks. 
First to see if the queue has become empty after deletion and 
second to see if `FRONT` has reached the maximum capacity of the queue. 
The value of `FRONT` is then updated based on the outcome of these checks.

===== Deques

A deque (pronounced as 'deck' or 'dequeue') is a list in which the elements can be inserted or deleted at either end. 
It is also known as a head-tail linked list because elements can be added to or removed from either the front (head) or the back (tail) end.

However, no element can be added and deleted from the middle. 
In the computer's memory, a deque is implemented using either a circular array or a circular doubly linked list.

In a deque, two pointers are maintained, LEFT and RIGHT, which point to either end of the dequeue. 
The elements in a deque extend from the LEFT end to the RIGHT end and since it is circular, Dequeue[N-1] is followed by Dequeue[0].
Consider the deques shown in Fig.3.18

image::{imagedir}queue-dequeue.png[]

There are 2 variants of a double-ended queue. 
They include

. `Input restricted deque`. In this dequeue, insertions can be done only at one of the ends, while deletions can be done from both ends.
. `Output restricted deque`. In this dequeue, deletions can be done only at one of the ends, while insertions can be done from both ends.

===== Priority Queues

A priority queue is a data structure in which each element is assigned a priority. 
The priority of the element will be used to determine the order in which the elements will be processed. 
The general rules of processing the elements of a priority queue are

* An element with higher priority is processed before an element with a lower priority.
* 2 elements with the same priority are processed on the first-come-first-served (FCFS) basis.

A priority queue can be thought of as a modified queue in which when an element has to be removed from the queue, the one with the highest-priority is retrieved first. 
The priority of the element can be set based on various factors. 
Priority queues are widely used in operation systems to execute the highest priority process first. 
The priority of the process may be set based on the CPU time it requires to get executed completely.

====== Implementation of a Priority Queue

There are 2 ways to implement a priority queue. 
We can either use a sorted list to store the elements so that when an element has to taken out, the queue will not have to be searched for the element with the highest priority or we can use an unsorted list so that insertions are always done at the end of the list.

Every time when an element has to be removed from the list, the element with the highest priority will be searched and removed. 
While a sorted list takes O(n) time to insert an element in the list, it takes only O(1) time to delete an element. 
On the contrary, an unsorted list will take O(1) time to insert an element and O(n) time to delete and element from the list.

Practically, both these techniques are inefficient and usually a blend of these two approaches is adopted that takes roughly O(log n) time or less.

===== Multiple Queues

When we implement a queue using an array, the size of the array must be known in advance. 
If the queue is allocated less space, then frequent overflow conditions will be encountered.

To deal with this problem, the code will have to be modified to reallocate more space for the array. 
In case we allocate a large amount of space for the queue, it will result in sheer wastage of memory.

Thus, there lies a tradeoff between the frequency of overflows and the space allocated. 
So a better solution to deal with this problem is to have multiple queues or to have more than one queue in the same array of sufficient size. 
Fig.3.19 illustrates this concept.

image::{imagedir}queue-multiple-queues.png[]

In the figure, an array Queue[n] is used to represent 2 queues, Queue A and Queue B. 
The value of n is such that the combined size of both the queues will never exceed n. 
While operating on these queues, it is important to note one thing, Queue A will grow from left to right, 
whereas Queue B will grow from right to left at the same time. 
Extending the concept to multiple queues, a queue can also be used to represent n number of queues in the same array. 
That is, if we have a QUEUE[n], then each queue will be allocated an equal amount of space bounded by indices b[i] and e[i]. 
This is shown in Fig.3.20.

=== Stacks

==== Introduction to Stacks

Stack is an important data structure which stores its elements in an ordered manner. 
We will explain the concept of stacks using an analogy. 
You must have seen a pile of plates where one plate is placed on top of another as shown in Fig.3.21.

Now, when you want to remove a plate, you remove the topmost plate first. 
Hence, you can add and remove an element (i.e. a plate) only at/from on position whish is topmost position.

image::{imagedir}stack-plates.png[]

A stack is a linear data structure which uses the same principle, i.e. the elements in a stack are added and removed only from one end, which is called `TOP`.

Hence, a stack is called LIFO (Last-In-First-Out) data structure, as the element that was inserted last is the first one to be taken out.

==== Array Representation of Stacks

In the computer's memory, stacks can be represented as a linear array. 
Every stack has a variable called `TOP` associated with it, which is used to store the address of the topmost element of the stack. 
It is this position where the element will be added to or deleted from.

The is another variable called `MAX`, which is used to store the maximum number of elements that the stack can hold. 
If `TOP = NULL`, then it indicates that the stack is empty and if `TOP = MAX -1`, then the stack is full. 
You must be wondering why we have written MAX-1. 
It is because array indices start from 0. 
Look at fig.3.22.

image::{imagedir}stack-1.png[]

===== Operations on Stacks

A stack supports 3 basic operations:

. push
. pop
. peek

The `push` operation add an element to top of the stack and 
the `pop` operation removes an element from top of stack. 
The `peek` operation returns the value of the topmost element of the stack.

====== Push Operation

* The `push` operation is used to insert an element into the stack.
* The new element is added at the topmost position of the stack.
* To insert an element with value 6, we first check if `TOP = MAX - 1`.
* If the condition is false, then we increment the value of `TOP` and store the new element at the position given by stack[TOP].

image::{imagedir}stack-push.png[]

.Algorithm stack push
----
Step 1: IF TOP = MAX - 1
                PRINT "OVERFLOW"
                GOTO step 4
        [END OF IF]
Step 2: SET TOP = TOP + 1
Step 3: SET STACK[TOP] = VALUE
Step 4: END
----

====== Pop Operation

* The `pop` operation is used to delete the topmost element from the stack.
* However, before deleting the value, we must first check if `TOP = NULL` because if that is the case, then it means the stack is empty and no more deletions can be done.
* To delete the topmost element, we first check if `TOP = NULL`. 
IF the condition is false, then we decrement the value pointed by `TOP`.

image::{imagedir}stack-pop.png[]

.Algorithm Stack POP
----
Step 1: IF TOP = NULL
                PRINT "UNDERFLOW"
                GOTO Step 4
        [END OF IF]
Step 2: SET VAL = STACK[TOP]
Step 3: SET TOP = TOP - 1
Step 4: END
----

====== Peek Operation

* Peek is an operation that returns the value of the topmost element of the stack without deleting it from the stack.
* However, the peek operation first checks if the stack is empty, i.e. if TOP = NULL, then an appropriate message is printed, else the value is returned.
* Here, the peek operation will return 5, s it is the value of the topmost element of the stack.

.Algorithm Stack Peek
----
Step 1: IF TOP = NULL
                PRINT "STACK IS EMPTY"
                GOTO Step 3
Step 2: RETURN STACK[TOP]
Step 3: END
----

.EXAMPLE
image::{imagedir}stack-example.png[]

==== Linked Representation of Stacks

We have seen how a stack is created using an array. 
This technique of creating a stack is easy, but the drawback is that the array must be declared to have some fixed size. 
In case the stack is very small one or its maximum size is known in advance, then the array implementation of the stack gives an efficient implementation. 
But if the array size cannot be determined in advance, then the other alternative, i.e. linked representation, is used.

The storage requirement of linked representation of the stack with `n` elements is O(n), and the typical time requirement for the operation is O(1).

In a linked stack, every node has 2 parts - 
one that stores data and another that stores the address of the next node. 
The `START` pointer of the linked list is used as `TOP`. 
All insertions and deletions are done at the node pointed by `TOP`. 
If `TOP = NULL`, then it indicates that the stack is empty. 
The linked representation of a stack is shown in below figure.

image::{imagedir}stack-linked_list.png[]

===== Push Operation

The push operation is used to insert an element into the stack. 
The new element is added at the topmost position of the stack. 
Consider the linked stack shown in below figure.

image::{imagedir}stack-linked_list-pop-1.png[]

To insert an element with value 9, 
we first check if `TOP = NULL`. 
If this is the case, then we allocate memory for a new node, store the value in its `DATA` part and `NULL` in its `NEXT` part. 
The new node will then be called `TOP`. 
However, if `TOP != NULL`, then we insert the new node at the beginning of the linked stack and name this new node as `TOP`.

image::{imagedir}stack-linked_list-pop-2.png[]

The algorithm to push an element into a linked stack. 

In step 1, memory is allocated for the new node. 

In step 2, the DATA part of the new node is initialized with the value to be stored in the node. 

In step 3, we check if the new node is the first node of the linked list, is done by checking if TOP = NULL. 
In case the IF statement evaluates to true, then NULL is stored in the NEXT part of the node and new node is called `TOP`.

However, if the new node is not the first node in the list, then it is added before the first node of the list (i.e., the `TOP` node) and termed as `TOP`.

.Algorithm Stack Linked Push
----
Step 1: Allocate memory for the new node and name it as NEW_NODE
Step 2: SET NEW_NODE -> DATA = VAL
Step 3: IF TOP = NULL
                SET NEW_NODE -> NEXT = NULL
                SET TOP = NEW_NODE
        ELSE
                SET NEW_NODE -> NEXT = TOP
                SET TOP = NEW_NODE
        [END OF IF]
Step 4: END
----

===== POP Operation

The `pop` operation is used to delete the topmost element from a sack. 
However, before deleting the value, we must first check if TOP = NULL, because if this is the case, then it means that the stack is empty and no more deletions can be done. 
If an attempt is made to delete a value from a stack that is already empty, an `UNDERFLOW` message is printed. 
Consider the stack shown in below figure.

image::{imagedir}stack-linked_list-pop-1.png[]

In case TOP != NULL, then we will delete the node pointed by TOP, and make TOP point to the second element of the linked stack. 
Thus, the updated stack becomes as shown in below figure.

image::{imagedir}stack-linked_list-pop-2.png[]

.Algorithm Stack Linked POP
----
Step 1: IF TOP = NULL
                PRINT "UNDERFLOW"
                GOTO step 5
        [END OF IF]
Step 2: SET PTR = TOP
Step 3: SET TOP = TOP -> NEXT
Step 4: FREE PTR
Step 5: END
----

The algorithm to delete an element from a stack:

In step 1, we first check for the UNDERFLOW condition.

In step 2, we use a pointer PTR that points to TOP.

In step 3, TOP is made to point to the next node in sequence.

In step 4, the memory occupied by PTR is given back to the free pool.

==== Applications of Stacks

In this section we will discuss typical problems where stacks can be easily applied for a simple and efficient solution. 
The topics that will be discussed in this section include the following:

* Reversing a list
* Parentheses checker
* Conversion of an infix expression into a postfix expression
* Evaluation of a postfix expression
* Conversion of an infix expression into a prefix expression
* Evaluation of a prefix expression
* Recursion
* Tower of Hanoi

===== Reversing List

A list of numbers can be reversed by reading each number from an array starting from the first index and pushing it on a stack. 
Once all the numbers have been read, the numbers can be popped one at a time and then stored in an array starting from the first index.

image::{imagedir}reversed-linked_list.png[]

===== Evaluation of Arithmetic Expressions

:sectnums!:
====== Polish Notations

Infix, postfix and prefix notations are 3 different but equivalent notations of writing algebraic expressions. 
But before learning about prefix and postfix notations, let us first see what an infix notation is. 
We all are familiar with the infix notation of writing algebraic expressions.

While writing an arithmetic expression using infix notation, the operator is placed in between the operands. 
For example, A + B; here, plus operator is placed between the operands A and B. 
Although it is easy for us to write expressions using infix notation, computers find it difficult to parse as the computer needs a lot of information to evaluate the expression. 
Information is needed about operator precedence and associativity rules, and brackets which override these rules.

So, computers work more efficiently with expressions written using prefix and postfix notations. 
Postfix notation was developed by Jan Lukasiewicz who was a polish logician, mathematician and philosopher. 
His aim was to develop a parenthesis-free prefix notation (also known as polish notation) and a postfix notation, which is better known as Reverse Polish Notation (RPN).

In postfix notation, as the name suggests, the operator is placed after the operands. 
For example, if an expression is written as A + B in infix notation, the same expression can be written as AB+ in postfix notation. 
The order of evaluation of postfix expression is always from left to right. 
Even brackets cannot alter the order of evaluation.

----
The expression (A + B) * C can be written as:
[AB+]*C
AB+C* in postfix notation
----

A postfix operation does not even follow the rules of operator precedence. 
The operator which occurs first in the expression is operated first on the operands.

For example, given a postfix notation AB+C*. 
While evaluation, addition will be performed prior to multiplication. 
Thus we see that in a postfix notation, operators are applied to the operands that are immediately left to them. 
In the example, AB+C*, + is applied on A and B, then * is applied on the result of addition and C.

image::{imagedir}in-pre-post-fix.png[]

====== Conversion of an Infix Expression into a Postfix Expression

Let I be an algebraic expression in infix notation. 
I may contain parentheses, operands and operators. 
For simplicity of the algorithm we will use only +, -, *, /, % operators.

The precedence of these operators can be given as follows:
* Higher priority *, /, %
* Lower priority +, -

No doubt, the order of evaluation of these operators can be changed by making use of parentheses. 
For example, if we have an expression A + B * C, then first B * C will be done and the result will be added to A. 
But the same expression if written as, (A + b) * C, will evaluate A + B first and then the result will be multiplied with C.

Example: Convert the following infix expressions into postfix expressions.

a). (A - B) * (C + D)

Solution:
----
[AB-]*[CD+]
AB-CD+*
----

b). (A + B) / (C + D) - (D * E)

Solution:
----
[AB+]/[CD+]-[DE*]
[AB+CD+/]-[DE*]
AB+CD+/DE*-
----

The algorithm given below transforms an infix expression into postfix expression. 
The algorithm accepts an infix expression that may contain operators, operands and parentheses.

For simplicity, we assume that the infix operation contains only modulus (%), division (/), multiplication (*), addition (+) and subtraction (-) operators and that operators with same precedence are performed from left-to-right.

The algorithm uses a stack to temporarily hold operators. 
The postfix expression is obtained from left-to-right using the operand from the infix expression and the operators which are removed from the stack. 
The first step in this algorithm is to push the left parenthesis on the stack and to add a corresponding right parenthesis at the end of the infix expression.

The algorithm is repeated until the stack is empty.

-----
Step 1: Add ")" to the end of the infix expression
Step 2: Push "(" on to the stack
Step 3: Repeat until each character in the infix notation is scanned
        IF a "(" is encountered, push it on the stack
        IF an operand (whether a digit or a character) is encountered, add it to the postfix expression.
        IF a ")" is encountered, then
                a. Repeatedly pop from stack and add it to the postfix expression until a "(" is encountered.
                b. Discard the "(". That is, remove the "(" from the stack and do not add it to the postfix expression.
        IF an operator O is encountered, then
                a. Repeatedly pop from stack and add each operator (popped fromt the stack) to the postfix expression which has the same precedence or a higher precedence than O.
                b. Push O on to the stack.
        [END OF IF]
Step 4: Repeatedly pop from the stack and add it to the postfix expression until the stack is empty.
Step 5: EXIT
-----

Example: Convert the following the infix expression into postfix expression using the algorithm

A - (B / C + (D % E * F) / G) * H

[%header,cols="1,2,3"]
|====
|Infix Character Scanned|Stack|Postfix Expression

|       |(              |
|A      |(              |A
|-      |( -            |A
|(      |( - (          |A
|B      |( - (          |A B
|/      |( - ( /        |A B
|C      |( - ( /        |A B C
|+      |( - ( +        |A B C /
|(      |( - ( + (      |A B C /
|D      |( - ( + (      |A B C / D
|%      |( - ( + ( %    |A B C / D
|E      |( - ( + ( %    |A B C / D E
|*      |( - ( + ( % *  |A B C / D E
|F      |( - ( + ( % *  |A B C / D E F
|)      |( - ( +        |A B C / D E F * %
|/      |( - ( + /      |A B C / D E F * %
|G      |( - ( + /      |A B C / D E F * % G
|)      |( -            |A B C / D E F * % G / +
|*      |( - *          |A B C / D E F * % G / +
|H      |( - *          |A B C / D E F * % G / + H
|)      |               |A B C / D E F * % G / + H * -

|====

====== Evaluation of a postfix expression

The ease of evaluation acts as the driving force for computers to translate an infix notation into a postfix notation. 
That is, given an algebraic expression written in infix notation, the computer fist converts the expression into the equivalent postfix notation and then evaluates the postfix expression.

Both these tasks - converting the infix notation into postfix notation and evaluating the postfix expression - make extensive use of stacks as the primary tool.

Using stacks, any postfix expression can be evaluated very easily. 
Every character of the postfix expression is scanned from left to right. 
If the character encountered is an operand, it is pushed on to the stack. 
However, if an operator is encountered, then the top 2 values are popped from the stack and the operator is applied on these values. 
The result is then pushed on to the stack.

.Algorithm to evaluate a postfix expression
----
Step 1: Add a ")" at the end of the postfix expression
Step 2: Scan every character of the postfix expression and repeat 3 and 4 until ")" is encountered.
Step 3: If an operand is encountered, push it on to the stack
        IF an operator O is encountered, then
                a. Pop the top 2 values from the stack as A and B
                b. Evaluate B O A, wher A is the topmost element and B is the element below A
                b. Push the result of evaluation on to the stack
        [END OF IF]
Step 4: SET RESULT equal to the topmost element of the stack
Step 5: EXIT
----

Let us now take an example that makes use of this algorithm.
+
Consider the infix expression given as 9 - ((3 * 4) + 8) / 4. 
Evaluate the expression.

The infix expression 9 - ((3 * 4) + 8) / 4 can be written as 9 3 4 * 8 + 4 / - using postfix notation.

.Evaluation of a postfix expression
[%header,cols="1,2"]
|====
|Character Scanned|Stack
|9               |9
|3               |9, 3
|4               |9, 3, 4
|*               |9, 12
|8               |9, 12, 8
|+               |9, 20
|4               |9, 20, 4
|/               |9, 5
|-               |4
|====

===== Factorial Calculation

We know n! = n * (n-1)! = n * (n-1) * (n-2)! and so on.

Recursion: factorial(n) = n * factorial(n-1)

factorial(5) = 5 * factorial(4) -> Push(5)

[width=5%]
|====
|
|
|
|
|5
|====

factorial(4) = 4 * factorial(3) -> Push(4)
[width=5%]
|====
|
|
|
|4
|5
|====

factorial(3) = 3 * factorial(2) -> Push(3)
[width=5%]
|====
|
|
|3
|4
|5
|====

factorial(2) = 2 * factorial(1) -> Push(2)
[width=5%]
|====
|
|2
|3
|4
|5
|====

factorial(1) = 1 * factorial(0) = returns 1 -> Push(1)
[width=5%]
|====
|1
|2
|3
|4
|5
|====

Pop(1) Factorial value = 1

Pop(2) Factorial value = 1 * 2 = 2

Pop(3) Factorial value = 2 * 3 = 6

Pop(4) Factorial value = 6 * 4 = 24

Pop(5) Factorial value = 24 * 5 = 120

Factorial value = 120

:sectnums:
== Trees

=== Basic Terminology in Trees

A tree is recursively defined as a set of one or more nodes where on node is designates as root of the tree and all the remaining nodes can partitioned into non-empty sets each of which is sub-tree of the root. 
Figure 4.1 shows a tree where node A is the root node; nodes B, C and D are children of the root node and form sub-trees of the tree rooted at node A.

image::{imagedir}tree-detail.png[]

Root Node:: The root node R is the topmost node in the tree. 
If R = NULL, then it means the tree is empty.

Sub-trees:: If the root node R is not NULL, then the trees T1, T2 and T3 are called the sub-trees of R.

Leaf-node:: Anode that has no children is called the leaf node or the terminal node.

Path:: A sequence of consecutive edges is called a path. 
For example in Fig.4.1, the path from the root node A to node I is given as: A, D and I.

Ancestor node:: An ancestor of a node is any predecessor node on the path from root to that node. 
The root node does not have any ancestors. 
In the tree given in Fig.4.1, nodes C, G, J and K are the descendants of node A.

Level number:: Every node in the tree is assigned a level number in such a way that the root node is at level 0, children of the root node are at level number 1. 
Thus, every node is at one level higher that its parent. 
So, all child nodes have a level number given by parent's level number + 1.

Degree:: Degree of a node is equal to the number of children that a node has. 
The degree of a leaf node is zero.

In-degree:: In-degree of a node is the number of edges arriving at the node.

Out-degree:: Out-degree of a node is the number of edges leaving that node.

=== Binary Trees

A binary tree is a data structure that is defined as a collection of elements called nodes. 
In a binary tree, the topmost element is called the root node, and each node has 0, 1 or at the most 2 children.

A node that has zero children is called a leaf node or a terminal node. 
Every node contains a data element, a leaf pointer which points to the left child and a right pointer which points to the right child. 
The root element is pointed by a 'root' pointer. 
If root = NULL, then it means the tree is empty.

Figure 4.2 shows a binary tree. 
In figure, R is the root node and the two trees T1 and T2 are called the left and right sub-trees of R. 
T1 is said to be the left successor of R. 
Likewise, T2 is called the right successor of R.

image::{imagedir}tree-binary.png[]

Note that the left sub-tree of the root node consists of the nodes: 2, 4, 5, 8 and 9. 
Similarly, the right sub-tree of the root node consists of nodes: 3, 6, 7, 10, 11 and 12.

In the tree, root node 1 has two successors: 2 and 3. 
Node 2 has two successor nodes: 4 and 5. 
Node 4 has two successors: 8 and 9. 
Node 5 has no successor. 
Node 3 has two successor nodes: 6 and 7. 
Node 6 has two successors: 10 and 11. 
Finally, node 7 has only one successor: 12.

A binary tree is recursive by definition as every node in the tree contains a left sub-tree and a right sub-tree. 
Even the terminal nodes contain an empty left sub-tree and an empty right sub-tree.
Look at Fig.4.2, nods 5, 8, 9, 10, 11 and 12 have no successors and thus said to have empty sub-trees.

==== Terminology

Parent:: If N is any node in T that has left successor S1 and right successor S2, then N is called the parent of S1 and S2. 
Correspondingly, S1 and S2 are called the left child and right child of N. 
Every node other than the root node has a parent.

image::{imagedir}tree-binary-levels.png[]

Level Number:: Every node in the binary tree is assigned a level number (refer Fig.4.3). 
The root node is defined to be at level 0. 
The left and the right child of the root node have a level number 1. 
Similarly, every node is at one level higher than its parents. 
So all child nodes are defined to have level number as parent's level number + 1.

Degree of a node:: It is equal to the number of children that a node has. 
The degree of a leaf node is zero. 
For example, in the tree, degree of node 4 is 2, degree of node 5 is zero and degree of node 7 is 1.

Sibling:: All nodes that are at same level and share the same parent are called siblings (brothers). 
For example, nodes 2 and 3; nodes 4 and 5; nodes 6 and 7; nodes 8 and 9; and nodes 10 and 11 are siblings.

Leaf node:: A node that has no children is called a leaf node or a terminal node. 
The leaf nodes in the tree are: 8, 9, 5, 10, 11 and 12.

Similar binary trees:: Two binary trees T and T' are said to be similar if both these trees have the same structure. 
Figure 4.4 shows two similar binary trees.

image::{imagedir}tree-binary-similar.png[]

Copies:: Two binary trees T and T' are said to be copies if they have similar structure and if they have same content at the corresponding nodes. 
Figure 4.5 shows that T' is a copy of T.

image::{imagedir}tree-binary-copy.png[]

Edge:: It is the line connecting a node N to any of its successors. 
A binary tree of n nodes has exactly n - 1 edges because every node except the root node is connected to tits parent via an edge.

Path:: A sequence of consecutive edges. 
For example, in Fig.4.3, the path from the root node to the node 8 is given as: 1, 2, 4 and 8.

Depth:: The depth of a node N is given as the length of the path from the root R to the node N. 
The depth of the root node is Zero.

Height of a tree:: It is the total number of nodes on the path from the root node to the deepest node in the tree. 
A tree with only a root node has a height of  1.
+
A binary tree of height h has at least h nodes and at most 2^h^ - 1 node. 
This is because every level will have at lease one node and can have at most 2 nodes. 
SO, if every level has two nodes then a tree with height h will have at most 2^h^ - 1 nodes as at level 0, there is only one element called the root. 
The height of a binary tree with n nodes is at least log~2~(n+1) and at most n.

In-degree/out-degree of a node:: It is the number of edges arriving at a node. 
The root node is the only node that has an in-degree equal to zero. 
Similarly, out-degree of a node is the number of edges leaving that node. 
Binary trees are commonly used to implement binary search trees, expression trees, expression trees, tournament trees and binary heaps.

==== Complete Binary Trees

A complete binary tree is a binary tree that satisfies two properties. 
First, in a complete binary tree, every level, expect possibly the last, is completely filled. 
Second, all nodes appear as far left as possible.

In a complete binary tree T~n~, there are exactly n nodes and level r of T can have at most 2^r^ nodes. 
Figure 4.7 shows a complete binary tree.

image::{imagedir}tree-binary-complete.png[]

Note that in Fig.4.6, 
level 0 has 2^0^ = 1 node, 
level 1 has 2^1^ = 2 nodes, 
level 2 has 2^2^ = 4 nodes, 
level 3 has 2^3^ = 8 nodes.

In Fig.4.6, tree T~13~ has exactly 13 nodes. 
They have been purposely labelled from 1 to 13, so that it is easy for the reader to find the parent node, the right child node, and the left child node of the given node.

The formula can be given as - if K is a parent nofe, then its left child can be calculated as 2 x K and its right child can be calculate as 2 x K + 1.

For example, the children of the node 4 are 8 (2 x 4) and 9 (2 x 4 + 1).
Similarly, the parent of the node K can be calculated as |K/2|. 
Given the node 4, its parent can be calculated as |4/2| = 2. 
The height of a tree T~n~ having exactly n nodes is given as: H~n~ = |log~2~(n + 1)|

NOTE: This means, if a tree T has 1000000 nodes, then its height is 21.

==== Extended Binary Trees

A binary tree T is said to be an extended binary tree (or a 2-tree) if each node in the tree has either no child or exactly two children. 
Figure 4.7 shows how an ordinary binary tree is converted into an extended binary tree.

In an extended binary tree, nodes having two children are called internal nodes and nodes having no children are called external nodes. 
In Fig.4.7, the internal nodes are represented using circles and the external nodes are represented using squares.

To convert a binary tree into an extended tree, every empty sub-tree is replaced by a new node. 
The original nodes in the tree are the internal nodes, and the new nodes added are called the external nodes.

image::{imagedir}tree-binary-extended.png[]

=== Representation of Binary Trees in the Memory

In the computer's memory, a binary tree can be maintained either by using a linked representation or by using a sequential representation.

==== Linked representation of binary trees

In the linked representation of a binary tree, every node will have 3 parts:
1) data element
2) a pointer to the left node and
3) a pointer to the right node.

So in C, the binary tree is built with a node type given below:

[source, c]
----
struct node
{
        struct node * left;
        int data;
        struct node * right;
}
----

Every binary tree has a pointer ROOT, which points to the root element (topmost element) of the tree. 
If ROOT = NULL, then the tree is empty. 
Consider the binary tree given in Fig.4.2. 
The schematic diagram of the linked representation of the binary tree is shown in Fig.4.8.

In Fig.4.8, the left position is used to point to the left child of the node or to store the address of the left child of the node. 
The middle position is used to store the data. 
Finally, the right position is used to point to the right child of the node or to store the address of the right child of the node. 
Empty sub-trees are represented using X (meaning NULL).

image::{imagedir}tree-binary-linked.png[]

Sequential representation of binary trees is done using single or one-dimensional arrays. 
Thought it is the simplest technique for memory representation, it is inefficient as it requires a lot of memory space.

A sequential binary tree follows the following rules:

* A one-dimensional array, called TREE, is used to store the element of tree.
* The root of the tree will be stored in the first location. 
That is, TREE[1] will store the data of the root element.
* The children of a node stored in location K will be stored in locations (2 x K) and (2 x K + 1).
* The maximum size of the array TREE is given as (2h -1), where h is the height of the tree.
* An empty tree or sub-tree is specified using NULL. 
If TREE[1] = NULL, then the tree is empty.

Fig.4.9 shows a binary tree and it's corresponding sequential representation. 
The tree has 11 nodes and it's height is 4.

image::{imagedir}tree-binary-sequential.png[]

=== Traversing a Binary Tree

Traversing a binary tree is the process of visiting each node in the tree exactly once in a systematic way. 
Unlike linear data structures in which the elements are traversed sequentially, tree is a nonlinear data structure in which the elements can be traversed in many different ways. 
There are different algorithms for tree traversals. 
These algorithms differ in the order in which the nodes are visited. 
In this section, we will discuss these algorithms.

==== Pre-order Traversal

To traverse a non-empty binary tree in pre-order, the following operations are performed recursively at each node. 
The algorithm works by:

. Visit the root node.
. Traverse the left subtree.
. Traverse the right subtree.

Pre-order traversal is also called as depth-first traversal. 
In this algorithm, the left sub-tree is always traversed before the right sub-tree. 
The word `pre` in the pre-order specifies that the root node is accessed prior to any other nodes in the left and right sub-trees. 
Pre-order algorithm is also knows as the NLR traversal algorithm (Node-Left-Right).

image::{imagedir}tree-binary-traversal-preorder.png[]

.Algorithm for pre-order traversal of a binary tree.
----
Step 1. While TREE != NULL
Step 2.         Write TREE -> DATA
Step 3.         PREORDER(TREE -> LEFT)
Step 4.         PREORDER(TREE -> RIGHT)
        [ENd OF WHILE]
Step 5: END
----

==== In-order Traversal

To traverse a non-empty binary tree in in-order, the following operations are performed recursively at each node. 
The algorithm works by:

. Traverse the left subtree.
. Visit the root node.
. Traverse the right subtree.

.Algorithm for in-order traversal of a binary tree.
----
Step 1. While TREE != NULL
Step 2.         INORDER(TREE -> LEFT)
Step 3.         Write TREE -> DATA
Step 4.         INORDER(TREE -> RIGHT)
        [ENd OF WHILE]
Step 5: END
----

In-order traversal is also called as symmetric traversal. 
In this algorithm, the left sub-tree is always traversed before the root and the right sub-tree.

The word `in` in the in-order specifies that the root node is accessed in between the left and right sub-trees. 
In-order algorithm is also known as the LNR traversal algorithm (Left-Node-Right).

image::{imagedir}tree-binary-traversal-inorder.png[]

==== Post-order Traversal

To traverse a non-empty binary tree in post-order, the following operations are performed recursively at each node. 
The algorithm works by:

. Traverse the left subtree.
. Traverse the right subtree.
. Visit the root node.

In this algorithm, the left sub-tree is always traversed before the right sub-tree and the root node. 
The word `post` in the post-order specifies that the root node is accessed after the left and the right  sub-trees.

Post-order algorithm is also known as the LRN traversal algorithm (Left-Right-Node).

.Algorithm for post-order traversal of a binary tree.
----
Step 1. While TREE != NULL
Step 2.         POSTORDER(TREE -> LEFT)
Step 3.         POSTORDER(TREE -> RIGHT)
Step 4.         Write TREE -> DATA
        [ENd OF WHILE]
Step 5: END
----

image::{imagedir}tree-binary-traversal-postorder.png[]

=== Binary Search Trees

A binary search tree, also known as an ordered binary tree, is a variant of binary trees in which the nodes are arranged in an order. 
In a binary search tree, all the nodes in the left sub-tree have a value less than that of the root node. 
Correspondingly, all the nodes in the right sub-tree have a value either equal to or greater than that of the root node. 
The same rule is applicable to every sub-tree in the tree.

NOTE: A binary search tree may or may not contain duplicate values, depending on the implementation.

image::{imagedir}tree-binary-search.png[]

The root node is 39. 
The left sub-tree of the root node consists of nodes 9, 10, 18, 19, 21, 27, 28, 29 and 36.

All these nodes have smaller values than the root node. 
The right sub-tree of the root node consists of nodes 40, 45, 54, 59, 60 and 65.

Recursively, each of the sub-trees also obeys the binary search tree constraint.

For example, in the left sub-tree of the root node, 27 is the root and all elements in its left sub-tree (9, 10, 18, 19, 21) are smaller than 27, while all nodes in its right sub-tree (28, 29, 36) are greater than the root node's value.

Binary search trees also speed up the insertion and deletion operations. 
The tree has a speed advantage when the data in the structure changes rapidly.

Binary search trees are considered to be efficient data structures especially when compared with sorted linear arrays and linked lists. 
In a sorted array, searching can be done in O(log~2~n) time, but insertions and deletions are quite expensive. 
In contrast, inserting and deleting elements in a linked list is easier, but searching for an element is done in O(n) time.

However, in the worst case, a binary search tree will take O(n) time to search for an element.

To summarize, a binary search tree is a binary tree with the following properties:

* The left sub-tree of a node N contains values that are less than N's value.
* The right sub-tree of a node N contains values that are greater than N's value.
* Both the left and right binary trees also satisfy these properties and thus are binary search trees.

:sectnums!:
==== Example

Create a binary search tree using the following data elements: 45, 39, 56, 12, 34, 78, 32, 10, 89, 54, 67 and 81.

image::{imagedir}tree-binary-search-example.png[]

:sectnums:
==== Operations on Binary search trees

===== Inserting a new node in a binary search tree

The insert function is used to add a new node with a given value at the correct position in the binary search tree. 
Adding the node at the correct position means that the new node should not violate the properties of the binary search tree. 
The initial code for the insert function is similar to the search function. 
THis is because we first find the correct position where the insertion has to be done and then add the node at that position. 
The insertion function changes the structure of the tree. 
Therefore, when the insert function is called recursively, the function should return the new tree pointer.

The insert function requires time proportional to the height of the tree in the worst case. 
It takes O(log n) time to execute in the average case and O(n) time in the worst case.

.Algorithm for inserting a new node in a binary search tree Insert (TREE, VAL)
----
Step 1: If TREE is NULL
Step 2:         Allocate memory for TREE
Step 3:         Set TREE -> DATA = VAL
Step 4:         Set TREE -> LEFT = TREE -> RIGHT = NULL
Step 5: ELSE
Step 6:         If VAL < TREE -> DATA
Step 7:                 INSERT(TREE -> LEFT, VAL)
Step 8:         ELSE
Step 9:                 INSERT(TREE -> RIGHT, VAL)
                [END OF IF]
        [ENd OF IF]
Step 10: END
----

Example: Inserting nodes with values 12 and 55 in the given binary search tree.

image::{imagedir}tree-binary-search-insert.png[]

===== Deleting a node from a binary search tree

The delete function deletes a node from the binary search tree. 
However, utmost care should be taken that the properties of the binary search tree are not violated and nodes are not lost in the process.

Case 1. Deleting a node that has no children

Case 2. Deleting a node with one child

Case 3. Deleting a node with two children

====== Case 1. Deleting a node that has no children

image::{imagedir}tree-binary-search-delete-no-child.png[]

If we have to delete node 78, we can simply remove this node without any issue.

This is the simplest case of deletion.

====== Case 2. Deleting a node with one child

image::{imagedir}tree-binary-search-delete-one-child.png[]

To handle this case, the node's child is set as the child of the node's parent. 
In other words, replace the node with its child. 
Now, if the node is the left child of the node's parent, the node's child becomes the left child of the node's parent. 
Correspondingly, if the node is the right child of its parent, the node's child becomes the right child of the node's parent.

Look at the binary search tree shown in figure and see how deletion of node 54 is handled.

====== Case 3. Deleting a node with two children

image::{imagedir}tree-binary-search-delete-two-child.png[]

To handle this case, replace the node's value with its in-order predecessor (largest value in the left sub-tree) or in-order successor (smallest value in the right sub-tree).

The in-order predecessor or the successor can then be deleted using any of the above cases.

Look at the binary search tree given in figure and see how deletion of node with value 56 is handled.

=== Balanced Binary Trees - AVL Trees

AVL tree is a self-balancing binary search tree invented by G.M. Adelson-Velsky and E.M. Landis in 1962. 
The tree is named AVL in honour of its inventors. 
In an AVL tree, the heights of the two sub-trees of a node may differ by at most one. 
Due to this property, the AVL tree is also know as height-balanced tree. 
The key advantage of using an AVL tree is that it takes O(log n) time to search, insert and delete operations in an average case as well as the worst case because the height of tree is limited to O(log n).

The structure of an AVL tree is the same as that of a binary search tree but with a little difference. 
In its structure, it stores an additional variable called the Balance factor. 
Thus, every node has a balance factor associated with it. 
The balance factor of a node is calculated by subtracting the height of its right sub-tree from the height of its left sub-tree. 
A binary search tree in which every node has balance factor of -1, 0 or 1 is said to be height balanced. 
A node with any other balance factor is considered to be an unbalanced and requires rebalancing of the tree.

Balance factor = Height of left subtree - Height of right subtree

* If the balance factor of a node is 1, then it means that the left sub-tree of the tree is one level higher than that of the right sub-tree. 
Such a tree is therefore called as a left-heavy tree.

* If the balance factor of a node is 0, then it means that the height of the left subtree (longest path in the left subtree) is equal to the height of the right subtree.

* If the balance factor of a node is -1, then it means that the left sub-tree of the tree is one level lower than that of the right sub-tree. 
Such a tree is therefore called as a right-heavy tree.

==== Operations on AVL Trees

===== Searching for a node in an AVL tree

Searching in an AVL tree is performed exactly the same way as it is performed in a binary search tree. 
Due to the height-balancing of the tree, the search operation takes O(log n) time to complete. 
Since the operation does not modify the structure of the tree, no special provisions are required.

===== Inserting a new node in an AVL tree

Insertion in an AVL tree is also done in the same way as it is done in a binary search tree. 
In the AVL tree, the new node is always inserted as the leaf node. 
But the step of insertion is usually followed by an additional step of rotation. 
Rotation is done to restore the balance of the tree.

However, if insertion of the new node does not disturb the balance factor, that is, if the balance factor of every node is still -1, 0 or 1, then rotations are not required.

To perform rotation, our first task is to find the critical node. 
Critical node is the nearest ancestor node on the path from the inserted node to the root whose balance factor is neither -1, 0 nor 1.

The second task in rebalancing the tree is to determine which type of rotation has to be done. 
There are 4 types of rebalancing rotations and application of these rotations depends on the position of the inserted node with reference to the critical node.

AVL tree is out of balance must be one of the 4 types:

* LL
+
The new node is inserted in the left sub-tree of the left sub-tree of the critical node. 
* RR
+
The new node is inserted in the right sub-tree of the right sub-tree of the critical node. 
* LR
+
The new node is inserted in the right sub-tree of the left sub-tree of the critical node.
* RL
+
The new node is inserted in the left sub-tree of the right sub-tree of the critical node.

====== Rotation of LL

When LL loses balance, the AVL tree can be balanced with one right rotation as shown below. 
Right branch of the left sub-tree is rearranged as left branch to the critical node.

Example: Consider the AVL tree given in figure and insert 18 into it.

image::{imagedir}tree-avl-left-left.bmp[]

====== Rotation of RR

When RR loses balance, the AVL tree can be balanced with one left rotation as shown below. 
Left branch of the right sub-tree is rearranged as right branch to the critical node.

Example: Consider ther AVL tree given in figure and insert 89 into it.

image::{imagedir}tree-avl-right-right.bmp[]

====== LR rotation

When LR loses balance, the AVL tree can be balanced with left rotation followed by right rotation as shown below.

image::{imagedir}tree-avl-left-right.bmp[]

====== RL rotation

When RL loses balance, the AVL tree can be balanced with right rotation followed by left rotation as shown below.

image::{imagedir}tree-avl-left-right.bmp[]

Example:

Construct an AVL tree by inserting the following elements in the given order.

63, 9, 19, 27, 18, 108, 99, 81.

image::{imagedir}tree-avl-example.png[]

===== Deleting a node from an AVL tree

Deletion of a node in an AVL tree is similar to that of binary search trees. 
But it goes on step ahead. 
Deletion may distrub the AVLness of the tree, so to rebalance the AVL tree, we need to perform rotations.

=== Applications of Trees

* Trees are used to store simple as well as complex data. 
Here simple means an ineger value, character value and complex data means a structure or a record.
* Trees are often used for implementing other types of data structures like hash tables, sets and maps.
* A self-balancing tree, Red-Black tree is used in kernel scheduling or preempt massively multiprocessor computer operating system use.
* Another variation of tree, B-trees are prominently used to store tree structures on disc. 
They are used to index a large number of records.
* B-trees are also used for secondary indexes in databases, where the index facilitates a select operation to answer some range criteria.
* Trees are an important data structure used for compiler construction.
* Trees are also used in database design.
* Trees are used in file system directories.
* Trees are also widely used for information storage and retrieval in symbol tables.

==== Expression Trees

image::{imagedir}tree-expression-1.png[]

Binary trees are widely used to store algebraic expressions. 
For example, consider the algebraic expression given as: 

Exp = (a - b) + (c * d)

This expression can be represented using a binary tree as shown in Figure.

Given an expression, Exp = ((a + b) - (c * d)) %  ((e ^ f) / (g - h)), construct the corresponding binary tree.

image::{imagedir}tree-expression-2.png[]

==== Heap Sort

Heap:: Recall that a heap is a complete binary tree such that the weight of every node is less than the weights of its children.

A heap with n elements can be conveniently represented as the first n elements of an array. 
Furthermore, the children of a[i] can be found in a[2i] (left child) and a[2i+1] (right child).

Steps:

. Consider the values of the elements as priorities and build the heap tree.

. Start deleteMin operations, storing each deleted element at the end of the heap array.

After performing step 2, the order of the elements will be opposite to the order in the heap tree. 
Hence if we want the elements to be stored in ascending order, we need to build the heap tree in descending order - the greatest element will have the highest priority.

Note that we have only one array, treating its parts differently:

a) When building the heap tree, part of the array will be considered as the heap, and the rest part - the original array.

b) When sorting, part of the array will be the heap, and the rest part - the sorted array.

:sectnums!:
===== Example

Given an array of 6 elements: 15, 19, 10, 7, 17 and 16 sort it in ascending order using heap sort.

Here is the array: 15, 19, 10, 7, 17 and 6

====== Building the heap tree

The array represented as a tree, complete but not ordered:

|====
|15|19|10|7|17|16
|====

image::{imagedir}tree-heap-1.png[]

Start with the rightmost node at height 1, the node at position 3 = Size / 2.

It has one greater child and has to percolated down:

image::{imagedir}tree-heap-2.png[]

After processing array[3] the situation is:

image::{imagedir}tree-heap-3.png[]

Next come array[2]. 
Its children are smaller, so no percolation is needed.

The last node to be processed is array[1]. 
Its left child is ther greater of the children.

The item at array[1] has to be percolated down to the left, swapped with array[2].

As a result the situtation is:

image::{imagedir}tree-heap-4.png[]

The children of array[2] are greater, and item 15 has to be moved down further, swapped with array[5].

image::{imagedir}tree-heap-5.png[]

Now the tree is ordered, and the binary heap is built.

====== Sorting - Performing deleteMax operations

*Delete the top element 19*

Store 19 in a temporary place, a hole is create at the top.

image::{imagedir}tree-heap-6.png[]

Swap 19 with the last element of the heap.

As 10 will be adjusted in the heap, its cell will no longer be a part of the heap.

Instead it becomes a cell from the sorted array.

image::{imagedir}tree-heap-7.png[]

Percolate down the hole.

image::{imagedir}tree-heap-8.png[]

Percolate once more (10 is less than 15, so it cannot be inserted in the previous hole).

image::{imagedir}tree-heap-9.png[]

Now 10 can be inserted in the hole.

image::{imagedir}tree-heap-10.png[]

*DeleteMax the top element 17*

Store 17 in a temporary place, a hole is create at the top.

image::{imagedir}tree-heap-11.png[]

Swap 17 with the last element of the heap.

As 10 will be adjusted in the heap, its cell will no longer be a part of the heap.

Instead it becomes a cell from the sorted array.

image::{imagedir}tree-heap-12.png[]

The element 10 is less than the children of the hole, and we percolate the hole down.

image::{imagedir}tree-heap-13.png[]

Insert 10 in the hole.

image::{imagedir}tree-heap-14.png[]

*DeleteMax 16*

Store 16 in a temporary place, a hole is create at the top.

image::{imagedir}tree-heap-15.png[]

Swap 16 with the last element of the heap.

As 7 will be adjusted in the heap, its cell will no longer be a part of the heap.

Instead it becomes a cell from the sorted array.

image::{imagedir}tree-heap-16.png[]

Percolate the hole down (7 cannot be inserted there - it is less than the children of the hole).

image::{imagedir}tree-heap-17.png[]

Insert 7 in the hole.

image::{imagedir}tree-heap-18.png[]

*DeleteMax the top element 15*

Store 15 in a temporary place, a hole is create at the top.

image::{imagedir}tree-heap-19.png[]

Swap 15 with the last element of the heap.

As 10 will be adjusted in the heap, its cell will no longer be a part of the heap.

Instead it becomes a cell from the sorted array.

image::{imagedir}tree-heap-20.png[]

Store 10 in the hole (10 is greater than the children of the hole).

image::{imagedir}tree-heap-21.png[]

*DeleteMax the top element 10*

Remove 10 from the heap and store it into a temporary place.

image::{imagedir}tree-heap-22.png[]

Swap 10 with the last element of the heap.

As 7 will be adjusted in the heap, its cell will no longer be a part of the heap.

Instead it becomes a cell from the sorted array.

image::{imagedir}tree-heap-23.png[]

Store 7 in the hole (as the only remaining element in the heap).

image::{imagedir}tree-heap-24.png[]

7 is the last element from the heap, so now the array is sorted.

image::{imagedir}tree-heap-25.png[]

The `HEAPSORT` procedure takes time (O(n log n)), since the call to `BULD_HEAP` takes time O(n) and each of the n-1 calls to Heapify takes time O(log n).
