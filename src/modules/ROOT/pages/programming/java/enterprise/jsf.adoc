== Outline

Technique JSF (JavaServer Faces) is a server-side framework and is used to create web applications. 
JSF attempts the complexities of web application development to encapsulate and hides a large part of the problems and techniques that a web developer has to deal with. 
That's what most people have to do Project team developers only have a rudimentary knowledge of web applications because they mainly develop in their usual programming language can and seldom need to realize that they develop are a web application. 
Even JSF cannot fully develop the developer before contact with web technologies shield.

*Target*
+
After reading this book you will be able to develop simple JSF applications. 
Since the internal processes and concepts of the JSF framework are also examined, you should also extend JSF appropriately and can solve problems encountered during development with JSF. 
Already after the first chapters you will at least be able to realize a simple JSF application and classify JSF as a technique to be able to after the last chapter you will also be able to independently implement JSF applications.

*Method*
+
In addition, reference is repeatedly made to practical exercises as well as examples and problems from practice are shown, which you can use in everyday work with JSF will probably encounter. 
The task of the book is to prepare you for practice, without neglecting the theory. 
After the first practical examples explains the more theoretical basics of JSF. 
However, this is very lively on the previously discussed examples, so you will not have any problems to follow the explanations. 
Please note that the examples shown have been shortened at appropriate points in order to clarify only the essential aspects.

*What of you is expected*
+
So that's what the book offers you. 
But now to what the book of awaits you:
* Working through the practical exercises
* Java Knowledge (e.g. [Balz13], [Balz14])
* Basic knowledge of developing web applications in Java (e.g. [KrBa11], [Wißm09]):
** You know how to use your preferred development environment Web application project created.
** You have already written a JSP application (JavaServer Pages) yourself.
** You have heard the following terms before and can roughly classify them:
*** Markup-Element (Tag )
*** Tag Library
*** Servlet

*If not everything is correct*
+
If you do not meet all the criteria, this is not an exclusion criterion. 
You can first try to "get by" once, in the appropriate places in the book all terms are briefly explained again. 
Because all terms in a practical context, you can see directly how to use these techniques. 
If that is not enough, you can read up on one or the other on the Internet.

If you prefer the book form, the book [Wißm09] (with e-learning course) is recommended that will give you all the basics you need to understand this book and the JSF technique are required.

*Development environment*
+
Compared to programming with a programming language, web applications use several tools. You should get the necessary tools install and configure on your computer system.

*Quick start*
+
The aim of the Quick Start is to give you a feel for the JSF technique. 
In addition a simple example serves as motivation.

* The Quick Start, p.5

*Basics of web development*
+
JSF is a specification and multiple implementations of this specification exist. 
The way from specification to implementation is shown in the basics and general web application architectures are described.

* Basics of Web Development, p.9

[Balz13]

Balzert, Helmut; Java: Der Einstieg in die Programmierung - Strukturiert & prozedural programmieren, 4. Auflage, Dortmund, W3L-Verlag, 2013.

[Balz14]

Balzert, Helmut; Java: Objektorientiert programmieren - Vom objektorientierten Analysemodell bis zum objektorientierten Programm, 3. Auflage, Dortmund, W3L-Verlag, 2014.

[KrBa11]

Krüger, Sandra; Balzert, Helmut; HTML5, XHTML & CSS - Websites systematisch und barrierefrei entwickeln, 2. Auflage, W3L-Verlag, 2011.

[Wißm09]

Wißmann, Dieter; JavaServer Pages - Dynamische Websites mit JSP erstellen, W3L-Verlag, 2009.

== The Quick Start

A minimal JSF page consists of an XHTML and two configuration files (faces-config.xml and web.xml). 
The XHTML elements are rendered as HTML5.

*Previous Knowledge*
+
The quick start is intended for readers who do not yet have any previous knowledge of JSF or XHTML (Extensible HyperText Markup Language). 
XHTML knowledge is necessary to develop JSF applications. 
This is because Facelets are defined as a standard VDL (View Declaration Language) in JSF applications. 
A more detailed description about Facelets will be given throughout the book. 
When using facelets usually XHTML is used. 
This book uses JSF version 2.3.

*JSF-Version*
+
A complete listing of all available classes, some of which are used in this book are given in [Orac18].

*Motivating Example*

Hello World

To get a first insight into the syntax of JSF applications, a motivating example a "Hello World" example is shown here. 
There will be a total of two configuration files `faces-config.xml` and `web.xml` are required. 
Also, a Java class `JSFActivationBean` and a JSF page declaration `index.xhtml` created. 
The files will be described below.

.faces-config.xml
----
<?xml version='1.0' encoding=’UTF-8’?>
<faces-config version="2.3"
    xmlns="http://xmlns.jcp.org/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee 
        http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_3.xsd">
</faces-config>
----

To "enable" JSF, create a configuration file `faces-config.xml` in the `WEB-INF` directory (alternatively: create a specially annotated Class). 
The specification <?xml version="1.0" encoding="UTF-8"?> designates the XML declaration
(Extensible Markup Language). 
It is an award with which each XML file should begin. 
Among other things, it describes the one used XML version and the character set used. 
By specifying version="2.3" sets the JSF version. 
The other parameters specify the namespace which defines the available elements of a JSF page declaration.

.JSF Activation Bean
----
@FacesConfig(version = FacesConfig.Version.JSF_2_3)
@ApplicationScoped
public class JSFActivationBean {
}
----

"Activating" JSF requires the creation of a specially annotated class (alternative: create a configuration file `faces-config.xml`) JSF 2.3 becomes in a "JSF 2.2 compatibility mode". 
This concerns, for example the management of objects in the application server using CDI (Contexts and dependency injection). 
For using JSF 2.3 is any Class with @FacesConfig annotation with version parameter FacesConfig.Version.JSF_2_3 in the ApplicationScoped scope. 
The name of this Any class can be chosen.

*NOTICE*
+
Throughout the book, both annotations and configurations in the the `faces-config.xml` file is used appropriately.

.web.xml
----
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://xmlns.jcp.org/xml/ns/javaee"
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
        http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
    version="4.0">
    <context-param>
        <param-name>javax.faces.PROJECT_STAGE</param-name>
        <param-value>Development</param-value>
    </context-param>
    <welcome-file-list>
        <welcome-file>index.xhtml</welcome-file>
    </welcome-file-list>
</web-app>
----

The `web.xml` file is saved in the `WEB-INF` directory. 
Through the context parameter `javax.faces.PROJECT_STAGE` with value `Development` become automatic Messages are output in the view using the `h:messages` JSF component. 
The start page should be `index.xhtml`. 
This is done in the <welcome-file-list>...</welcome-filelist>.

*NOTICE*
----
The FacesServlet class can automatically be used as the processing class for the requests
be set. 
The prerequisite for this is the existence of a configuration file `faces-config.xml` or at least one class with a JSF annotation (e.g. @FacesConfig). 
This means that the <servlet>...</servlet> area can be omitted. 
Likewise the mapping is optional. 
If the area <servlet-mapping>...</servlet-mapping> is not set, all `*.xhtml` files are automatically mapped to the FacesServlet.
----

.index.xhtml
----
<!DOCTYPE html>
<html lang="en"
    xmlns="http://www.w3.org/1999/xhtml"
    xmlns:h="http://xmlns.jcp.org/jsf/html">
<h:head>
    <title>Hello World</title>
</h:head>
<h:body>
    <h:outputText value="Hello World" />
</h:body>
</html>
----

In the DOCTYPE area there is no reference to an HTML DTD (Document Type Definition) given, therefore it is an HTML5 page. 
HTML5 is not based based on SGML (Standard Generalized Markup Language), so specifying a
Document type definition not necessary. 
The output text Hello World is replaced by the set JSF component h:outputText.

*NOTICE*
----
By using facelets as VDL, the DOCTYPE specification is not crucial: HTML5 source code is always rendered. 
It would also be possible to use the following document type definition from the XHTML standard:

<!DOCTYPE html PUBLIC
    "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
----

Here it is specified in the DOCTYPE area that the publicly available HTML DTD (Document Type Definition) is referred to. 
The DTD defines the document structure. 
It is further specified that XHTML in version 1.0 and in the variant Transitional and that the used elements and attribute names have been defined in the EN language. 
In the html area, the language of the XHTML page and the tag libraries used specified.

*Result*
Calling up the page is shown in Fig.2.0-1.

image::
Fig.2.0-1: Example hello world.

The existing source text of the call looks like this:
----
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head id="j_idt2">
    <title>Hallo Welt</title>
</head>
<body>Hallo Welt</body>
</html>
----

The small example shows that the JSF page declaration with XHTML and JSF tags is defined, but the generated result is presented as HTML5 becomes.

NOTICE
----
In the example, the `index.xhtml` file is named "JSF Page Declaration". 
XHTML and JSF tags are used. 
As the book progresses, simply the term »JSF page« is used.
----

== Web Development Basics

The basics of web development with Java are described in various JSRs (Java Specification
request). 
These include, for example, »Java 8 SE« (JSR 337), »Expression Language 3.0« (JSR 341) and »JavaServer Faces 2.3« (JSR 372). 
A JSR goes through different stages and may have reached a certain level. 
Web applications can have different architectures. 
The content will be in described in the following chapters:

* Java Specification Request, P.9
* Web Application Architecture, P.10

*Java Specification Request*

A JSR (Java Specification Request) goes through different states and can have reached a certain level.

JSF is first of all a specification. 
New requirements to existing specifications are described in a JSR. 
For the inclusion of new language elements or the API (Application Programming Interface) extension creates a new JSR. 
As part of the specification process, a JSR is created by experts from different fields directed. 
The current specification of JSF 2.3 is described in JSR 372 [JCP17].

The specifications can have different statuses (see Table. 3.1-1).

|====
|Status
|Description

|Active
|A specification that has had a milestone released within the last 12 months.

|Final
|A specification that has had a final release within the last 12 months.

|Maintenance
|A specification that most recently passed a maintenance review or a maintenance release milestone was created more than a year ago.

|Inactive
|A specification that is not a final release or maintenance release and is within the last 
Year no milestone was created.

|Withdrawn
|A specification that was withdrawn prior to the release of a Final Release.

|Rejected
|A specification that was not accepted at one of the voting levels.

|Dormant
|A specification that has been voted "inactive" or has exceeded its natural lifespan has reached.

|JSR Review
|Anyone with an internet connection can view the specification for two to four weeks view and comment.

|Early Draft Review
|One to three months, the public can an early draft specification review and comment.

|Public Review
|The public can examine the draft specification for one to three months and Leave a Comment.

|Proposed Final
|The draft specification is used to create a reference implementation.

|Final Release
|The specification has been approved in its final version and can now be used to be implemented.

|Maintenance Review
|At least one month before the completion of a minor revision (minor changes at the specification), at the members and the public the proposed Review and comment on change entries.

|Inactive
|Inactive specifications have not reached final release or have been within No milestones published in the last 12 months.

|Dormant
|This marking makes it clear that no further work is invested in the specification for example because they are removed from the list of active specifications by voting was removed.

|Withdrawn
|This marks specifications that were initially started but are progressing have been removed from the list of active projects because no member has agreed to do so has to take the leading role.

|Rejected
|Specifications can be rejected by the executive committee.
|====
Table. 3.1-2: JSR Stand.

*Web Application Architecture*

Web applications can be structured and divided in different ways. 
The underlying architecture defines how the individual components interact with a web application.

Just like common Java applications, there are also different ones for web applications
architectural pattern. 
At this point, the architectural patterns Model 1 and Model 2 treated. 
For Model 1 web applications, the client accesses the directly corresponding views. 
In the case of Model 2 web applications, access is provided by the clients not directly on the views, but always on the controller of the web application. 
Model 2 patterns are also called MVC patterns (Model View Controller patterns).

=== Model 1

Web application flow control from page to page is used in Model 1 applications realized via direct references. 
That is, in a view, a reference exists that refers to another view. 
This process is shown in Fig. 3.2-1 illustrated.

image::

Fig. 3.2-1: Process model 1 (general).

The client calls each view directly. 
This can be via referrals or direct input done in the address bar. 
The process in the context of JSP applications is shown in Fig. 3.2-2 explained.

The client calls page 1.jsp ("Request 1"). 
This page uses an object of class user to store data there. 
To use the User class, create 1.jsp an object of the class and stores data there that is determined from the request were (»filled«). 
The JSP page then generates a corresponding HTML document as an answer and returns it to the client. 
This generated HTML document contains a reference to 2.jsp. 
The user clicks on this link (Request 2) and calls 2.jsp. 
This page also uses the object created by 1.jsp Class user and in turn generates an HTML document. 
This HTML document is then returned to the client.

*Technical structure*
+
Typically, a Model 1 web application (seen from the client perspective) is built exclusively from JSP pages or servlets. 
As a result, the JSP pages and Servlets can be used not only as a view but also as a controller. 
JSP pages do not only fulfill the task of generating and returning HTML (as pure view), but also call the business logic, generate the on the page required JavaBeans and determine which JSP page is displayed next (Flow control). 
The above tasks are things that are usually be done by a controller. 
So the JSP pages do the job too the following (controller) aspects:

image::

Fig. 3.2-2: Process Model 1 in the context of JSP applications

* Application/Business Logic
* Flow control
* Creation/filling of the used JavaBeans

*limitations*
+
Inevitably, this always occurs as the size of the application increases more complex JSP pages and servlets, as there is no strict separation between each areas of responsibility. There is a risk of losing track and create a hard-to-maintain application.

*Conclusion*
+
This does not mean that the Model 1 approach should be rejected in principle. 
For small Applications or prototypes that can be discarded after the presentation Model 1 enable an efficient procedure. 
For larger applications that require more than are to be maintained for a longer period of time, Model 1 is rather insufficient. 
here there must be a stronger separation of the individual areas of responsibility. 
This problem addressed Model 2.

=== Model 2

With Model 1 web applications, the client accesses a view directly. 
For model 2 - Applications, on the other hand, have a central location that is called up instead and forwards the call. 
This process is illustrated in Fig. 3.2-3.

The user communicates with the controller, so he sends his requests directly there. 
The controller creates and fills the model. 
Then he delegates it Output generation to the view that accesses Model objects generated by the controller.

In the context of JSP applications, the central place that the client calls is mostly a servlet (Java class that implements the javax.servlet.Servlet interface). 
Because this task within the web application it is called front controller servlet. 
As a rule, this servlet does not generate HTML itself, but uses it to do so for example facelets, JSP pages or servlets. 
In principle, the client does not notice anything this procedure.

Fig. 3.2-4 shows how the same application shown in Model 1 works with a Model 2 architecture.

*compared with style 1*
+
In a direct comparison of the graphic with Fig.3.2-2, it can be clearly seen that were previously handled individually by each JSP page are now handled by the front controller servlet.

*No direct access on JSP pages*
+
In Fig.3.2-4 you can see that the user no longer directly accesses the JSP pages. 
Instead, it always calls the front controller servlet, which in turn calls the JSP pages uses. 
In this case, the first call uses the front controller servlet the page 1.jsp.

*generate and filling through front controller*
+
With the second call (by clicking on a corresponding link) like-which calls the front controller servlet, but this time the servlet uses 2.jsp. 
In the case of the Model 2 web application, the creation and filling of the JavaBean objects inherited from the front controller servlet, so this is no longer the case must be implemented in the views.

*flow control*
+
The central role of the front controller servlet makes it easy to specify which ones JSP page when to be called (flow control). 
By the way, Model 2 is not set to use JSP pages to generate the HTML. 
As good as would it be possible to use a different kind of files describing the view (e.g. XML files like Facelets).

*Conclusion*
+
The most important difference to the Model 1 architecture is the clear demarcation of the individual areas of responsibility. 
This makes it easier to localize corresponding code parts and the risk of developing an unmaintainable "monolith" decreases.

image::

Fig.3.2-4: Process Model 2 in the context of JSP applications.

If you look at the last two figures, you will see that many Front controller functions are more general in nature and only loosely related to the related business logic. 
Therefore it is quite conceivable to have a universal Front controller to be used, which is set to the special by means of a configuration file Application needs can be customized. 
This configuration file contains then information such as navigation processes (which page leads to which other referenced) or information about the model to be created. 
A universal one Front controller does not have to be developed independently. 
Here put Java web frameworks like JSF and ship a generic front controller (among many
other amenities).

== Java web development with Servlets and JSP pages

JSF application development is different from development ordinary Java web applications with servlets and JSP pages.

The rough structure of a Java web application with Model 2 architecture is explained in the introduction Fig.4.0-1 briefly explained.

image::

Fig.4.0-1: Structure of a web application.

With Model 1 architectures, direct access to the JSP pages would also be possible. 
Basically, a web container is required first (e.g. Tomcat or Payara), where the web application can be published. 
The web application in turn consists of different elements. 
The most important ones are listed in Fig. 4.0-1: A configuration file (web.xml), one or more servlets, and one or multiple JSP pages. 
JSP pages and servlets make it easy to build a web application. 
The client (i.e. the browser) accesses the servlet and the servlet in turn accesses the JSP pages.

*Expiry of a user requirement (Request)*
This means, of course, that all technical aspects of the web application are also here
to be implemented. 
This means that first the user request (Request) must be evaluated to extract any transfer parameters, when programming a servlet. 
Then the actual business logic executed and then the HTML document is generated and returned to the client. 
The process is illustrated in Fig.4.0-2.

*Example*
+
In order to make the whole thing a little more vivid, a simple example is given using Servlets, JSP pages and JSF pages implemented. 
Fig. 4.0-3 shows an example Calling the example. 
After entering any text, e.g. »User«, and submitting the form, the text »Hello, user« is displayed. 
The values are stored in a Java class User.java, which is just a Property `name` owns.

User.java
----
public class User {
    
    private String name;
    
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
----

image::
Fig. 4.0-2: Sequence of a request/response cycle.

image::
Fig. 4.0-3: Example for comparison.

The example for the respective areas is implemented in the following chapters.

*Servlets*
+
The implementation of the example with servlets is described in this chapter.

»Servlets«

*JSP pages*
+
When implementing the example with JSP pages, there are different options shown: JSP scripting, JSTL (JSP Standard Tag Library) and EL (Expression Language).

»JSP pages«

*JSF pages*
+
In a direct comparison, the example is implemented with JSF.

»JSF pages«

*Conclusion*
+
The different areas are compared in a conclusion.

»Conclusion on servlets and JSP pages«

=== Servlets

A servlet (more specifically, HTTP servlet) is a Java class that provides the interface 
javax.servlet.http.HttpServlet implemented. 
Each HTML element must be compatible with the methods `print()` or `println()` can be created.

A class that implements the javax.servlet.http.HttpServlet interface and thus as the servlet must be defined as such in the web.xml configuration file will. 
The HttpServlet interface inherits from javax.servlet.Servlet.

*Example*
+
The implementation of the presented example (see »Java web development with servlets 
and JSP pages«, p. 15) with servlets will now be explained (Program Web developmentServlets).

ExampleServlet.java
----
public class ExampleServlet extends HttpServlet {

    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {

            response.setContentType("text/html;charset=UTF-8");

            PrintWriter out = response.getWriter();
            try {
                out.println("<!DOCTYPE html>");
                out.println("<html lang=\"en\"xmlns=\"http://www.w3.org/1999/xhtml\">");
                out.println("<head><title>ExampleServlet")
                out.println("</title></head><body>");
                out.println("<form method=\"post\">");
                out.println("<input type=\"text\"");
                out.println("name=\"username\" />");
                out.println("<input type=\"submit\"");
                out.println("value=\"send\" />");
                out.println("</form>");

                if (request.getParameter("username") != null) {
                    out.println("<p>Hello, " + request.getParameter("username")+"</p>");
                }

                out.println("</body></html>");
            } finally {
                out.close();
            }
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
            processRequest(request, response);
    }

    protected void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
            processRequest(request, response);
    }
}
----

web.xml
----
<servlet>
    <servlet-name>ExampleServlet</servlet-name>
    <servlet-class>jsf.beans.ExampleServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>ExampleServlet</servlet-name>
    <url-pattern>/ExampleServlet</url-pattern>
</servlet-mapping>
----

*Explanation*
+
This example shows the individual steps that are carried out need to go through the cycle of request and response:

* First, the input form is created.
* Then the request is evaluated and a decision is made as to whether a message is issued (is a username parameter set?).
* Finally, the HTML is rendered.

=== JSP pages

JSP pages are another web development option. 
It doesn't have to exclusively Java classes as with Servlets are used, but the program parts are positioned within the HTML elements and evaluated at runtime. 
In the background, JSP pages become Java classes, also called JSP classes, transformed. 
A JSP class is a servlet class, so it can also be simple called a servlet. 
However, this is transparent to the user. 
In the following chapters are different implementations of JSP pages shown: JSP scripting, JSTL (JSP Standard Tag Library) and EL (Expression Language).

* JSP scripting
* JSP Standard Tag Library
* Expression Language

==== JSP scripting

With JSP scripting, the Java code is embedded within a JSP page. 
The result is a mixture of HTML elements and Java code.

JSP scripting is an improvement in that full development of a Java class that implements the javax.servlet.http.HttpServlet interface necessary is. 
The required lines of Java code are written directly at the location of the HTML document
involved where they are needed.

There are different types of JSP script elements:
* Declarations <%! ... %>
** Used to define constants, variables, and methods that to be used in a JSP page.
* Scriplets <% ... %>
** In these areas, the Java code is integrated at the points in the HTML document where it is needed.
* expressions <%= ... %>
** Serves as a simple output. 
Alternatively, this could be done in scriplets using out.println(...); will be realized.
* Comments <%-- ... --%>
** This defines JSP comments that are visible in the JSP pages, but not in the generated HTML pages.

Example 1a:
The implementation of the presented example (see »Java web development with servlets
and JSP pages«, p. 15) with JSP scripting will now be explained (program WebdevelopmentJSP).

index_jspscripting.jsp
+
----
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>JSP-Scripting</title>
</head>
<body>
<jsp:useBean id="user" scope="page" class="jsf.beans.user" />
<jsp:setProperty name="user" property="name" param="username" />
<form>
<input type="text" name="username" />
<input type="submit" value="send" />
</form>
<%
if (user.getName()!=null)
{
%>
<p>Hello, <%=user.getName()%></p>
<%
}
%>
</body>
</html>
----

*Explanation*
+
The small example already shows that JSP scripting reduces the complexity of the source code increased. 
For the area of the closing bracket "}" must again a JSP scriplet can be generated.

*Example 1b*
+
Alternatively, the entire paragraph can be output using Java code:

----
<%
if (user.getName()!=null)
{
out.println("<p>Hello, " + user.getName() + "</p>");
}
%>
----

*Explanation*
+
In this case, although reopening a new JSP scriptlet that finally inserting a closing curly brace prevents, but must be explicitly accessed on the object out.

==== JSP Standard Tag Library

JSTL is the abbreviation for JSP Standard Tag Library. 
Sense and purpose of this technique is to do without Java code within JSP pages as far as possible.

*What can JSP tags?*
+
The JSTL's JSP tags perform specific tasks, which are typically accomplished using Java code blocks can be implemented. 
The areas of responsibility include whose:

* Process control (when, otherwise etc.)
* Ribbons
* XML processing
* internationalization
* Using SQL (Structured Query Language)

Tags already exist for most areas of application. 
The use of the tags makes it easier to develop, maintain and understand JSP pages.

If there is no tag for a specific task, it is also possible to use your own custom JSP tags to develop tags. 
There are three approaches to implementing your own tags:
* Simple Tags
* Classic Tags
* Tag files (from JSP 2.0)

For the Simple Tags and Classic Tags approaches, a separate TLD file (Tag Library Descriptor) that defines the corresponding tag. 
Inside of the TLD file is then a Java class that you also have to develop yourself with the tag linked. 
This Java class must be of type javax.servlet.jsp.tagext.SimpleTagSupport or extend javax.servlet.jsp.tagext.TagSupport. 
Once this TLD in its own JSP page is integrated, the self-defined tag can be used. 
For further information on own JSP tags is referred to [Wißm09]. 
Fig. 4.2-1 illustrates the relationship between JSP page, TLD and Java class.

image::

Fig. 4.2-1: Simplified TLD concept.

*functioning of JSP tags*
+
No Java code is used in the JSP page itself, just a tag and a reference to the tag library descriptor. 
The tag library descriptor links the tag with a Java class. 
Once this tag is used during the render process (i.e. creation of the HTML document) of the JSP page is encountered, the corresponding doTag() method of the Java class, which then renders the respective HTML codes takes over.

These JSP tags can then be packed as a JAR file (Java Archive) and without any problems use in other web projects.

*Example*
+
The implementation of the previous example (see »Java Web Development with Servlets and JSP pages«, p. 15) with JSTL will now be explained (program WebdevelopmentJSP).

index_ jstl.jsp
+
----
<%@page contentType="text/html" pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>JSTL</title>
</head>
<body>
    <jsp:useBean id="user" scope="page" class="jsf.beans.user" />
    <jsp:setProperty name="user" property="name" param="username" />
    <form>
        <input type="text" name="username"/>
        <input type="submit" value="send"/>
    </form>
    <c:choose>
        <c:when test="${user.name!=null}">
            <p><c:out value="Hello, ${user.name}"/></p>
        </c:when>
    </c:choose>
</body>
</html>
----

*Explanation*
+
In contrast to JSP scripting, no Java code is used, only tags used. 
Not only the usual HTML tags are visible, but also special JSP tags (jsp:useBean ...) from the corresponding tag libraries (Tag libraries).

The JSP solution is no longer as "technical" as the previous solution. 
It is still necessary to read the parameter from the request, i.e. evaluate the request, however, the request is abstracted: the word request itself no longer appears. 
The following is a short list of the important ones Features of this JSP solution shown:

* JSP tags are used instead of Java code to generate the HTML code. 
The username parameter is simply added to the `jsp:setProperty` tag in the property name of the object user saved, in turn, with the tag jsp:useBean was created.
* Scopes are used to store objects.
* Of course it's not enough just to have an object user of the type jsf.beans.user to generate. 
It is necessary to say in which scope it is located, i.e. where it is to be stored.
* The so-called EL (Expression Language, see »Expression Language«, p. 21) used to open Java code even for simple evaluations avoid.
* In this solution there is no line of Java code, just the EL expressions ${user.name!=null} and ${user.name}.
* Overall, the solution is therefore somewhat more abstracted from the underlying technology.

For more information on the subject of JSP tags, see the sources [Babl03] and [Horn09].

==== Expression Language

The EL (Expression Language) is used to define expressions that are used in JSP pages can be used.

The EL is a scripting language that allows easy access to objects that are
are in any scope. Historically, EL was initially in
JSTL introduced and adopted as a standalone technique since JSP 2.0.

=== JSF Pages

*More fundamental Construction*
+
Facelets are used when developing JSF applications. 
To the Comparing a JSF web application to a regular Java web application is discussed in 
Fig. 4.3-1 shows the basic structure of a JSF web application.

*comparison*
+
The graphic is slightly different from a usual Java web application (see »Java Web Development with Servlets and JSP Pages«, p. 15). 
Since this is a Model 2 web application, only the Faces servlet is accessed and no longer directly to the JSF pages. 
The Faces servlet is that previously mentioned front controller servlet (see "Web Application Architecture", p. 10). 
This is provided by the JSF framework.

image::

Fig. 4.3-1: Structure of a JSF web application.

Besides the web.xml, which is required by every Java web application, there is one another configuration file called faces-config.xml. 
This file can be used for configuration used by JSF-specific settings. 
It is true that Faces takes over Servlet only general tasks like calling the JSF pages, however it is natural application-dependent when which JSF page should be called. 
Exactly the faces-config.xml file provides such information.

*Example*
+
To make these differences a little more tangible, the web application, which have already been presented in the comments on servlets and JSP pages (see "Java Web Development with Servlets and JSP Pages," p. 15), now implemented as a JSF application (program WebdevelopmentJSF).

index.xhtml
----
<h:body>
<h:form>
<h:inputText value="#{user.name}" />
<h:commandButton value="send" />
</h:form>
<h:outputText value="Hello, #{user.name}" rendered="#{user.name!=null}" />
</h:body>
----

web.xml
----
<welcome-file-list>
    <welcome-file>index.xhtml</welcome-file>
</welcome-file-list>
----

faces-config.xml
----
<?xml version='1.0' encoding='UTF-8'?>
<faces-config version="2.3"
    xmlns="http://xmlns.jcp.org/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
    http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_3.xsd">
</faces-config>
----

User.java
----
@Named("user")
@SessionScoped
public class User implements Serializable {
    private String name;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
----

*Explanation*
+
The content of the `index.xhtml` JSF page does not contain any Java source code. 
The integration it is even forbidden here. 
Only JSF tags and EL expressions may be used will. 
The EL expressions used here are - in contrast to the EL expressions in the JSP examples - preceded by a »#«. 
These will explained later in the book (see "Expression Language," p. 33). 
In the User.java class, the @Named("user") annotation is used to make an object of this type available within the JSF page. 
The annotation @SessionScoped specifies that the object is in the context of a session
is saved.

=== Conclusion on servlets and JSP pages

JSP pages with EL or JSTL abstract more from the underlying one Technology as servlets or JSP scripting. 
With JSF becomes even stronger from technology abstracted.

*Motivation for JSF*
+
To understand the motivation behind the JSF technique, it is helpful to look at the historical development of the previous technologies and their weaknesses.

*comparison JSP/Servlet*
+
In general it can be said that by using EL or JSTL will achieve better results than using servlet technology. 
There are multiple reasons for this:

* Stronger abstraction from the underlying technical conditions: For example, explicit access to the request is no longer necessary.
* Better separation of the business logic from the view: the Java code can be relatively 
easily be swapped out in Java classes, while the JSP page itself is just the view.

*weaknesses of Servlet approach*
+
In larger projects, servlet classes can quickly become confusing because Here HTML and Java code are mixed in one class. 
With project guidelines could this problem be mitigated, but would probably have to, sooner or later, a small web framework will be developed. 
Because of the large number of existing this is not necessary for frameworks. 
It makes more sense to choose a suitable one from the outset select a framework that encapsulates technical aspects.

*Weaknesses of the JSP / JSTL approach*
+
The use of JSP scripting, JSTL or EL is certainly a significant improvement here compared to the servlet technique. 
However, there are still some aspects to consider here to take care of:
* Transfer of data from the request into objects.
* creation of objects.
* Generate HTML (although this is already partly inherited from the JSTL becomes).
* Flow control (which JSP page is called after which user action).

JSF abstracts even more from the underlying technology and provides solutions for the above problems and this should ultimately be motivation enough to delve deeper into JSF in the following chapters.

== JavaServer Faces

Developing with JSF is a bit different than developing with Servlets or JSP pages. 
JSF is a framework based on the Model 2 - Concept.

*differences to development without JSF*
+
Development with JSF is further removed from the underlying web technology than in Java web development with servlets and JSP pages. 
Although the use of EL or JSTL is already a possibility, to a certain extent of JSF still tries to abstract the technical details of a web application to go one step further. 
JSTL uses tags that mainly have the task of generating certain HTML parts. 
With JSF one uses Components that are similarly easy to use as the tags, but still offer more possibilities than with simple JSTL tags. 
Another point is that at a simple web architecture directly on the view (i.e. the servlets and JSP pages, that generate the HTML) is accessed. 
This is also referred to as Model 1 - web applications.

In contrast, with JSF, the view is not accessed directly, but indirectly via a so-called front controller servlet. 
That is, the user calls not directly a JSF page, but first the front controller servlet, which in turn calls the JSF page and returns the generated HTML to the user. 
This is referred to as Model 2 web applications. 
These web applications are based on the MVC pattern (model view controller) known from fat client development. 
However, since this pattern does not apply one-to-one to web applications sometimes referred to as the MVC-2 pattern. 
The following Chapters explain the main approaches and basic techniques in context from JSF:

»History«, p.27
»Architecture of JSF«, p.29
»View Declaration Language«, p.30
»Tag Libraries«, p.31
"Expression Language", p.33
"Managed Beans", p.35
»Annotations vs. Configuration File«, p.54
"Bindings," p.56

=== History

JSF 1.0 was described in JSR 127 in 2004. 
A few have come over the years versions until the current version 2.3 was published.

JSF aims to abstract from the underlying technology and existing ones Standardize approaches to Java web development.

*JSF 1.0*
+
The first JSF version 1.0 was released in March 2004 (Final Release 1) and was not yet part of the Java EE specification (Enterprise Edition).

*JSF 1.1*
+
This version was still heavily buggy and so two months later the Version 1.1 (Final Release 2) released. 
In this version, the specification not changed, just bug fixes.

*JSF 1.2*
+
JSF 1.2 was subsequently released in May 2006 in JSR 252 and also in the Java EE specification 5 added. 
The following functionalities were added (excerpt):
* Expression Language:
+
In the previous versions there is an EL version, which was created specifically for the needs of JSF. 
This is independent from the EL used in JSP technology. 
This is due to that older JSF versions (before 1.2) are based on JSP version 2.0 and the
EL existing there had to remain valid. 
In JSF 1.2 these were now both EL versions (see »Expression Language«, p. 33).

*Messages to components*
+
It can now send messages to specific components be linked. 
This is particularly interesting for validation errors, since the error can now be displayed directly on the component.

*JSF 2.0*
+
With version 1.2, JSF was widely used. 
The next version was 2.0 specified in JSR 314 in June 2009 and included in the Java EE specification 6. 
The following functionalities were added (excerpt):

*Facelets:*
+
JSP has been replaced as a page declaration language by facelets (see »View Declaration Language«, p.30).

*AJAX (Asynchronous JavaScript and XML):*
+
This is an asynchronous data transmission between the client (web browser) and the server
(Web server) (see "Asynchronous JavaScript and XML," p.189).

*Components:*
+
Own components can be developed without Java code (see »Reuse«, p.215).

*Validation:*
+
Information on validations can be specified directly at the points where they are needed, e.g. as annotations for the attributes (see »Validation«, p.109).

*Annotations:*
+
Through the wide use of annotations, JSF applications very easy to configure.

*Resources:*
+
The management of resources, e.g. CSS (Cascading Style Sheets), has been significantly simplified (see »Management of Resources«, p.183).

*Scope:*
+
A new scope view has been added.

*JSF 2.1*
+
A year later (October 2010) version 2.1 was released. 
In this version mainly errors were fixed and the specification was changed in some places
reworked. 
The following functionality was added (excerpt):
* JSP Document Syntax :
+
Files in the JSP Document Syntax (file extension .jspx) are treated like facelets.

*JSF 2.2*
+
The JSF version 2.2 was specified in May 2013 in the JSR 344 and in the Java EE specification 7 included. 
The following functionalities were added (excerpt):
* Faces Flows:
+
Several websites can be combined as processes in flows (see »Faces Flows«, p.237).

* HTML5 support:
+
HTML5 has a number of new attributes that are included in JSF 2.1 is not supported and therefore cannot be displayed. 
JSF 2.2 enabled now the specification of "pass through attributes ", which is simply in the generated document (see »HTML5 Friendly Markup«, p.197).

*upload files*
+
It is now possible with JSF to create a file using the component `h:inputFile` (see »File upload«, p. 143).

*JSF 2.3*
+
The current JSF version 2.3 was specified in April 2017 in JSR 372 and in the Java EE specification 8 added. 
The following functionalities were added (excerpt):

* CDI managed beans instead of JSF managed beans:
+
The management of the objects is the responsibility of the application server and not the JSF framework (see »Managed Beans«, p.35).

* Java support:
+
Language elements from Java version 8 can be used will.

* WebSocket integration:
+
Native WebSocket usage is possible (see »WebSocket«, p.201).

* Validation:
+
Class-level validations can be performed (see »Validation«, p.109).

=== Architecture of JSF

JSF is a Model 2 framework - this is easy to do on the central Front-Controller-Servlet, called JSF Faces Servlet.

JSF works like a Model 2 application (see »Web Application Architecture«, p. 10). All input and output takes place via Faces Servlet.

*Configuration of web.xml*
+
In the `web.xml` configuration file, Faces Servlet is specified as the one to be used Servlet not mandatory. 
The FacesServlet class can automatically be used as the working class can be set for the requests, provided the configuration file `facesconfig.xml` or at least one class with a JSF annotation (e.g. @FacesConfig) is available. 
This means that the <servlet>...</servlet> area can be omitted. 
Also optional is the characteristic of the mapping. 
If the area <servlet-mapping>...</servletmapping> is not set, all `*.xhtml` files are automatically sent to the FacesServlet Posted.

*Example*
+
Optionally, the use of Faces Servlet be defined as follows:

web.xml
----
<servlet>
    <servlet-name>Faces Servlet</servlet-name>
    <servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>Faces Servlet</servlet-name>
    <url-pattern>*.xhtml</url-pattern>
</servlet-mapping>
----

NOTE:
----
A JSF page can be made available in a web container, too if the Faces servlet is not set up, however, in this case then only the text of a JSF page is displayed without being processed.
----

*compared with style 2*
+
Fig. 5.2-1 shows a modified Model 2 mapping, which shows the process of a JSF application again schematically.

image::

Fig. 5.2-1: Process Model 2 in the context of JSF applications.

The illustration makes it clear once again that the Faces Servlet is used in the context of JSF representing the front controller servlet. 
Strictly speaking, the CDI container creates the managed beans and not the faces servlet. This situation will be discussed later process described in more detail. 
The individual JSF pages (1.xhtml and 2.xhtml) are created using XHTML and use Facelets as page declaration language. 
the client receives HTML pages (HTML5 pages to be precise) as a response.

=== View Declaration Language

As VDL (View Declaration Language), the page declaration language becomes one specific technology. 
With JSF, since JSF 2.0, these are the facelets.

*Facelets vs. JSP*
+
Facelets replaces JSP as the page declaration language for JSF applications. 
This has diverse Reasons. 
As already described in the previous chapters, JSF abstracts more dependent on the underlying technology than JSP. 
Since JSF 2.0, Facelets is used as primary page declaration language used. 
Before JSF 2.0, JSP was used as the primary page declaration language used. 
The aim was to enable developers to switch from JSP to JSF as easy as possible.

*life cycle*
+
Facelets and JSP go through very different lifecycles. 
A JSP page will loaded on first request. 
The JSP page becomes a JSP class (servlet) transformed and remains available as long as the web server is started and the JSP page has not been modified. 
The life cycle of JSF pages is much more complex (see "The JSF Life Cycle," p.165). Various tasks (e.g. render, validate, convert) are processed in a specific order.

The situation becomes especially problematic when the two technologies are combined will. This is the case when JSF elements and HTML elements are used at the same time be used. The HTML elements are displayed directly when creating the view, while the JSF elements in the component tree (see »Component Tree«, p.161) and only generated at the end of the life cycle. 
With new ones Applications should use Facelets as page declaration language. 
Facelets is a lightweight page declaration language, which uses XHTML elements created the JSF pages and the component tree.

=== Tag Libraries

Tags are familiar from ordinary XHTML pages. 
JSF tags are more complex Constructs used to build a JSF page. 
In tag libraries (Tag Library) the tags are defined. 
JSF supports various tag libraries.

Various tag libraries can be used in facelets. 
In Table 5.4-1 the tag libraries supported by facelets are listed (excerpt).

|====
|Tag-library
|URI
|prefix

|JavaServer Faces Facelets
|http://xmlns.jcp.org/jsf/facelets
|ui:

|JavaServer Faces HTML
|http://xmlns.jcp.org/jsf/html
|h:

|JavaServer Faces Core
|http://xmlns.jcp.org/jsf/core
|f:

|Pass-through Elements
|http://xmlns.jcp.org/jsf/passthrough
|jsf:

|Pass-through Attributes
|http://xmlns.jcp.org/jsf
|p:

|JSTL Core
|http://xmlns.jcp.org/jsp/jstl/core
|c:

|JSTL Functions
|http://xmlns.jcp.org/jsp/jstl/functions
|fn:
|====
Table. 5.4-1: Supported tag libraries.

Depending on the required functionality, a corresponding tag library can be used will. 
A combination of the libraries is also possible. 
With the one shown prefix is just the default prefix. 
This can also be used if required get a different abbreviation. 
For a list of all available tags go to [Orac18a]. 
In this book, the standard prefix of each discussed Tags always specified.

*Facelets*
+
The JavaServer Faces Facelets Tag Library contains all tags required for using templating are necessary (see »Templating«, p.81) (excerpt):

* ui:component
* ui:insert
* ui:repeat
* ui:param


*HTML*
+
The JavaServer Faces HTML Tag Library contains tags for all UIComponent objects. 
There-where are the components that generate the HTML code (excerpt):

* h:head
* h:body
* h:form
* h:outputText
* h:inputText
* h:message
* h:messages

*Core*
+
The JavaServer Faces Core Tag Library contains tags for all components that require basic 
enable actions independent of a specific render kit (excerpt):

* f:actionListener
* f:attribute
* f:param
* f:loadBundle
* f:validateLength

*Pass-through Elements*
+
The Pass-through Elements Tag Library contains tags for HTML5 support friendly markup (excerpt):
* jsf:id
* jsf:element

*Pass-through Attributes*
+
The Pass-through Attributes Tag Library contains tags for HTML5 support friendly markup (excerpt):
* p:type

*JSTL Core*
+
The JSTL Core Tag Library contains tags for frequently used functions (excerpt):

* c:catch
* c:choose
* c:forEach
* c:if
* c:when

*JSTL Functions*
+
The JSTL Functions Tag Library contains tags for standard functions where mostly a manipulation of texts is carried out (excerpt):

* fn:contains
* fn:toUpperCase
* fn:toLowerCase
* fn:trim

*Component, renderers, handlers*
+
A typical pure JSP application using JSTL is pronounced- finally by tags. 
With JSF, however, it's not just tags that are used. 
Rather, the tag is just a link between the JSF page and the component, renderer or handlers. 
The component provides the actual functionality and uses a Renderer for the rendering (depending on the context, e.g. HTML code). 
A special one Java class (called tag handler) can be defined as a tag's "handling class" 
and is called when building the component tree. 
For that she has to Class javax.faces.view.facelets.TagHandler can be extended. 
If no tag handler is defined, Facelets creates a default tag handler. 
Furthermore, it is possible Create tag handlers specific to the component. 
For this, the class javax.faces.view.facelets.ComponentHandler are extended.

The structure of a JSF component is illustrated in Fig. 5.4-1. 
In the TLD must at either a component or a tag handler can be entered in a tag. Additionally a specific renderer can be configured for a component.

image::

Fig. 5.4-1: JSF component.

In JSF, the tags are only used as placeholders in the JSF pages. 
For example, you speak from putting a tag in the JSF page. 
However, if you talk about that Generating HTML, one usually refers to the component or the used renderer.

Compared to simple tags, components have more possibilities. 
These options will be discussed in more detail later.

=== Expression Language

The EL (Expression Language) enables communication between the Views and the business logic.

The EL (Expression Language) was initially created with the JSTL under the name SPEL
(Simplest Possible Expression Language) introduced. 
Since JSP 2.0, EL expressions can also be used outside of JSTL tags to separate Java code from the JSP portion separate.

With the introduction of JSF, a corresponding EL was also specified, which is JSF context could be used. 
A separate EL for JSF was necessary because the ELExpressions be evaluated directly in JSP (when parsing the page). 
The Life Cycle of JSF applications is more complicated and therefore the EL expressions can also be used in be evaluated at a later stage.

The Expression Language is currently available in version 3.0. 
This is fundamental independent of JSP and JSF, but combines the "JSP-EL" and the "JSF-EL". 
The specification can be viewed at [Orac13].

*evaluation*
+
The EL differentiates between immediate and deferred evaluation.

* Immediate
+
With immediate, a specific expression is evaluated and returned as soon as the page was first rendered. 
This behavior is already known from JSP. 
This type of evaluation is specified with "$" and can only be read on certain access attribute values.

* Deferred
+
In contrast, with deferred, the evaluation can take place at a different phase of the life cycle are carried out. 
This type of evaluation is specified using "#". 
and has both read and write access to attribute values. 
Additionally methods can also be evaluated. 
This is not possible with immediate.

NOTE:
The preferred page declaration language, Facelets, does not distinguish between immediate
and deferred. 
The expressions with "$" are treated in the same way how "#". 
It is always a deferred evaluation.

*Expressions value and method*
+
There are two types of expressions: value expression and method expression.

*Value expression*
+
With value expression, you can still choose between rvalue (read-only data) and lvalue (data read and write) can be distinguished. 
This is an access on attribute values. 
Expressions with "$" are always rvalue, while expressions with "#" rvalue or lvalue (depending on the underlying technology).
NOTE:
Facelets treat expressions with "$" the same as "#". 
Access can be read or done in writing.

*Method expression*
+
With method expression, methods are invoked. 
These methods must be public and can provide a return value. 
Parameters can also be set these methods are passed.

NOTE:
Because a method can be called at different stages of its life cycle it is always a matter of deferred evaluation. 
The expressions will i.e. introduced with »#«.

Example:
DemoEL
The following example uses the types value expression and method expression shown. 
An object of class jsf.beans.Output named output (@Named("output")) as a managed bean in session scope (@SessionScoped) made available. 
Managed beans are objects managed by the application server to get managed. 
The objects are generated automatically. 
the Configuration of such objects is described in the "Managed Beans" chapter. 
The web.xml configuration file is not shown here.

Output.java
----
@Named("output")
@SessionScoped
public class Output implements Serializable {
    private String param;
    private boolean selection = false;
    // Getter und Setter
    ...
    public String spend(String parameter) {
        this.selection = true;
        return parameter + " and " + this.param;
    }
}
----

index.xhtml
----
<h:body>
<h:form>
    <h:inputText value="#{output.param}" />
    <h:commandButton value="send" />
</h:form>
<h:outputText value="Output 1: #{output.param}" rendered="#{output.selection!=false}" />
<h:outputText value="Output 2: #{output.spend('parameter')}" />
<h:outputText value="Output 3: #{output.param}" rendered="#{output.selection!=false}" />
</h:body>
----

*Explanation*
+
The first time the page is called up, the following result is displayed:

Output 2: parameter and null
Output 3:

The first output is not generated because it first checks whether output.selection!=false. 
This is not the case when the page is called up for the first time, since this value is initially assigned false. 
The second output calls the method String Output(String parameter) and passes the  parameter value parameter. 
Within the method, selection=true is set and then the concatenated value parameter, "and" and the value of param are printed. 
Since there is no value for param is present, null is returned. 
The third output is rendered because at the value selection=true was set in the previous method call. 
The condition is thus fulfilled.

Sending the value input produces the following output:
Output 1: input
Output 2: parameters and input
Output 3: input

The conditions for the first and third editions are met and it is now a Value for param present.

=== Managed Beans

Managed beans are objects managed by the application server. 
The objects are generated automatically. 
Furthermore, the properties of a Auto-populate managed bean. 
The concept of managed beans is presented in the following chapters described.

* Introduction to managed beans
==== Introduction to managed beans
Managed beans are objects automatically generated by application servers and made available in a specific scope. 
They are configured via annotations in the respective managed bean class.

*introduction*
+
To access objects in JSF pages under a specific name (e.g. user) enable, they must be generated and available in a scope be asked. 
Starting with JSF 2.3, objects should be managed exclusively via CDI (Contexts and Dependency Injection) (see »Contexts and Dependency Injection«, p.37).

When using information like #{user.name} it doesn't seem like it at first glance what type it is and in what scope of validity object is present. 
This information must also be stored. 
This happens via annotations in the underlying Managed Bean class.

*What is a managed bean?*
+
For objects that are automatically generated by a container (in the context of JSF, this is CDI) generated and stored in a scope is called managed beans.

*managed bean class*
+
A managed bean is a "contextual instance" of a managed bean class. 
One Managed Bean class is used to implement for state saves and/or for Implementation of logic used. 
The underlying container (in this case the CDI container) is responsible for creating and destroying the object, as well as the classification in the specific context. 
Contextual instances can be found in other objects of the same context are "injected".

Managed Bean classes should meet the following requirements:
* Definition of a unique name
* Definition of a scope
* Implementation of Serializable
* Using a parameterless constructor

Example:
An annotated managed bean class is shown below.
----
@Named("user")
@SessionScoped
public class User implements Serializable {
    private String name;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
----

*Explanation*
+
Not all of the requirements described above need to be met explicitly:

* The @Named("user") annotation is used in the User.java class, to make an object of this type available under the name user. 
Omitting the name label by using @Named would result in return the same result in this case: it will be the class name with a small assign first letters as default name. 
More constellations in the context of naming are possible. 
For more information will refer to [ReHa17].
* The `@SessionScoped` annotation specifies that the object is in the context of a session is saved. 
Other options for determining availabilities are described in »Contexts«, p.39.
* The Serializable interface as a marker-only interface must be scoped are used in which objects are serialized and deserialized will.
* In the absence of a parameterless constructor, it becomes implicit added. 
For this reason, the information is not mandatory. 
However, one will parameterized constructor implemented, does not find the implicit addition instead of.

==== Contexts and Dependency Injection

CDI (Contexts and Dependency Injection) (JSR 365) is a Java standard EE (Enterprise Edition) with which it is possible to manage objects to be performed in the application server. 
This means that the objects used are in available throughout the application.

*Java EE*
+
Before CDI can be discussed, a few terms must first be led. 
In the context of this book, we always talked about web applications. 
In Business applications (also enterprise applications), however, this is only one Component of the overall software architecture. 
Describes a software architecture the general structure of a software system. 
Especially in the Java environment exists the "Java EE" specification, which is a software architecture for enterprise applications pretends. 
The application server GlassFish from Oracle is the reference implementation this specification. There are other application server implementations as well such as e.g. Payara, JBoss. 
The current Java EE 8 specification is maintained by »GlassFish 5« implemented. 
The CDI specification can be viewed at [ReHa17].

*Container*
+
Within the Java EE specification, server and container services are the most important Elements. 
A container describes a logical component that has a specific task fulfilled and can communicate with other containers. 
Java EE defines the following containers:
* Applet Container: Management of applets
* Application Client Container: Management of applications running on the client to be executed
* Web Container: Management of web applications
* Enterprise JavaBeans Container: Management of EJBs

*EJBs*
+
EJBs implement the business logic, i.e. the actual »task« of the company application.

*Layers*
+
The available containers are divided into different layers: Application Client containers and applet containers are distributed at the client tier, the web Container is distributed to the web tier and the Enterprise JavaBeans container is distributed to the business logic layer.

These logical layers in turn can be distributed to physical targets: The Client tier runs on the client machine and the web tier as well as the business logic layer run on the application server (Java EE server). 
Additionally is still a persistence layer running on a database server. 
A simplified one Representation of the layers is shown in Fig. 5.6-1.

image::

Fig. 5.6-1: Layers of an application.

A client application accesses the business logic layer directly while a Web browser must first access the web layer. 
Exclusively about the Business logic layer can be accessed to existing persistence layer Persist (store) objects. 
For more information on software technical infrastructures, reference is made to [Balz11]. 
A detailed overview of the Java EE 8 specification is given in [Orac17].

*Contexts*
+
Contexts are used to determine the scope of the managed beans. 
The available ones Scopes are described in the »Contexts« chapter.

*Dependency Injection*
+
The term dependency injection describes a procedure in which an object of another object is made available outside. 
The object needs generation of the required object itself. 
One gains flexibility and one loose Coupling. 
The objects are managed in different places. 
With CDI Managed Beans, this is the Context and Dependency Injection service included in all containers is available. 
A closer look is given in the chapter "Dependency Injection", p.44, given.

*Managed Beans*
+
CDI managed beans are managed by the application server. 
The so generated objects can be used in the web application via the Expression Language but also in the entire application server. 
It's about the created objects are not directly instances of managed bean classes, since dated
Application server so-called proxies are generated, which access the actual Encapsulate objects (so-called proxy pattern). 
Through the use of proxies non-functional requirements, e.g. B. safety aspects, can be implemented more easily. 
The created objects can also be used in any other artifacts (e.g. filters, listeners) are used. Later in the book are using managed beans always meant CDI managed beans.

*Comparison CDI and EJB*
+
Enterprise JavaBeans are managed in the EJB container and, in contrast to CDI managed beans extended functionalities such as transactions or security aspect.

==== Contexts

There are different areas of validity (also: scopes) that determine how long an object has existed and from where it can be accessed.

Within a web application, objects can be created and then saved. 
However, the question arises as to where exactly these objects are stored.

*Motivation*
+
In an ordinary Java application, an object is stored in a property of another object or in a static property. 
In a web application However, an object is used by several users. 
So it must be determined at which point the objects are made available and for how long
these should remain available. 
Exactly this definition is called the scope.

*Object storage options*
+
A username e.g. B. is clearly user-related. 
But also information like a search query, a search result or a data record to be processed are user-related information that is only available to a specific user.

==== Dependency Injection

==== Advanced configuration

=== Annotations vs. Configuration File

=== Bindings

== Case study blog application overview

The following case study is used to illustrate the respective topics of the following chapter to deepen practically. 
This is a blog Application. 
First, the required classes for the »Business Logic« and the basic configuration files are created.

*What is a blog?*
+
A blog is a kind of diary. 
Any text entries can be created, each with a title, date and a category. 
Then they can displayed one below the other, creating a kind of diary.

*Functionality*
+
In order not to make the application too complicated, the »business logic« (here only persistence logic exists instead of business logic) for this sample application (case study overview) already implemented and is therefore not explained in detail.
The classes provided offer the possibility of text entries with a title, a text, a category and a date in a definable directory save. 
Alternatively, the current user's home directory used for storage. 
Multi-user use is not intended.

Fig.6.0-1 shows what the finished software could look like.

image::

Fig.6.0-1: Case study: list of blog entries.

*Create blog entry*
+
The central use case of the application is to create a blog entry. 
The user should be able to enter the information for title, date, category and to capture text. 
These details are then available as a blog entry on the provided classes are saved (Fig. 6.0-2).

*Classes*
+
The classes that enable the entries to be saved and loaded are already made available and therefore do not have to be programmed by yourself. 
In this chapter introduces the classes that are used for this and the next use cases are needed. 
The classes are shown in Fig. 6.0-3 as a UML diagram shown.

The central BlogManager class provides persistence and the BlogEntry class represents an entry in the blog.

image::

Fig.6.0-2: Case study: Blog entry process - input.

image::

Fig.6.0-3: API of the case study in UML notation.

The properties of the BlogEntry class are listed in Table.6.0-1.

|====
|Property
|Description

|id
|A unique number. 
This is set by the BlogManager - the first time save - Assigned and does not need to be set explicitly.

|title
|The title of the blog entry.

|text
|The content of the blog entry.

|category
|The category of the blog post.

|date
|A date to which the blog entry refers.
|====
Table. 6.0-1: BlogEntry properties.

The BlogManager class provides the following methods:

*Methods of Blog Manager*
+
public void saveEntry(BlogEntry entry):
Saves a new entry.
public void deleteEntry(BlogEntry entry):
Deletes an existing entry.
public List<BlogEntry> getAllEntries():
Returns all saved entries.
private String getFilename():
Returns the path to the persistence file. 
Is a path in the web.xml by the user defined, this is used. 
Otherwise, the home directory of the current User used for storage.
private void saveDb(List<BlogEntry> list):
Persist the existing blog entries.
private void initDb():
Initializing the database.

*Own storage path*
+
By default, the path `c:\blog.db` is used to store blog entries. 
A user-defined storage path can be specified in the `web.xml` configuration file.

web.xml
----
<context-param>
    <param-name>blogdbpath</param-name>
    <param-value>c:\blog.db</param-value>
</context-param>
----

An object of class BlogManager is implemented as a managed bean in scope of a Session created:

BlogManager.java
----
@Named
@SessionScoped
public class BlogManager implements Serializable {
    ...
}
----

*Overview*
+
Fig.6.0-4 shows an overview of the available programs.

image::

Fig.6.0-4: Case study: Overview of the different programs.

Based on the program case study overview, the programs case study input mask, Case study file upload and case study tables implemented. 
The program case study input mask serves as the basis for the programs case study templating, case study internationalization, Case study navigation, case study converter, case study validation, case study Shortlists and case study resources. 
The differences are in the description explained in the respective case study. 
In the Total Case Study program, all content is summarized in one application.

== Basic JSF components

=== Box: Component Hierarchy

=== h:outputText

=== h:inputText, h:inputSecret, h:inputTextarea

=== h:commandButton, h:commandLink

=== The components in interaction

=== Case study blog application - input mask

== Templating

=== JSF-Templating

=== Case Study Blog Application - Templating

== Internationalization

=== JSF internationalization

=== Case Study Blog Application - internationalization

== Navigation

Web applications usually do not only consist of one page. 
The following chapters explain the possibilities for realizing navigation in the context of JSF:

=== JSF-Navigation

JSF offers the possibility to choose between navigate multiple pages.

It is often necessary to implement an application with several pages. 
In the most cases, a realization with only one side should not be an option at all, for example when entering data records. 
A distinction is made between 'user-defined' and 'implicit' navigation.

*Custom Navigation*
+
Normally, navigation rules (also: navigation rules) are defined. 
This determine under which conditions from which side to which other side is referenced. 
For example, from `index.xhtml` page to `saveOK.xhtml` page. 
the conditions are described by so-called outcomes in the `faces-config.xml` (Program DemoNavigation).

Example 1a.
A navigation rule is then defined in the faces-config.xml file.
faces-config.xml
----
<navigation-rule>
    <from-view-id>/index.xhtml</from-view-id>
    <navigation-case>
        <from-outcome>ok</from-outcome>
        <to-view-id>/speichernOK.xhtml</to-view-id>
    </navigation-case>
</navigation-rule>
----

*Explanation*
+
This navigation rule determines that from the page `index.xhtml` to the page `save-
OK.xhtml` is branched. 
But only with the outcome ok.

*What is a outcome?*
+
An outcome is the result (i.e. the return value) of a method initiated by JSF method call. 
As already shown, in JSF, buttons and links are created using Method binding associated with an action.

Example 1b
The following example is conceivable:

JSF page:
<h:commandButton value="save(ok)" action="#{exampleBean.actionSaveOK}" />

Method:
public String actionSaveOK() {
    return "ok";
}

*Explanation*
+
In contrast to the method bindings considered so far, this method returns a string and does not return void. 
With this return value one also speaks of the outcome of the method. 
This value will used to determine the appropriate navigation rule. 
Here would be the outcome always ok and the current page is index.xhtml. 
Therefore, JSF will save to the pageOK.xhtml branch. 
The method would return an unknown value (for example nok), then JSF would appear on the current page (ie index.xhtml) stay.

*outcomes are variable*
+
Of course, it is not only possible to always return the same value, but different values could be returned via an if query.

It would be conceivable that the method checks something and depending on it ok or nok
returns. 
Depending on the outcome of the method and how the navigation rules are defined, JSF then links to one side or the other.

Example 1c
An example that saves from the `index.xhtml` page to OK if the outcome is `ok.xhtml` and in the case of an outcome of `nok` refers to saving `NOK.xhtml` the following:

----
<navigation-rule>
    <from-view-id>/index.xhtml</from-view-id>
    <navigation-case>
        <from-outcome>ok</from-outcome>
        <to-view-id>/speichernOK.xhtml</to-view-id>
    </navigation-case>
    <navigation-case>
        <from-outcome>nok</from-outcome>
        <to-view-id>/speichernNOK.xhtml</to-view-id>
    </navigation-case>
</navigation-rule>
----

*Explanation*
+
Two navigation cases are defined here. 
JSF will consider the case whose `from-outcome` attribute matches the outcome returned by the method. 
In this case, the first navigation case (saveOK.xhtml), if the outcome is ok or the second navigation case (saveNOK.xhtml) if the outcome is nok. 
If no navigation case applies (e.g. in the case of an outcome test), JSF will remain on the current page (i.e. index.xhtml here).

*Peculiarities of JSF navigation*
+
At the time the user requests the `index.xhtml` page, JSF still knows not whether the following page will be `saveOK.xhtml` or `saveNOK.xhtml`. 
That decides only after the form content of `index.xhtml` from user to was transmitted to the server, i.e. he pressed the button. 
Only after pressing the button (and the associated submission of the form content) the method binding is evaluated. 
In principle, however, every form content requires submission to the server a destination URL (Uniform Resource Locator) to which this data are transmitted. 
But since it is not yet clear which side will follow, refer `index.xhtml` to itself first, so it sends the form data back `index.xhtml`.

However, JSF will not return `index.xhtml`, but the method binding first execute and `saveOK.xhtml` or `saveNOK.xhtml` according to the outcome.

=== Case Study Blog Application - Navigation

== Converter

User input is always transmitted from the browser to the server as a string, regardless of whether the input is a number or not. 
These inputs will converted from JSF to required format, for example to integer. 
For it converter used. 
Some particularly frequently used converters are in the range of JSF included:

* JSF Converter
* Custom Converter
* Case study blog application - Converter

=== JSF Converter

User input is transmitted from the browser to the server as text, regardless of whether the input is a number or not. 
Still will these values are stored as a number in the managed bean. 
JSF uses converters for this. 
Converters supplied by JSF can be used for this.

The demo converter sample program illustrates the automatic conversion. 
That `h:messages` tag displays error messages that occur. 
It is defined in »Display of validation errors«, p. 113, explained in more detail.

*Example 1*
+
The following source code uses the `h:messages` tag.
----
<h:messages/>
<h:form>
    <h:inputText id="number" value="#{beispielBean.wert}" />
    <h:commandButton value="OK" />
</h:form>
----

*Explanation*
+
In this example exampleBean.value is a property of type double. 
Returns the user if you enter a number in the text field, it will be automatically converted and correctly converted into the saved managed bean. 
Returns the user a non-numeric value (e.g. test) occurs, an error message appears, as shown in Fig. 11.1-1.

image::

Fig.11.1-1: Converter error message.

The conversion is done automatically for some types like integer, double, etc.

The validators (the topic of validators is discussed in the chapter "Validation", p. 109
deepened) are dependent on the converters. 
So a `f:validateLongRange` validator don't validate a string, just a numeric value. 
The conversion must so take place before. 
Fig. 11.1-2 shows the process.

image::
Fig. 11.1-2: Conversion process.

Step 1: The user enters a number and presses the save button.
Step 2: The value (string) is saved as submitted value in the component.
Step 3: The value will be converted. 
The converted value is called local value saved.
Step 4: Now the validator can validate the value. 
It uses the (converted) local value.
Step 5: The local value is stored in the managed bean. 
If required, this value was previously validated.

The value transmitted by the browser is therefore initially displayed as submitted in the component value (String), then converted by a converter and stored as converted value saved as local value (for more information on submitted value and local value is referred to the chapter "The JSF Life Cycle", p. 165 referenced). 
Table. 11.1-1 shows types that are automatically converted by JSF.

In addition, there is also the option of explicitly adding converters to a component. 
This is useful, for example, if values are to be converted that cannot be automatically converted by JSF.

Specifying amounts in a currency would be an example. 
Here JSF will not automatically since only the amount and not the currency is saved
(€26.05 could only be stored as a simple numerical value 26.05, the currency is decisive for the amount). 
For such a case, the universal `f:convertNumber` tag can be used.

.Table 11.1-1: Types that can be automatically converted by JSF
|====
|Converter class
|Conversion class

|BigDecimalConverter
|java.math.BigDecimal

|BigIntegerConverter
|java.math.BigInteger

|BooleanConverter
|java.lang.Boolean and boolean

|ByteConverter
|java.lang.Number

|CharacterConverter
|java.lang.Character and char

|DoubleConverter
|java.lang.Double and double

|FloatConverter
|java.lang.Float and float

|IntegerConverter
|java.lang.Integer and int

|LongConverter
|java.lang.Long and long

|ShortConverter
|java.lang.Short and short
|====

A converter like `f:convertNumber` is simply attached as a "child" to the input component. 

The following source code uses the `f:convertNumber` tag.
.Example-2
----
<h:inputText id="currency" value="#{beispielBean.wert}">
    <f:convertNumber maxFractionDigits="2" groupingUsed="true"
        type="currency" currencySymbol="€" />
</h:inputText>
----

*Explanation*
+
In the example, the value is accurate to two digits (maxFractionDigits) with the Currency (type="currency") Euro (currencySymbol) and thousands separator (groupingUsed) shown. 
It is therefore assumed that the user exclusively enter amounts in euros. 
A valid entry would therefore be 1,00€. 
The value 1.0 is then stored in the managed bean. 
This conversion works also in the other direction. 
If the value changes in the managed bean to Example to the value 2.0, 2,00€ is displayed in the GUI.

However, the `f:convertNumber` tag is not only suitable for converting currency amounts. 
It is also possible to convert arbitrarily formatted numbers. 
In addition a pattern (also Pattern) can be used.

A selection of some tag configuration options is shown in Table. 11.1-2 listed.

.Table 11.1-2: Attributes of f:convertNumber.
|====
|Attribute
|Description

|currencyCode
|ISO 4217 currency code (only if type="currency").

|currencySymbol
|Currency symbol (only if type="currency").

|groupingUsed
|Indicates whether the value is presented with thousands separators.

|integerOnly
|Indicates whether the value is an integer.

|locale
|Locale used to format the values (e.g. es).

|pattern
|A number pattern that is used (e.g. €###, usable only if type="number").

|type
|Specifies the type (number, currency, or percentage). Default is percentage.
|====

The following source code uses the f:convertDateTime tag.

.Example-3
----
<h:outputText id="date" value="#{beispielBean.datum}">
    <f:convertDateTime dateStyle="full"
        locale="es" timeStyle="long" type="both" />
</h:outputText>
----

*Explanation*
+
For example, the output here will look like this:
+
martes 6 de febrero de 2018 21:06:00 GMT.

The `f:convertDateTime` tag presented here also offers some attributes that are listed in the Table
11.1-3 are shown.

|====
|Attribute
|Description

|dateStyle
|The date format: default, short, medium, long and full (Java standard).

|locale
|Locale used to format the values.

|pattern
|Pattern to use for parsing - timeStyle, dateStyle and type are then ignored - example: MM/dd/yyyy.

|timeStyle
|The time format: default, short, medium, long and full (Java standard).

|timeZone
|Time zone - Example: Europe/Berlin

|type
|Specifies the type (date, time, or both). Default is date.
|====
Table. 11.1-3: Attributes of f:convertDateTime.

=== Custom Converter

In many cases the converters provided by JSF should be sufficient. 
For special requirements there is the possibility to develop to use your own converter.

*Requirements of a custom converter*
+
A converter is supposed to turn a string (the user's input) into an object of a certain type. 
Like a standard converter, for example string values converted to numbers (e.g. integers).

The target type (that is, the class to convert to) can be a Class from the standard scope of Java or a self-developed class. 

However, the conversion process is not a one-way street. 
Values can be read from Managed beans and written to managed beans. 
A self-developed custom converter must therefore meet two requirements:

* Ability to turn a string into an object of the target type.
* Being able to turn an object of the target type back into a string.

*Structure of a converter*
+
These requirements make it obvious that two methods are needed to be able to do the conversion. 
A method to get a String into the object of the target type, and a method that returns the object can transform back.

JSF offers an interface that is used by the implementing converter class requires exactly these two methods. 
So it is not provided the conversion methods implement in the Managed Bean class. 
Instead there is the converter from a separate class that has the described converter interface (javax.faces.convert.Converter) implemented. 
Fig. 11.2-1 shows a UML representation this converter interface.

image::

Fig.11.2-1: Converter (UML-Notation).

The example program DemoCustomConverter clarifies the use and the implementation its Custom converter.

In the following, a converter is to be developed for the following city class.

Example 1. City.java
----
public class City {
    private int zip;
    private String name;
    
    // Getter und Setter
    ...
    @Override public String toString() {
        return zip + " " + name;
    }
}
----

In the object of the City class, the name of the city (name) and the zip code can be entered
(plz) are saved. 
JSF cannot automatically convert a string into an object of type city. 
Instead, a separate converter is developed for this purpose.

CityConverter.java
----
public class CityConverter implements Converter {
    public Object getAsObject(FacesContext context, UIComponent component, String value) {
        int split = value.indexOf('');
        City city = new City();
        city.setZip(Integer.parseInt(value.substring(0,split)));
        city.setName(value.substring(split+1,value.length()));
        return city;
}

public String getAsString(FacesContext context, UIComponent component, Object value) {
    return ((City)value).getZip() + " " + ((City)value).getName();
    }
}
----

For example, this converter accepts input in the form »zip city«.

Table 11.2-1 lists the method parameters shown in this example.
|====
|Attribute
|Description

|component
|Component containing the value to convert.

|context
|Faces Context, used to communicate with the framework

|value (String)
|String to be converted to an object.

|value (Object)
|Object to be converted to a string.
|====

The example is executable in this form, but the converter must still be made known to JSF so that it can be used. 
This is possible in two ways. 
It can be registered to be automatically used by JSF whenever a property of a managed bean or a managed bean itself of type city to be filled with a value. 
Alternatively, the converter can also be connected manually to a component to be hung.

*General registration of a converter*
+
The first option (general registration of the converter) is via a Annotation in the converter class and applies throughout the application.

This example shows the registration of the CityConverterClass:
----
@FacesConverter(forClass = City.class)
public class CityConverterClass implements Converter {
    ...
}
----

If a converter is registered via the `forClass` annotation parameter, JSF uses it automatically whenever a user-entered value is placed in an object of the target class (City.class) to be converted. 
This conversion is necessary when the input in a managed bean or a managed bean property of the type of the target class is to be saved.

The following class shows this connection as an example:

Example 3: Address.java
----
@Named
@SessionScoped
public class Address {
    private City city;
    public void setCity(City city) {
        System.out.println("was set:" + city);
        this.city = city;
    }
    public City getCity() {
        return city;
    }
}
----

*Explanation*
+
Now, when a JSF page accesses a managed bean of type Address and If you want to save an input as a city, JSF would automatically use the for this Process configured converter.

The following snippet shows access to the city property from a JSF page out (it is assumed that a managed bean address of type Address configured):

.index.xhtml
----
<h:inputText value="#{address.city}" />
----

In this example, the conversion is completely transparent and requires no further intervention by the developer.

*Explicit configuration of converter*
+
In addition to the general configuration described above, there are also the ability to explicitly configure a converter. 
To do this, an explicit name in of the @FacesConverter annotation.

An explicit configuration looks like this:

Example 4: CityConverterName.java
----
@FacesConverter("cityConverterName")
public class CityConverterName implements Converter {
    ...
}
----

*Explanation*
+
The example does not generally define which converter for which target type is used, but an ID is assigned to the converter. 
Under this one it can be referenced later in the JSF page.

Explicitly adding the city converter to a component would look for that above example like this:

----
<h:inputText value="#{address.city}"
    converter="cityConverterName" />
</h:inputText>
----

The converter is also used in this case, but only explicitly in this case Component.

=== Case Study Blog Application - Converter

The case study can be extended with its own converter. 
The converter will make it possible to specify the date in the form "today" as well. 
The current date is then used.

*GUI*
+
In addition to »Title« and »Text«, the blog entries also contain a »Date«. 
The corresponding date field is therefore added to the page (addEntry.xhtml). 
Additionally need error messages are issued. 
This is implemented using the `h:messages` tag.

*Implementation CaseStudyConverter*
+
Below are the changes compared to the Case Study input mask program shown.

A converter class `DateConverter` is implemented, which is included in the display page `addEntry.xhtml` is used. 
To do this, the annotation `@FacesConverter` must be added will.

The `addEntry.xhtml` file looks like this:

addEntry.xhtml
----
<h:body>
<h:messages />
<h:form>
    ...
    <h:outputText value="Date" />
    <h:inputText converter="dateConverter"
        value="#{addEntryBean.blogEntry.date}" />
...
</h:form>
</h:body>
----

The `h:messages` tag is used to output error descriptions. 
JSF cannot do automatic conversion for the date in this example. 
Although JSF provides a suitable converter for converting to a date (Date-TimeConverter), but this will (in contrast to all other supplied converters) not automatically drawn by JSF because the formatting information is different (e.g. 2018-04-13, 2018-04-13). 
Although this could be done via the Locale be determined, but it must be determined whether an entry with date and time (or only date or only time) is available. 
This cannot be determined done automatically.

DateConverter.java
----
@FacesConverter("dateConverter")
public class DateConverter implements Converter {
    public Object getAsObject(FacesContext context, UIComponent component, String value) {
        if("today".equalsIgnoreCase(value)) return new Date();
        SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");
        Date date = null;
        try {
            date = sdf.parse(value);
        }
        catch(ParseException ex) {
            ex.printStackTrace();
            throw new ConverterException (
                new FacesMessage("Date cannot be converted")
            );
        }
        return date;
    }

    public String getAsString(FacesContext context, UIComponent component, Object value) {
        Date date = (Date)value;
        SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");
        String dateText = sdf.format(date);
        if(dateText.equals(sdf.format(new Date()))) return "heute";
        return dateText;
    }
}
----

The converter is configured explicitly here. 
The converter can be found at Specification of the name `dateConverter` can be used. 
For each component, creates a new object of the class.

In this example, a custom converter is developed. 
The converter to be developed should - regardless of the locale set in the browser - a date in the form dd.MM.yyyy (e.g. 07.02.2018) and also accept an entry in the form »today«. 
When the user enters "today" in the field, it automatically becomes the current date used. If the date is to be output, in the event that the to be output date corresponds to the current date, also printed as "today". 
A possible internationalization is left out for the sake of simplicity. 
In the converter, the SimpleDateFormat class is used to convert the String object to transform a Date object and vice versa. 
If the date is the current date, this is a special case: Here »today« is used as the representation used instead of the date. 
In the event of an error, a ConverterException is thrown. 
JSF will then generate an appropriate error message, which is defined by the `h:messages` tag is shown.

Fig.11.3-1 shows the Managed Bean objects involved in the case study.

*Managed Bean-Objects*
+
image::

Fig.11.3-1: Managed Bean objects involved in the converter case study.

Compared to the case study input mask program, only the object `dateConverter` added. 
This is created a new for each component. 
If in a JSF page multiple components use this converter, then one for each component new object created.

== Validation

A central task of a web application is the validation of the data entered by the user. 
Various conditions often have to be checked: Was a value is entered, a text is long enough or a number is high enough. 
In the various aspects of validation are discussed in the next chapters:

* JSF Validation
* Displaying Validation errors
* Suspend validation
* Custom validation
* Bean Validation
* Case Study Blog Application - Validation

=== JSF Validation

Using validation tags added input component tags JSF can perform field validations. 

*JSF brings one support for validations with*
+
Validations can of course be done manually. 
Such an approach is However, JSF is not required. 
JSF already comes with a declarative validation functionality, intended for such tests. 
The data entered by the user are used Values already checked by JSF and only then (via the value binding) in the written managed bean when conforming to the specified validation rules are valid. Incorrect validations therefore mean that the values are not in the managed bean are written.

One of the simplest and at the same time most common checks is whether there is any value in
entered in a field. 
For JSF to check this, the required attribute for the corresponding tag can be set.

*Example 1:*

This could be for text fields that have the two properties lastname and firstname a represent managed bean users, look like this (on the implementation of the class for the managed bean is not received):

requiredfieldsValidation.xhtml
----
<h:inputText value="#{user.lastName}" required="true" />
<h:inputText value="#{user.firstName}" />
----

*Explanation*
+
In this case, JSF will only save the user's two entries in the corresponding form in the user managed bean when the last name has been entered was. 
If only the first name is entered by the user, JSF will neither store the first name nor the last name in the managed bean. 
To have to i.e. all user input must be valid so that JSF accepts the values.

Any JSF tag that accepts input from a user supports the required attribute (e.g. also h:inputTextarea). 
To check this function can an output in the setFirstName() method of the corresponding managed bean class to be added.

If only something is entered in the first name field and the OK button is clicked the value is not set (the setFirstName() method is not executed and thus the output does not appear). 
Only when an entry is made in the surname field both fields are set after pressing the button.

*More Validations*
+
In addition to this simple test, there is also the possibility of more extensive ones to carry out tests. 
So-called validators are used for this. 
validators are attached to an input component as a »child«. 
The validator will then check the input value of the user and save the value in the Managed Bean only allow the bean if it satisfies the relevant validation.

*Example 2:*
+
In this example, JSF will store the values in the managed bean only if the input is at least »three« characters long. 
The `f:validateLength` tag is used for this added.

lengthValidation.xhtml
----
<h:inputText value="#{user.firstName}">
    <f:validateLength minimum="3" />
</h:inputText>
----

*Explanation*
+
Here the `f:validateLength` tag is explicitly added to the `h:inputText` tag. 
The user must now enter at least three characters in the text field.

*Procedure for a value binding without validation*
+
It is easier to understand how this validation works within JSF if you know the normal procedure (without validation) that JSF uses for a value binding. 
This is shown in Fig.12.1-1.

image::

Fig.12.1-1: Procedure: value binding.

Step 1: The user enters some text in the box and hits the save-Button.
Step 2: The user's input is taken from the `h:inputText` component on the Server read from the request and stored in it.
Step 3: The value of the `h:inputText` component is stored in the associated Value Binding, i.e. the corresponding managed bean, is saved.

*Process at one value binding with validation*
+
If a validation is to be carried out using a validation tag, the validation tag is used between step 2 and step 3 to check the input.
Step 3 is only then carried out if the validation is successful. 
The graphic then looks like in Fig.12.1-2.

Fig.12.1-2: Procedure: value binding with validation.

There are several standard validation tags that come standard with JSF. 
A brief overview follows.

The `f:validateLength` tag validates the length of the input. 
It gets the user's input only accept if it is longer than the minimum (if a minimum is specified
becomes) and is not greater than the maximum (if a maximum is specified)
(Ref. Table. 12.1-1).

|====
|Attribute|Description
|minimum
|Minimum input length.
|maximum
|Maximum length of input.
|====
Table. 12.1-1: Attributes of the tag `f:validateLength`.

In this example, the last name entered must have a minimum of three and a maximum of eight characters long.
*Example 3*
+
lengthValidationMinMax.xhtml
----
<h:inputText value="#{user.lastName}">
    <f:validateLength minimum="3" maximum="8" />
</h:inputText>
----

The `f:validateLongRange` tag validates the size of the entered integer value. 
The numeric value must be greater than the minimum (if specified) and less than that maximum (if specified) (see Table. 12.1-2).

|====
|Attribute|Description
|minimum
|Minimum size of the value.
|maximum
|Maximum size of the value.
|====
Table. 12.1-2: Attributes of the tag `f:validateLongRange`.

In this example, the age entered must be between 18 and 120.

*Example 4*
+
numberrangeValidation.xhtml
----
<h:inputText value="#{user.age}">
    <f:validateLongRange minimum="18" maximum="120" />
</h:inputText>
----

The `f:validateDoubleRange` tag also validates the size of an entered numerical value. 
This time, however, it is a double value with decimal places. 
The numeric value must be greater than the minimum (if specified) and less than the maximum (if specified) (ref. Table. 12.1-3).

|====
|Attribute|Description
|minimum
|Minimum size of the value (also as an integer).
|maximum
|Maximum size of the value (also as an integer).
|====
Table. 12.1-2: Attributes of the tag `f:validateDoubleRange`.

*Example 5*
+
numberrangeValidation.xhtml

In this example, the weight is given as a number with decimal places in the range 10.00 and 200.00 expected.

----
<h:inputText value="#{user.weight}">
    <f:validateDoubleRange minimum="10.00" maximum="200.00" />
</h:inputText>
----

The `f:validateRegex` tag validates a value using regular expressions (ref. Table. 12.1-4).

|====
|Attribute|Description
|pattern
|Regular Expressions (searched pattern in a value)
|====
Table.12.1-4: Attributes of the tag `f:validateRegex`.

In the following example, the entered text must be four to ten characters long and contain both a number and a capital letter. 
A valid input value would be 1abC.

*Example 6*
+
regexValidation.xhtml
----
<h:inputText value="#{user.lastName}">
    <f:validateRegex pattern="((?=.*\d)(?=.*[a-z])
        (?=.*[A-Z]).{4,10})" />
</h:inputText>
----

These featured tags are the standard validation tags provided by JSF. 
Additional validation tags are offered by third-party providers (both commercial and non-commercial) that integrate with JSF.

=== Displaying Validation errors

Error messages can be output with the tags `h:message` and `h:messages`.

*Validation without error message*
+
Although JSF prevents the value from being written to the corresponding managed bean, however, the user does not know that there is an error. 
If a Navigation Rule is defined, it will not be executed. 
Here the user might guess that something is wrong. 
However, if the user enters the correct input on the same page and therefore no navigation rule is defined, it will be displayed on a Incorrect input may not notice any difference: the page becomes simple loaded again.

*JSF supports validations*
+
In any case, the user is informed that his input is not valid are, essential. 
However, since JSF cannot guess at which point on the page. 
To present error messages most appropriately, there are two tags, with which error messages can be output. 
So the developer can exactly determine where on the page these messages appear. 
The two tags are used in the explained below.

*h:messages*
+
The `h:messages` tag can be used to output all error messages that are on the page have occurred (ref. Table. 12.2-1).

|====
|Attribute|Description

|globalOnly
|Indicates whether all error messages are displayed or only error messages not caused by a component (more about this type of error message in the chapter »Own Validation«, p. 120).

|showDetail
|Indicates whether details about the error message should be displayed.

|showSummary
|Indicates whether a summary of the error message is displayed.
|====
Table. 12.2-1: Attributes of the `h:messages` tag.

For example, a summary is "validation error", the detailed message: "[ID] input required" (as "[ID]" is displayed a string identifying the component clearly identified).

There are also the following properties:

* errorClass/errorStyle
* fatalClass/fatalStyle
* infoClass/infoStyle
* warnClass/warnStyle

These attributes can be used to specify the respective classes / CSS styles that are used with
of the respective error level (error/fatal/info/warn). 
If you set the value border:1px solid red; to the errorStyle attribute, errors of the type error with a provided with a red frame. 
The following examples of the program demo validation errors should clarify the situation.

The input field for the last name is a mandatory field. 
Example 1 The OK button pressed without entering a last name, an error message is displayed.
*Example 1*
+
messageExample.xhtml
----
<h:messages/>
<h:form>
<h:inputText value="#{user.lastName}" required="true" />
<h:commandButton value="OK" />
</h:form>
----

*Explaination*
+
The error message can be slightly different depending on the JSF implementation used be. 
An error message is output here if the user does not input (Fig. 12.2-1). 
The information j_idt6 and j_idt7 refer to the component IDs in the component tree assigned by the JSF framework will. 
The value j_idt6 refers to the form (h:form) and the value j_idt7 refers to the input field within the form (h:inputText).

image::

Fig.12.2-1: Representation: Simple error message

*h:message*
+
The `h:message` tag can be used to output error messages that occur with a specific component have occurred. 
While with the `h:messages` tag, all error messages can be output here "in one" place on the page
placed meaningfully on the page for a particular component. 
As a general rule this should be near the component that caused the error. 
This Tag should preferably be used as it increases the usability of an application greatly improved. 
The attributes are almost identical to those of the `h:messages` tag. 
It the `globalOnly` attribute is missing, for this there is another attribute that the `h:messages`- tag does not have (ref. Table. 12.2-2).

|====
|Attribute|Description
|for
|Specifies which component to display errors for.
|====
Table.12.2-2: Attribute of the `h:message` tag.

*ID of the components*
+
In order to be able to specify the component in the for attribute for which error messages are to be generated, the components must be provided with an ID. 
The component can then be referenced via this ID.

Usage is shown in the example below:

Example 2:
+
messageForExample.html
----
<h:inputText id="firstName" value="#{user.firstName}"
required="true" />
<h:message for="firstName" />
<h:inputText id="lastName" value="#{user.lastName}"
required="true" />
<h:message for="lastName" />
<h:commandButton value="OK" />
----

*Explanation*
+
With each JSF tag, in addition to the component-specific properties, ties, an ID can also always be assigned. 
Here the first `h:inputText`-Tag is given the ID `firstname`, the second `h:inputText` tag is given the ID `lastname`. 
The IDs can be assigned arbitrarily. 
Once a tag has a unique ID, error messages are output for him with the `h:message` tag. 
This will the respective ID of the input component is specified in the for attribute of the `h:message` tag (Fig. 12.2-2). 
In this example, the error messages are always direct displayed above the respective component.

image::

Fig. 12.2-2: Representation: Two error messages.

*Customize error messages*
+
The quality of the message and the appearance can still be improved. 
Example- the wise is the id (e.g. j_idt5:lastname) represented by JSF for the user
rather confusing. 
The specification j_idt5 refers to the form for which no own ID was assigned. Therefore, an ID was assigned by the JSF framework.

Adjusting the error texts is fairly easy, but it requires understanding the internationalization concept understood by JSF. 
In addition to special property files with texts (also called message bundles) intended for one or more JSF pages are, there is also the possibility to define global files. 
these can then contain customized error messages, for example. 
Adjust demo validation errors in the program this is made clear.

*Adaptation in the faces-config.xml*
+
To configure JSF to pull such a file, the `faces-config.xml` needs to be extended as follows:
----
<application>
    <message-bundle>jsf.beans.errormessages</message-bundle>
</application>
----

*Property file with error messages*
+
The message-bundle tag contains the property file that contains the error messages that are printed instead of the default messages.

An example of a Property file overriding the message for mandatory fields left blank:

*Example 3*
+
errormessages.properties
----
javax.faces.component.UIInput.REQUIRED=This is a mandatory field, please fill out this field.
----

Instead of the error message given in example 2, the error message in the file defined error message. 
Again, it is possible for different Languages different files (with appropriate language abbreviation) use to define the error messages in different languages.

*Place Holder*
+
To output the component causing the error in the form of its ID, the wildcard {0} can be used. 
The form should also get an ID, otherwise the ID automatically assigned by the JSF framework is displayed in the error message becomes.

For example, the Property file looks like this:
*Example 4*
+
errormessages.properties
----
javax.faces.component.UIInput.REQUIRED={0} is a required field, please fill this field.
----

There are numerous other keys that overwrite with appropriate error messages can become. 
A brief listing is shown below, where the ..._detail message is the detail message. The first error message (javax.faces.component.UIInput.REQUIRED) the general error message would be e.g. Validation errors and the detailed message (javax.faces.component.UIInput.REQUIRED_detail) [ID] input required.

|====
|required
|javax.faces.component.UIInput.REQUIRED (REQUIRED_detail)

A required field was not filled out.

Placeholder: {0} (ID)

|f:validateLength
|javax.faces.validator.LengthValidator.MAXIMUM (MAXIMUM_detail)

The value is greater than the maximum.

Placeholder: {0} (maximum), {1} (id)

|javax.faces.validator.LengthValidator.MINIMUM (MINIMUM_detail)

The value is less than the minimum.

Placeholder: {0} (minimum), {1} (ID)
|f:validateDoubleRange

|javax.faces.validator.DoubleRangeValidator.MAXIMUM (MAXIMUM_detail)

The value is greater than the maximum.

Placeholder: {0} (maximum), {1} (ID)
|javax.faces.validator.DoubleRangeValidator.MINIMUM (MINIMUM_detail)

The value is less than the minimum.

Placeholder: {0} (minimum), {1} (ID)
|javax.faces.validator.DoubleRangeValidator.NOT_IN_RANGE (NOT_IN_RANGE_detail)

The value entered is not in the valid range.

Placeholder: {0} (from), {1} (to), {2} (ID)
|f:validateLongRange
|javax.faces.validator.LongRangeValidator.MAXIMUM (MAXIMUM_detail)

The value is greater than the maximum.

Placeholder: {0} (maximum), {1} (id)

javax.faces.validator.LongRangeValidator.MINIMUM (MINIMUM_detail)
|====

=== Suspend validation

Sometimes it may be necessary to validate a page at certain times disable actions. 
For example, if the "Cancel" button is pressed.

When the Cancel button is pressed, validations are usually undesired: The user wants to cancel the current action, the entered Values do not need to be adopted. 
Therefore, there should be no error message appear. 
But for JSF it is also the Cancel button an ordinary button followed by an action. Therefore, also at A validation can be performed when this button is triggered. shows the process (generalized) Fig. 12.3-1.

image::

Fig. 12.3-1: Validation when cancel is triggered.

Step 1: The user enters a text.
Step 2: The text is read from the request by the input component and stored internally.
Step 3: The internally stored text is validated.
Step 4: The text is included in the managed bean (if it was valid).
Step 5: The action of the button is performed.

*Suspend validation*
+
However, there is a way to suspend that. 
That's what you use for that Validation immediate attribute of the button. 
If this attribute is set, the button Action performed before validation (i.e. immediate) and entered Values are neither validated nor by the corresponding value binding transferred to the managed bean. 
Instead, the (via the method Binding) defined action of the button is executed and then accordingly navigates. 
The process is (generalized) as shown in Fig. 12.3-2.
image::
Fig. 12.3-2: Validation when triggering with immediate.

Step 4 and step 5 are shown separated by a line in Fig. 12.3-2 because these steps are no longer performed after the immediate action has been performed. 
The button action is already executed here in step 3.

The relationships are explained in the DemoValidationRelease program.

The example1.xhtml page illustrates the use of the immediate attribute.

Example 1

example1.xhtml
----
<h:message for="firstName" />
<h:inputText value="#{benutzer.eingabe1}"
required="true" id="firstName" />
<h:commandButton immediate="true" value="abbrechen" />
<h:commandButton value="speichern" />
----

*Explanation*
+
Here the user can enter a text (first name) and then save it to press. 
However, the save action is only executed if a text has also been entered. 
This is provided by the `h:inputText` component's required attribute forced. 
However, if the user presses cancel, the cancel-Action performed and no validation takes place. 
In this case he has to User does not enter any text in the text box.

If the first name field is left blank and then the save button pressed, an error message is output. 
When pressing the button no error message is output. 
Instead of triggering the store-button to reload the same page, it would also be possible to go to another page to branch. 
To keep the example simple, this has been omitted.

*More detailed consideration*
+
In addition to these rather superficial observations, something else happens in this example: When canceling, the entered value is not saved in the associated value binding (here #{user.input1}), regardless of whether it is valid or not is saved (as shown in Fig. 12.3-2). 
When saving, the Value, on the other hand, is stored in the value binding (as shown in Fig. 12.3-1).

*Immediate attribute for input components*
+
Besides being able to set the immediate attribute on the `h:commandButton` component, there is also the option to set the immediate attribute on the `h:inputText` component to put.

Setting the immediate attribute on the `h:inputText` component results in the validation before the validation of the other (non-immediate) components and also before executing an action of an immediate -`h:commandButton` component is carried out. 
Fig. 12.3-3 illustrates the process for a page on which there is both an `h:inputText` component that is immediate (here the type) and one that is not immediate (like firstname in the previous examples).

Fig. 12.3-3: Validation with and without immediate.

Step 3 and step 4 are only processed here for the component type, since this is immediate. 
Only step 2 is processed for the first name component. 
Step 5 and 6 would not be processed at all if you clicked on the Cancel button (therefore shown separated by a line).

*Example 2*

The source code example2.xhtml looks like this:

example2.xhtml
----
<h:message for="typ" />
<h:inputText value="#{benutzer.eingabe1}" required="true"
immediate="true" id="typ" />
<h:message for="firstName" />
<h:inputText value="#{benutzer.eingabe2}" required="true"
id="firstName" />
<h:commandButton immediate="true" value="abbrechen" />
<h:commandButton value="speichern" />
----

*Explanation*
+
In this example, there are several ways the user can behave could. 
Each of the possibilities, including the result, is explained below listed (see Tab. 12.3-1).

|Input
|action
|Description

Tab. 12.3-1: Input options.

=== Custom validation

You can also implement your own imperative validations with JSF, which are also carried out before values in the respective value binding of the components are written. 
A distinction is made here between component-dependent and component-independent validations.

*Difference*
+
In a component-dependent validation, the entered value becomes a specific component validated (e.g. an email address). 
error messages refer to this one component.

In a component-independent validation, not only a syntactical one takes place check of a single value instead of a semantic (e.g. authentication username and password combination).

*Component dependent validation*
+
In this case, a separate validation method is implemented. 
To own one Performing validation requires a special method binding on the component
set that is to carry out this check. 
This is how method and component become linked together.

The program DemoValidationOwnSyntactically clarifies the facts.

In a JSF page, validateEmail.xhtml, it looks like this:

Example 1a.

validateEmail.xhtml
----
<h:messages />
<h:inputText value="#{user.email}"
    validator="#{user.validateEmail}">
</h:inputText>
----

This assumes that the managed bean user actually has a method `validateEmail()` exists.

*Method binding for validation*
+
It is not necessary to include the validation method (as shown here) in the Implement managed bean class that also contains the value to be checked. 
It would also be possible to create another class that, for example, only Validation methods and the method binding refer to this class to let. 
To do this, this class must implement the `javax.faces.validator.Validator` interface.
In the JSF page, the tag is `f:validator` specifying the validator class over the Attribute `validatorId` required. 
However, it is often advisable to program parts that are responsible for rendering a specific page, in a managed bean class to summarize.

*conventions for validation methods*
+
A method that accepts validation must have certain accept invocation parameters and have a specific return value so that JSF can use it for validation.

An example of such a method (here: validateEmail()) is listed below:

Example 1b: user.java
----
public void validateEmail(FacesContext context, UIComponent component, Object value) {
    String input = (String) value;
    if (input.indexOf('@')==-1) {
        ((UIInput)component).setValid(false);
        FacesMessage message = new FacesMessage("Invalid e-mail address");
        context.addMessage(component.getClientId(context), message);
    }
}
----

The many call parameters of the validation method may seem confusing, that however, the underlying concept is quite easy to understand (ref. Table-12.4-1).

|====
|Parameter
|Function

|FacesContext context
|This is an object that contains all the information about the keeps current JSF state. 
This object enables direct communication with the framework.

|UIComponent component
|The component that contains the value to validate.

|Object value
|The value to validate, entered by the user.
|====
Table. 12.4-1: Call parameters of the validation method.

These call parameters must be present with every validation method.

The core of the method is checking the entered value (in this case it is checked if
whether the input contains an @ sign). 
The value to be checked is given as a parameter passed value.

*Converter*
+
This does not necessarily have to be a string, as assumed here. 
When adding any object can be expected from a converter to a component will. 
If no converter is used and the property of the value binding is on String (as in this example), a string can also be expected here.

If the check is successful, there are no further steps in the method necessary.

*How to proceed if not valid values*
+
If the value is not valid, two steps must be performed. 
Of the the fourth step is to tell the affected component itself that the value it contains is invalid. 
This is done via the setValid() method.

The user must then also be informed with a message. 
For this purpose, a Faces Message is created with an error message and using the addMessage() method communicated to the JSF framework.

In this case, the addMessage() method is called with two parameters. the
both parameters are explained in Table. 12.4-2.

|====
|Parameter
|Function

|String
|FacesMessage
|====
Table 12.4-2: Parameters of the addMessage() method

The first parameter is a string, that is, the component ID must be passed here as a string. 
To find out the ID of a component, the getClientId() method can be used. 
This returns the ID of the component as String back.

It is important to include the component ID when communicating the error message with addMessage() to use so later with the h:message tag the error messages can be output that belong to a specific component (using of the for attribute).

*Component independent validation*
+
The mechanisms presented so far allow a syntactic single field check. 
However, something more general must often be validated. 
It would be conceivable that checked whether a person's first and last name already exist in the database. 
Here not only one field is checked, but two. 
The exam is in this case not syntactic, but semantic (content-related) nature.

*Method Binding*
+
In order to also be able to take such cases into account, JSF offers the possibility of checking data from several fields at the same time after they have been transferred to the corresponding Managed beans were written. 
So this type of validation does not prevent adoption a value into the managed bean (this has already happened at this point), but is used for subsequent validation and display of corresponding error messages. 
Usually this will happen in the method due to the User action (e.g. pressing a button) or the associated method Bindings is called.

*Example 2*
+
For example, the user may press a "Save" button. 
JSF then first reads the data entered by the user (here, for example, first name and last name) in the managed bean. 
Then the with method linked to the button (via a method binding) storeUser() executed. Before the method finally saves the record, it will conduct an exam. 
Here it is an exam that ensures the pros and Surname does not yet exist in the database (userExists()).

The DemoValidationOwnSemantic program explains the facts.

----
@Inject
private FacesContext context;
public String saveUser() {
    if (userExists(user.getFirstName(), user.getLastName())) {
        FacesMessage message = new FacesMessage();
        message.setSeverity(FacesMessage.SEVERITY_ERROR);
        message.setSummary("Combination of first and last name already exists");
        message.setDetail("A combination of first and last name may only occur once");
        context.addMessage(null,message);
        return "";
    }
    return "ok";
}
----

*Explanation*
+
This example uses the `userExists()` method to determine whether the specified combination of first and last name is already in the database exists. 
In this case, a Faces Message is created with the error message and the error details are set. 
This Faces Message is then sent to the Faces Passing the context (addMessage()) without specifying an ID (in contrast to the addMessage() call for an error message associated with a component becomes). 
The error message is therefore not assigned to any component. 
It is a general error message. 
Finally, JSF is returned using return ""; instructed to reload the current page. 
Important for the return value is only that no navigation rule exists for it. 
It might as well be there return "xyz".

NOTE:
The severity of the message can be specified using the `setSeverity()` method (SEVERITY_INFO, SEVERITY_WARN, SEVERITY_ERROR or SEVERITY_FATAL). the inserted messages may or may not be displayed depending on the setting. 
These setting options are not discussed in detail in this book.
=== Bean Validation

Using bean validation is another declarative way to do this Validating input to managed beans. 
The validation information will be done directly in the managed bean classes.

The specification of the Bean Validation 2.0 was released and made possible in the JSR 380 the use of validation rules directly in the managed bean class. 
As in the validation tags, this is a declarative configuration. 
Next to the specification of the validation rules in the managed bean class are no further tags necessary.

Analogous to the definition of validation rules using validation tags, the passed values are not written to the managed bean until validation is successful was.

*Use*
+
When using bean validation, the necessary restrictions (Constraints) via annotations on the respective properties of the managed bean - class are defined. 
Table. 12.5-1 shows a section of the possible annotations.

|====
|Annotation
|Description

|Min
|Max
|NotBlank
|NotEmpty
|NotNull
|Size
|====

Table. 12.5-1: Bean validation annotations.

The following examples of the program `DemoBeanValidation` clarify the usage from `BeanValidation`.

Two text boxes are inserted on a JSF page with no validation information

Example 1:
user.xhtml
----
<h:messages />
<h:form>
<h:outputText value="firstName" />
<h:inputText value="#{user.firstName}" /><br />
<h:outputText value="lastName" />
<h:inputText value="#{user.lastName}" /><br />
<h:commandButton value="ok" />
</h:form>
----

In the underlying managed bean class users are the constraints determined by annotations.

User.java
----
@Named
@RequestScoped
public class User implements Serializable {
    private String lastName;
    private String firstName;

    @NotNull(message = "Last name is a required field")
    @NotBlank(message = "Last name cannot be empty")
    @Pattern(regexp = "[a-z-A-Z]*", message = "Invalid characters in last name")
    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    @NotNull(message = "First name is a required field")
    @NotBlank(message = "First name cannot be empty")
    @Pattern(regexp = "[a-z-A-Z]*", message = "Invalid characters in first name")
    public String getFirstName() {
        return firstName;
    }
    
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
}
----

The browser display after sending empty input fields shows the Fig. 12.5-1.

Both properties lastName and firstName must not be "null" (@NotNull). 
The inputs must not consist exclusively of spaces (@NotBlank) and must match the pattern "lowercase and uppercase" (@Pattern).

Classic JSF validation aims at validating individual components. 
However, in some areas it makes sense to validate the entire managed bean, for example
a simultaneous check of several fields. 
This mechanism is about the tag that allows `f:validateWholeBean`. 
Simultaneous checks of several fields can also be implemented with your own validation components, but the transferred values into the managed bean when using `f:validateWholeBean` written if the validation was successful. 
Table 12.5-2 shows the attributes this tag.

image::..

Fig. 12.5-1: Class validation.

|====
|Attribute
|Description

|disabled
|id
|validationGroups
|value
|====

Table 12.5-2: Attributes of f:validateWholeBean.

This functionality must be activated via an entry in the configuration file `web.xml`
will.

web.xml
----
<context-param>
<param-name>javax.faces.validator.ENABLE_VALIDATE_WHOLE_BEAN</param-name>
<param-value>true</param-value>
</context-param>
----

Validation information can be refined by using the `f:validateBean` tag will. 
For example, groupings can be specified or implicit validation be deactivated. 
Table. 12.5-3 shows the attributes of this tag.

|====
|Attribute
|Description

|disabled
|validationGroups
|====
Table. 12.5-3: Attributes of f:validateBean.

*Example 2*

A password including password repetition should be entered on a JSF page. 
An entered password is only valid if both entries are identical.

A ValidPasswordGroup tagging interface is set as a validation group.

ValidPasswordGroup.java
----
public interface ValidPasswortGroup { }
----

The JSF page is shown below.
password.xhtml
----
<h:messages />
<h:form>
<h:outputText value="Password" />
<h:inputText value="#{password.password}">
<f:validateBean validationGroups="jsf.beans.ValidPasswortGroup" />
</h:inputText><br />
<h:outputText value="Password (repeat)" />
<h:inputText value="#{password.repeatPassword}">
<f:validateBean validationGroups="jsf.beans.ValidPasswortGroup" />
</h:inputText><br />
<f:validateWholeBean value="#{password}" 
    validationGroups="jsf.beans.ValidPasswortGroup" />
<h:commandButton value="ok" />
</h:form>
----

The validation group is set using the `f:validateBean` tag `jsf.beans.ValidPasswordGroup` for both input fields. 
If one If validation of the individual fields is to be activated, the added to the `javax.validation.groups.Default` validation group. 
The tag `f:validateWholeBean` sets the class validation. 
The validation groups must for the input fields configured with `f:validateBean `and for the tag `f:validateWholeBean` must be identical.

The managed bean class must be annotated with a specially defined annotation will. 
The annotation `ValidPassword` is created for this.

ValidPassword.java
----
@Target(TYPE)
@Retention(RUNTIME)
@Constraint(validatedBy = Password.class)
public @interface ValidPassword {
    String message() default "Invalid passwords";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
----

The annotation should be set at class level (@Target(TYPE)) and to be available at runtime (@Retention(RUNTIME)). 
The actual implementation class for performing the validation, specifying the annotation @Constraint(validatedBy = password.class). 
The message annotation attribute specifies the Returns default text in case of a negative validation check. 
The validation groups are configured via the annotation attribute groups. 
The payload can be used to pass your own user data for validation.

The `ValidPassword` managed bean class does the actual validation.

ValidPassword.java
----
@ValidPassword(groups = jsf.beans.ValidPasswortGroup.class)
public class Password implements Serializable, 
    ConstraintValidator<ValidPassword, Password> {
        private String password;
        private String passwordWdh;
        
        // Getter und Setter
        ...
        
        @Override
        public void initialize(ValidPassword constraintAnnotation) { }

        @Override
        public boolean isValid(Password other, ConstraintValidatorContext context) {
            return other.getPassword().equals(other.getPasswordWdh());
        }
}
----

The validation takes place in the `isValid` method. 
Only if both passwords match, the validation is successful.

The browser display after sending unequal passwords shows the Fig. 12.5-2.

image::..

Fig. 12.5-2: Class validation

=== Case Study Blog Application - Validation

Validations are also necessary in the case study. 
It becomes the input mask appropriately validated for a blog entry.

*GUI*
+
The properties title and text of a blog entry should be validated. 
A title should come with at least three and a maximum of 50 characters. 
The detailed text should contain at least three characters.

*Implementation case study validation*
+
Below are the changes compared to the Case Study input mask program shown.

Only the `addEntry.xhtml` display page needs to be updated.

The `addEntry.xhtml` file looks like this:

addEntry.xhtml
----
<h:body>
<h:form>
<h:outputText value="Title" />
<h:inputText value="#{addEntryBean.blogEntry.title}" id="title">
    <f:validateLength minimum="3" maximum="50" />
</h:inputText>
<h:message for="title" />
<h:outputText value="Text" />
<h:inputTextarea value="#{addEntryBean.blogEntry.text}" rows="5" cols="80" id="text">
    <f:validateLength minimum="3" />
</h:inputTextarea>
<h:message for="text" />
</h:form>
</h:body>
----

The input field for title must have a minimum of three (minimum="3") and a maximum of 50 characters (maximum="50"). 
The input field for text must contain at least three characters (minimum="3") long. 
In addition, an `h:message` tag was added after both fields, that outputs any error messages. 
To allow the notifications are displayed for the respective input components, both components were additionally extended by an ID (title and text).

*Managed Bean-objects*
+
The Managed Bean objects involved are no different from the CaseStudyInputForm program.

== Listener

=== Action Listener

=== Value Change Listener

== Advanced Components

=== Selection lists

==== JSF picklists

==== Case Study Blog Application - Picklists

=== file upload

==== JSF file upload

==== Case Study Blog Application - File Upload

=== Advanced Components - Tables

==== JSF tables

==== Tables - the Master Detail Pattern

==== Case study blog application - table

== component tree

== The JSF lifecycle

== Around the JSF application

== Configuration files

=== web.xml

=== faces-config.xml

== Management of resources

=== JSF resources

=== Case Study Blog Application - Resources

== Asynchronous JavaScript and XML

== HTML5 Friendly Markup

== WebSocket

== JSON Processing

JSON ( JavaScript Object Notation) is a lightweight data exchange format. 
The data is read in a human-readable format and written. 
In JSF applications, the Java API can be used for processing JSON.

JSON only defines two data structures: objects and arrays. 
There is an object a collection of "name/value pairs" and an array is a list of values. 
In JSON, six different data types can be used: string, number, object, array, bool [true, false] or null.

*Object*
+
An object is defined in curly brackets {...}. 
The existing name/value pairs are separated by a »comma«. 
The name is specified as a string and the value is specified as value. 
The separation of name and value is realized by means of a »colon«. 
A value can be one of the six available acceptable data types.

An example of name/value pairs looks like this:

.Example-1[JSON]
----
{
"firstname":"nagaraju",
"lastname":"gumpini",
"age":30
}
----

*Explanation*
+
In this case, there are three name/value pairs: firstname, lastname, and age. 
The age is stored as a number and is therefore not in quotes.

*Array*
+
An array is defined in square brackets [...]. 
The value values ​​are given using an array separated by "commas".

An example of an array looks like this:
.Example-1[JSON]
----
{
"name":"nagaraju",
"telephone":
    [
        { "type":"private", "number":"8886934448" },
        { "type":"business", "nummer":"8886914448" }
    ]
}
----

*Explanation*
+
The object consists of the name/value pairs name and phone, where phone has an array is defined as the value. 
The array consists in turn of the name/value pair type and number.

See JSR 374 for more information [JCP17a].

*Server*
+
The JsonObject interface and the Json class relevant to the creation are shown below.

* javax.json.JsonObject:
+
Represents a JSON object composed of an unordered collection of name/value pairs.
* javax.json.Json:
+
Factory class for creating JSON objects.

*Client*
+
Client-side A JavaScript API is used on the client side, which has the methods JSON.parse() and JSON.stringify() and is built into most web browsers.
* JSON.parse(text [, reviver]):
+
This method converts a text value text into a JSON object. 
The value reviver is optional and transforms the results.
* JSON.stringify(value [, replacer] [, space])
+
This method converts a JavaScript value to a JSON object.

The example JSON1 implements the »chat room« example from the chapter »Web Socket«, p. 201, passing a JSON object. 
The class ChatroomBean contains Getter and setter for a temporary property to pass the input values ​​and a property of type JsonObject.
.Example-3[java]
----
ChatraumBean.java

----

== Reuse

== Faces Flows

== Extend JSF core

== Outlook

== Appendix A Eclipse
