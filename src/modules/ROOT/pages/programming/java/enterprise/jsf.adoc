== Outline

Technique JSF (JavaServer Faces) is a server-side framework and is used to create web applications. 
JSF attempts the complexities of web application development to encapsulate and hides a large part of the problems and techniques that a web developer has to deal with. 
That's what most people have to do Project team developers only have a rudimentary knowledge of web applications because they mainly develop in their usual programming language can and seldom need to realize that they develop are a web application. 
Even JSF cannot fully develop the developer before contact with web technologies shield.

*Target*
+
After reading this book you will be able to develop simple JSF applications. 
Since the internal processes and concepts of the JSF framework are also examined, you should also extend JSF appropriately and can solve problems encountered during development with JSF. 
Already after the first chapters you will at least be able to realize a simple JSF application and classify JSF as a technique to be able to after the last chapter you will also be able to independently implement JSF applications.

*Method*
+
In addition, reference is repeatedly made to practical exercises as well as examples and problems from practice are shown, which you can use in everyday work with JSF will probably encounter. 
The task of the book is to prepare you for practice, without neglecting the theory. 
After the first practical examples explains the more theoretical basics of JSF. 
However, this is very lively on the previously discussed examples, so you will not have any problems to follow the explanations. 
Please note that the examples shown have been shortened at appropriate points in order to clarify only the essential aspects.

*What of you is expected*
+
So that's what the book offers you. 
But now to what the book of awaits you:
* Working through the practical exercises
* Java Knowledge (e.g. [Balz13], [Balz14])
* Basic knowledge of developing web applications in Java (e.g. [KrBa11], [Wißm09]):
** You know how to use your preferred development environment Web application project created.

[Balz13]
Balzert, Helmut; Java: Der Einstieg in die Programmierung - Strukturiert & prozedural
programmieren, 4. Auflage, Dortmund, W3L-Verlag, 2013.
[Balz14]
Balzert, Helmut; Java: Objektorientiert programmieren - Vom objektorientierten
Analysemodell bis zum objektorientierten Programm, 3. Auflage, Dortmund,
W3L-Verlag, 2014.
[KrBa11]
Krüger, Sandra; Balzert, Helmut; HTML5, XHTML & CSS - Websites systematisch
und barrierefrei entwickeln, 2. Auflage, W3L-Verlag, 2011.
[Wißm09]
Wißmann, Dieter; JavaServer Pages – Dynamische Websites mit JSP erstellen,
W3L-Verlag, 2009.

== The Quick Start

A minimal JSF page consists of an XHTML and two configuration files (faces-config.xml and web.xml). 
The XHTML elements are rendered as HTML5.

*Previous Knowledge*
+
The quick start is intended for readers who do not yet have any previous knowledge of JSF or XHTML (Extensible HyperText Markup Language). 
XHTML knowledge is necessary to develop JSF applications. 
This is because Facelets are defined as a standard VDL (View Declaration Language) in JSF applications. 
A more detailed description about Facelets will be given throughout the book. 
When using facelets usually XHTML is used. 
This book uses JSF version 2.3.

*JSF-Version*
+
A complete listing of all available classes, some of which are used in this book are given in [Orac18].

*Motivating Example*

Hello World

To get a first insight into the syntax of JSF applications, a motivating example a "Hello World" example is shown here. 
There will be a total of two configuration files `faces-config.xml` and `web.xml` are required. 
Also, a Java class `JSFActivationBean` and a JSF page declaration `index.xhtml` created. 
The files will be described below.

.faces-config.xml
----
<?xml version='1.0' encoding=’UTF-8’?>
<faces-config version="2.3"
    xmlns="http://xmlns.jcp.org/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee 
        http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_3.xsd">
</faces-config>
----

To "enable" JSF, create a configuration file `faces-config.xml` in the `WEB-INF` directory (alternatively: create a specially annotated Class). 
The specification <?xml version="1.0" encoding="UTF-8"?> designates the XML declaration
(Extensible Markup Language). 
It is an award with which each XML file should begin. 
Among other things, it describes the one used XML version and the character set used. 
By specifying version="2.3" sets the JSF version. 
The other parameters specify the namespace which defines the available elements of a JSF page declaration.

.JSF Activation Bean
----
@FacesConfig(version = FacesConfig.Version.JSF_2_3)
@ApplicationScoped
public class JSFActivationBean {
}
----

"Activating" JSF requires the creation of a specially annotated class (alternative: create a configuration file `faces-config.xml`) JSF 2.3 becomes in a "JSF 2.2 compatibility mode". 
This concerns, for example the management of objects in the application server using CDI (Contexts and dependency injection). 
For using JSF 2.3 is any Class with @FacesConfig annotation with version parameter FacesConfig.Version.JSF_2_3 in the ApplicationScoped scope. 
The name of this Any class can be chosen.

*NOTICE*
+
Throughout the book, both annotations and configurations in the the `faces-config.xml` file is used appropriately.

.web.xml
----
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://xmlns.jcp.org/xml/ns/javaee"
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
        http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
    version="4.0">
    <context-param>
        <param-name>javax.faces.PROJECT_STAGE</param-name>
        <param-value>Development</param-value>
    </context-param>
    <welcome-file-list>
        <welcome-file>index.xhtml</welcome-file>
    </welcome-file-list>
</web-app>
----

The `web.xml` file is saved in the `WEB-INF` directory. 
Through the context parameter `javax.faces.PROJECT_STAGE` with value `Development` become automatic Messages are output in the view using the `h:messages` JSF component. 
The start page should be `index.xhtml`. 
This is done in the <welcome-file-list>...</welcome-filelist>.

*NOTICE*
----
The FacesServlet class can automatically be used as the processing class for the requests
be set. 
The prerequisite for this is the existence of a configuration file `faces-config.xml` or at least one class with a JSF annotation (e.g. @FacesConfig). 
This means that the <servlet>...</servlet> area can be omitted. 
Likewise the mapping is optional. 
If the area <servlet-mapping>...</servlet-mapping> is not set, all `*.xhtml` files are automatically mapped to the FacesServlet.
----

.index.xhtml
----
<!DOCTYPE html>
<html lang="en"
    xmlns="http://www.w3.org/1999/xhtml"
    xmlns:h="http://xmlns.jcp.org/jsf/html">
<h:head>
    <title>Hello World</title>
</h:head>
<h:body>
    <h:outputText value="Hello World" />
</h:body>
</html>
----

In the DOCTYPE area there is no reference to an HTML DTD (Document Type Definition) given, therefore it is an HTML5 page. 
HTML5 is not based based on SGML (Standard Generalized Markup Language), so specifying a
Document type definition not necessary. 
The output text Hello World is replaced by the set JSF component h:outputText.

*NOTICE*
----
By using facelets as VDL, the DOCTYPE specification is not crucial: HTML5 source code is always rendered. 
It would also be possible to use the following document type definition from the XHTML standard:

<!DOCTYPE html PUBLIC
    "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
----

Here it is specified in the DOCTYPE area that the publicly available HTML DTD (Document Type Definition) is referred to. 
The DTD defines the document structure. 
It is further specified that XHTML in version 1.0 and in the variant Transitional and that the used elements and attribute names have been defined in the EN language. 
In the html area, the language of the XHTML page and the tag libraries used specified.

*Result*
Calling up the page is shown in Fig.2.0-1.

image::
Fig.2.0-1: Example hello world.

The existing source text of the call looks like this:
----
<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head id="j_idt2">
    <title>Hallo Welt</title>
</head>
<body>Hallo Welt</body>
</html>
----

The small example shows that the JSF page declaration with XHTML and JSF tags is defined, but the generated result is presented as HTML5 becomes.

NOTICE
----
In the example, the `index.xhtml` file is named "JSF Page Declaration". 
XHTML and JSF tags are used. 
As the book progresses, simply the term »JSF page« is used.
----

== Web Development Basics

The basics of web development with Java are described in various JSRs (Java Specification
request). 
These include, for example, »Java 8 SE« (JSR 337), »Expression Language 3.0« (JSR 341) and »JavaServer Faces 2.3« (JSR 372). 
A JSR goes through different stages and may have reached a certain level. 
Web applications can have different architectures. 
The content will be in described in the following chapters:

*Web Application Architecture*

Web applications can be structured and divided in different ways. 
The underlying architecture defines how the individual components interact with a web application.

Just like common Java applications, there are also different ones for web applications
architectural pattern. 
At this point, the architectural patterns Model 1 and Model 2 treated. 
For Model 1 web applications, the client accesses the directly corresponding views. 
In the case of Model 2 web applications, access is provided by the clients not directly on the views, but always on the controller of the web application. 
Model 2 patterns are also called MVC patterns (Model View Controller patterns).

=== Model 1

=== Model 2

With Model 1 web applications, the client accesses a view directly. 
For model 2 - Applications, on the other hand, have a central location that is called up instead and forwards the call. 
This process is illustrated in Fig. 3.2-3.

The user communicates with the controller, so he sends his requests directly there. 
The controller creates and fills the model. 
Then he delegates it Output generation to the view that accesses Model objects generated by the controller.

== Java web development with Servlets and JSP pages

JSF application development is different from development ordinary Java web applications with servlets and JSP pages.

The rough structure of a Java web application with Model 2 architecture is explained in the introduction Fig.4.0-1 briefly explained.

image::

Fig.4.0-1: Structure of a web application.

With Model 1 architectures, direct access to the JSP pages would also be possible. 
Basically, a web container is required first (e.g. Tomcat or Payara), where the web application can be published. 
The web application in turn consists of different elements. 
The most important ones are listed in Fig. 4.0-1: A configuration file (web.xml), one or more servlets, and one or multiple JSP pages. 
JSP pages and servlets make it easy to build a web application. 
The client (i.e. the browser) accesses the servlet and the servlet in turn accesses the JSP pages.

*Expiry of a user requirement (Request)*
This means, of course, that all technical aspects of the web application are also here
to be implemented. 
This means that first the user request (Request) must be evaluated to extract any transfer parameters, when programming a servlet. 
Then the actual business logic executed and then the HTML document is generated and returned to the client. 
The process is illustrated in Fig.4.0-2.

== JavaServer Faces

Developing with JSF is a bit different than developing with Servlets or JSP pages. 
JSF is a framework based on the Model 2 - Concept.

=== Architecture of JSF

JSF is a Model 2 framework - this is easy to do on the central Front-Controller-Servlet, called JSF Faces Servlet.

JSF works like a Model 2 application (see »Web Application Architecture«, p. 10). All input and output takes place via Faces Servlet.

=== Configuration of web.xml

In the `web.xml` configuration file, Faces Servlet is specified as the one to be used Servlet not mandatory. 
The FacesServlet class can automatically be used as the working class can be set for the requests, provided the configuration file `facesconfig.xml` or at least one class with a JSF annotation (e.g. @FacesConfig) is available. 
This means that the <servlet>...</servlet> area can be omitted. 
Also optional is the characteristic of the mapping. 
If the area <servlet-mapping>...</servletmapping> is not set, all `*.xhtml` files are automatically sent to the FacesServlet Posted.

=== Contexts

There are different areas of validity (also: scopes) that determine how long an object has existed and from where it can be accessed.

Within a web application, objects can be created and then saved. 
However, the question arises as to where exactly these objects are stored.

*Motivation*
+
In an ordinary Java application, an object is stored in a property of another object or in a static property. 
In a web application However, an object is used by several users. 
So it must be determined at which point the objects are made available and for how long
these should remain available. 
Exactly this definition is called the scope.

*Object storage options*
+
A username e.g. B. is clearly user-related. 
But also information like a search query, a search result or a data record to be processed are user-related information that is only available to a specific user.

== Case study blog application overview

The following case study is used to illustrate the respective topics of the following chapter to deepen practically. 
This is a blog Application. 
First, the required classes for the »Business Logic« and the basic configuration files are created.

*What is a blog?*
+
A blog is a kind of diary. 
Any text entries can be created, each with a title, date and a category. 
Then they can displayed one below the other, creating a kind of diary.

*Functionality*
+
In order not to make the application too complicated, the »business logic« (here only persistence logic exists instead of business logic) for this sample application (case study overview) already implemented and is therefore not explained in detail.
The classes provided offer the possibility of text entries with a title, a text, a category and a date in a definable directory save. 
Alternatively, the current user's home directory used for storage. 
Multi-user use is not intended.

Fig.6.0-1 shows what the finished software could look like.

image::

Fig.6.0-1: Case study: list of blog entries.

*Create blog entry*
+
The central use case of the application is to create a blog entry. 
The user should be able to enter the information for title, date, category and to capture text. 
These details are then available as a blog entry on the provided classes are saved (Fig. 6.0-2).

*Classes*
+
The classes that enable the entries to be saved and loaded are already made available and therefore do not have to be programmed by yourself. 
In this chapter introduces the classes that are used for this and the next use cases are needed. 
The classes are shown in Fig. 6.0-3 as a UML diagram shown.

The central BlogManager class provides persistence and the BlogEntry class represents an entry in the blog.

image::

Fig.6.0-2: Case study: Blog entry process - input.

image::

Fig.6.0-3: API of the case study in UML notation.

The properties of the BlogEntry class are listed in Table.6.0-1.

|====
|Property
|Description

|id
|A unique number. 
This is set by the BlogManager - the first time save - Assigned and does not need to be set explicitly.

|title
|The title of the blog entry.

|text
|The content of the blog entry.

|category
|The category of the blog post.

|date
|A date to which the blog entry refers.
|====
Table. 6.0-1: BlogEntry properties.

The BlogManager class provides the following methods:

*Methods of Blog Manager*
+
public void saveEntry(BlogEntry entry):
Saves a new entry.
public void deleteEntry(BlogEntry entry):
Deletes an existing entry.
public List<BlogEntry> getAllEntries():
Returns all saved entries.
private String getFilename():
Returns the path to the persistence file. 
Is a path in the web.xml by the user defined, this is used. 
Otherwise, the home directory of the current User used for storage.
private void saveDb(List<BlogEntry> list):
Persist the existing blog entries.
private void initDb():
Initializing the database.

*Own storage path*
+
By default, the path `c:\blog.db` is used to store blog entries. 
A user-defined storage path can be specified in the `web.xml` configuration file.

web.xml
----
<context-param>
    <param-name>blogdbpath</param-name>
    <param-value>c:\blog.db</param-value>
</context-param>
----

An object of class BlogManager is implemented as a managed bean in scope of a Session created:

BlogManager.java
----
@Named
@SessionScoped
public class BlogManager implements Serializable {
    ...
}
----

*Overview*
+
Fig.6.0-4 shows an overview of the available programs.

image::

Fig.6.0-4: Case study: Overview of the different programs.

Based on the program case study overview, the programs case study input mask, Case study file upload and case study tables implemented. 
The program case study input mask serves as the basis for the programs case study templating, case study internationalization, Case study navigation, case study converter, case study validation, case study Shortlists and case study resources. 
The differences are in the description explained in the respective case study. 
In the Total Case Study program, all content is summarized in one application.

== Basic JSF components

=== Box: Component Hierarchy

=== h:outputText

=== h:inputText, h:inputSecret, h:inputTextarea

=== h:commandButton, h:commandLink

=== The components in interaction

=== Case study blog application - input mask

== Templating

=== JSF-Templating

=== Case Study Blog Application - Templating

== Internationalization

=== JSF internationalization

=== Case Study Blog Application - internationalization

== Navigation

Web applications usually do not only consist of one page. 
The following chapters explain the possibilities for realizing navigation in the context of JSF:

=== JSF-Navigation

JSF offers the possibility to choose between navigate multiple pages.

It is often necessary to implement an application with several pages. 
In the most cases, a realization with only one side should not be an option at all, for example when entering data records. 
A distinction is made between 'user-defined' and 'implicit' navigation.

*Custom Navigation*
+
Normally, navigation rules (also: navigation rules) are defined. 
This determine under which conditions from which side to which other side is referenced. 
For example, from `index.xhtml` page to `saveOK.xhtml` page. 
the conditions are described by so-called outcomes in the `faces-config.xml` (Program DemoNavigation).

Example 1a.
A navigation rule is then defined in the faces-config.xml file.
faces-config.xml
----
<navigation-rule>
    <from-view-id>/index.xhtml</from-view-id>
    <navigation-case>
        <from-outcome>ok</from-outcome>
        <to-view-id>/speichernOK.xhtml</to-view-id>
    </navigation-case>
</navigation-rule>
----

*Explanation*
+
This navigation rule determines that from the page `index.xhtml` to the page `save-
OK.xhtml` is branched. 
But only with the outcome ok.

*What is a outcome?*
+
An outcome is the result (i.e. the return value) of a method initiated by JSF method call. 
As already shown, in JSF, buttons and links are created using Method binding associated with an action.

Example 1b
The following example is conceivable:

JSF page:
<h:commandButton value="save(ok)" action="#{exampleBean.actionSaveOK}" />

Method:
public String actionSaveOK() {
    return "ok";
}

*Explanation*
+
In contrast to the method bindings considered so far, this method returns a string and does not return void. 
With this return value one also speaks of the outcome of the method. 
This value will used to determine the appropriate navigation rule. 
Here would be the outcome always ok and the current page is index.xhtml. 
Therefore, JSF will save to the pageOK.xhtml branch. 
The method would return an unknown value (for example nok), then JSF would appear on the current page (ie index.xhtml) stay.

*outcomes are variable*
+
Of course, it is not only possible to always return the same value, but different values could be returned via an if query.

It would be conceivable that the method checks something and depending on it ok or nok
returns. 
Depending on the outcome of the method and how the navigation rules are defined, JSF then links to one side or the other.

Example 1c
An example that saves from the `index.xhtml` page to OK if the outcome is `ok.xhtml` and in the case of an outcome of `nok` refers to saving `NOK.xhtml` the following:

----
<navigation-rule>
    <from-view-id>/index.xhtml</from-view-id>
    <navigation-case>
        <from-outcome>ok</from-outcome>
        <to-view-id>/speichernOK.xhtml</to-view-id>
    </navigation-case>
    <navigation-case>
        <from-outcome>nok</from-outcome>
        <to-view-id>/speichernNOK.xhtml</to-view-id>
    </navigation-case>
</navigation-rule>
----

*Explanation*
+
Two navigation cases are defined here. 
JSF will consider the case whose `from-outcome` attribute matches the outcome returned by the method. 
In this case, the first navigation case (saveOK.xhtml), if the outcome is ok or the second navigation case (saveNOK.xhtml) if the outcome is nok. 
If no navigation case applies (e.g. in the case of an outcome test), JSF will remain on the current page (i.e. index.xhtml here).

*Peculiarities of JSF navigation*
+
At the time the user requests the `index.xhtml` page, JSF still knows not whether the following page will be `saveOK.xhtml` or `saveNOK.xhtml`. 
That decides only after the form content of `index.xhtml` from user to was transmitted to the server, i.e. he pressed the button. 
Only after pressing the button (and the associated submission of the form content) the method binding is evaluated. 
In principle, however, every form content requires submission to the server a destination URL (Uniform Resource Locator) to which this data are transmitted. 
But since it is not yet clear which side will follow, refer `index.xhtml` to itself first, so it sends the form data back `index.xhtml`.

However, JSF will not return `index.xhtml`, but the method binding first execute and `saveOK.xhtml` or `saveNOK.xhtml` according to the outcome.

=== Case Study Blog Application - Navigation

== Converter

User input is always transmitted from the browser to the server as a string, regardless of whether the input is a number or not. 
These inputs will converted from JSF to required format, for example to integer. 
For it converter used. 
Some particularly frequently used converters are in the range of JSF included:

* JSF Converter
* Custom Converter
* Case study blog application - Converter

=== JSF Converter

User input is transmitted from the browser to the server as text, regardless of whether the input is a number or not. 
Still will these values are stored as a number in the managed bean. 
JSF uses converters for this. 
Converters supplied by JSF can be used for this.

The demo converter sample program illustrates the automatic conversion. 
That `h:messages` tag displays error messages that occur. 
It is defined in »Display of validation errors«, p. 113, explained in more detail.

*Example 1*
+
The following source code uses the `h:messages` tag.
----
<h:messages/>
<h:form>
    <h:inputText id="number" value="#{beispielBean.wert}" />
    <h:commandButton value="OK" />
</h:form>
----

*Explanation*
+
In this example exampleBean.value is a property of type double. 
Returns the user if you enter a number in the text field, it will be automatically converted and correctly converted into the saved managed bean. 
Returns the user a non-numeric value (e.g. test) occurs, an error message appears, as shown in Fig. 11.1-1.

image::

Fig.11.1-1: Converter error message.

The conversion is done automatically for some types like integer, double, etc.

The validators (the topic of validators is discussed in the chapter "Validation", p. 109
deepened) are dependent on the converters. 
So a `f:validateLongRange` validator don't validate a string, just a numeric value. 
The conversion must so take place before. 
Fig. 11.1-2 shows the process.

image::
Fig. 11.1-2: Conversion process.

Step 1: The user enters a number and presses the save button.
Step 2: The value (string) is saved as submitted value in the component.
Step 3: The value will be converted. 
The converted value is called local value saved.
Step 4: Now the validator can validate the value. 
It uses the (converted) local value.
Step 5: The local value is stored in the managed bean. 
If required, this value was previously validated.

The value transmitted by the browser is therefore initially displayed as submitted in the component value (String), then converted by a converter and stored as converted value saved as local value (for more information on submitted value and local value is referred to the chapter "The JSF Life Cycle", p. 165 referenced). 
Table. 11.1-1 shows types that are automatically converted by JSF.

In addition, there is also the option of explicitly adding converters to a component. 
This is useful, for example, if values are to be converted that cannot be automatically converted by JSF.

Specifying amounts in a currency would be an example. 
Here JSF will not automatically since only the amount and not the currency is saved
(€26.05 could only be stored as a simple numerical value 26.05, the currency is decisive for the amount). 
For such a case, the universal `f:convertNumber` tag can be used.

.Table 11.1-1: Types that can be automatically converted by JSF
|====
|Converter class
|Conversion class

|BigDecimalConverter
|java.math.BigDecimal

|BigIntegerConverter
|java.math.BigInteger

|BooleanConverter
|java.lang.Boolean and boolean

|ByteConverter
|java.lang.Number

|CharacterConverter
|java.lang.Character and char

|DoubleConverter
|java.lang.Double and double

|FloatConverter
|java.lang.Float and float

|IntegerConverter
|java.lang.Integer and int

|LongConverter
|java.lang.Long and long

|ShortConverter
|java.lang.Short and short
|====

A converter like `f:convertNumber` is simply attached as a "child" to the input component. 

The following source code uses the `f:convertNumber` tag.
.Example-2
----
<h:inputText id="currency" value="#{beispielBean.wert}">
    <f:convertNumber maxFractionDigits="2" groupingUsed="true"
        type="currency" currencySymbol="€" />
</h:inputText>
----

*Explanation*
+
In the example, the value is accurate to two digits (maxFractionDigits) with the Currency (type="currency") Euro (currencySymbol) and thousands separator (groupingUsed) shown. 
It is therefore assumed that the user exclusively enter amounts in euros. 
A valid entry would therefore be 1,00€. 
The value 1.0 is then stored in the managed bean. 
This conversion works also in the other direction. 
If the value changes in the managed bean to Example to the value 2.0, 2,00€ is displayed in the GUI.

However, the `f:convertNumber` tag is not only suitable for converting currency amounts. 
It is also possible to convert arbitrarily formatted numbers. 
In addition a pattern (also Pattern) can be used.

A selection of some tag configuration options is shown in Table. 11.1-2 listed.

.Table 11.1-2: Attributes of f:convertNumber.
|====
|Attribute
|Description

|currencyCode
|ISO 4217 currency code (only if type="currency").

|currencySymbol
|Currency symbol (only if type="currency").

|groupingUsed
|Indicates whether the value is presented with thousands separators.

|integerOnly
|Indicates whether the value is an integer.

|locale
|Locale used to format the values (e.g. es).

|pattern
|A number pattern that is used (e.g. €###, usable only if type="number").

|type
|Specifies the type (number, currency, or percentage). Default is percentage.
|====

The following source code uses the f:convertDateTime tag.

.Example-3
----
<h:outputText id="date" value="#{beispielBean.datum}">
    <f:convertDateTime dateStyle="full"
        locale="es" timeStyle="long" type="both" />
</h:outputText>
----

*Explanation*
+
For example, the output here will look like this:
+
martes 6 de febrero de 2018 21:06:00 GMT.

The `f:convertDateTime` tag presented here also offers some attributes that are listed in the Table
11.1-3 are shown.

|====
|Attribute
|Description

|dateStyle
|The date format: default, short, medium, long and full (Java standard).

|locale
|Locale used to format the values.

|pattern
|Pattern to use for parsing - timeStyle, dateStyle and type are then ignored - example: MM/dd/yyyy.

|timeStyle
|The time format: default, short, medium, long and full (Java standard).

|timeZone
|Time zone - Example: Europe/Berlin

|type
|Specifies the type (date, time, or both). Default is date.
|====
Table. 11.1-3: Attributes of f:convertDateTime.

=== Custom Converter

In many cases the converters provided by JSF should be sufficient. 
For special requirements there is the possibility to develop to use your own converter.

*Requirements of a custom converter*
+
A converter is supposed to turn a string (the user's input) into an object of a certain type. 
Like a standard converter, for example string values converted to numbers (e.g. integers).

The target type (that is, the class to convert to) can be a Class from the standard scope of Java or a self-developed class. 

However, the conversion process is not a one-way street. 
Values can be read from Managed beans and written to managed beans. 
A self-developed custom converter must therefore meet two requirements:

* Ability to turn a string into an object of the target type.
* Being able to turn an object of the target type back into a string.

*Structure of a converter*
+
These requirements make it obvious that two methods are needed to be able to do the conversion. 
A method to get a String into the object of the target type, and a method that returns the object can transform back.

JSF offers an interface that is used by the implementing converter class requires exactly these two methods. 
So it is not provided the conversion methods implement in the Managed Bean class. 
Instead there is the converter from a separate class that has the described converter interface (javax.faces.convert.Converter) implemented. 
Fig. 11.2-1 shows a UML representation this converter interface.

image::

Fig.11.2-1: Converter (UML-Notation).

The example program DemoCustomConverter clarifies the use and the implementation its Custom converter.

In the following, a converter is to be developed for the following city class.

Example 1. City.java
----
public class City {
    private int zip;
    private String name;
    
    // Getter und Setter
    ...
    @Override public String toString() {
        return zip + " " + name;
    }
}
----

In the object of the City class, the name of the city (name) and the zip code can be entered
(plz) are saved. 
JSF cannot automatically convert a string into an object of type city. 
Instead, a separate converter is developed for this purpose.

CityConverter.java
----
public class CityConverter implements Converter {
    public Object getAsObject(FacesContext context, UIComponent component, String value) {
        int split = value.indexOf('');
        City city = new City();
        city.setZip(Integer.parseInt(value.substring(0,split)));
        city.setName(value.substring(split+1,value.length()));
        return city;
}

public String getAsString(FacesContext context, UIComponent component, Object value) {
    return ((City)value).getZip() + " " + ((City)value).getName();
    }
}
----

For example, this converter accepts input in the form »zip city«.

Table 11.2-1 lists the method parameters shown in this example.
|====
|Attribute
|Description

|component
|Component containing the value to convert.

|context
|Faces Context, used to communicate with the framework

|value (String)
|String to be converted to an object.

|value (Object)
|Object to be converted to a string.
|====

The example is executable in this form, but the converter must still be made known to JSF so that it can be used. 
This is possible in two ways. 
It can be registered to be automatically used by JSF whenever a property of a managed bean or a managed bean itself of type city to be filled with a value. 
Alternatively, the converter can also be connected manually to a component to be hung.

*General registration of a converter*
+
The first option (general registration of the converter) is via a Annotation in the converter class and applies throughout the application.

This example shows the registration of the CityConverterClass:
----
@FacesConverter(forClass = City.class)
public class CityConverterClass implements Converter {
    ...
}
----

If a converter is registered via the `forClass` annotation parameter, JSF uses it automatically whenever a user-entered value is placed in an object of the target class (City.class) to be converted. 
This conversion is necessary when the input in a managed bean or a managed bean property of the type of the target class is to be saved.

The following class shows this connection as an example:

Example 3: Address.java
----
@Named
@SessionScoped
public class Address {
    private City city;
    public void setCity(City city) {
        System.out.println("was set:" + city);
        this.city = city;
    }
    public City getCity() {
        return city;
    }
}
----

*Explanation*
+
Now, when a JSF page accesses a managed bean of type Address and If you want to save an input as a city, JSF would automatically use the for this Process configured converter.

The following snippet shows access to the city property from a JSF page out (it is assumed that a managed bean address of type Address configured):

.index.xhtml
----
<h:inputText value="#{address.city}" />
----

In this example, the conversion is completely transparent and requires no further intervention by the developer.

*Explicit configuration of converter*
+
In addition to the general configuration described above, there are also the ability to explicitly configure a converter. 
To do this, an explicit name in of the @FacesConverter annotation.

An explicit configuration looks like this:

Example 4: CityConverterName.java
----
@FacesConverter("cityConverterName")
public class CityConverterName implements Converter {
    ...
}
----

*Explanation*
+
The example does not generally define which converter for which target type is used, but an ID is assigned to the converter. 
Under this one it can be referenced later in the JSF page.

Explicitly adding the city converter to a component would look for that above example like this:

----
<h:inputText value="#{address.city}"
    converter="cityConverterName" />
</h:inputText>
----

The converter is also used in this case, but only explicitly in this case Component.

=== Case Study Blog Application - Converter

The case study can be extended with its own converter. 
The converter will make it possible to specify the date in the form "today" as well. 
The current date is then used.

*GUI*
+
In addition to »Title« and »Text«, the blog entries also contain a »Date«. 
The corresponding date field is therefore added to the page (addEntry.xhtml). 
Additionally need error messages are issued. 
This is implemented using the `h:messages` tag.

*Implementation CaseStudyConverter*
+
Below are the changes compared to the Case Study input mask program shown.

A converter class `DateConverter` is implemented, which is included in the display page `addEntry.xhtml` is used. 
To do this, the annotation `@FacesConverter` must be added will.

The `addEntry.xhtml` file looks like this:

addEntry.xhtml
----
<h:body>
<h:messages />
<h:form>
    ...
    <h:outputText value="Date" />
    <h:inputText converter="dateConverter"
        value="#{addEntryBean.blogEntry.date}" />
...
</h:form>
</h:body>
----

The `h:messages` tag is used to output error descriptions. 
JSF cannot do automatic conversion for the date in this example. 
Although JSF provides a suitable converter for converting to a date (Date-TimeConverter), but this will (in contrast to all other supplied converters) not automatically drawn by JSF because the formatting information is different (e.g. 2018-04-13, 2018-04-13). 
Although this could be done via the Locale be determined, but it must be determined whether an entry with date and time (or only date or only time) is available. 
This cannot be determined done automatically.

DateConverter.java
----
@FacesConverter("dateConverter")
public class DateConverter implements Converter {
    public Object getAsObject(FacesContext context, UIComponent component, String value) {
        if("today".equalsIgnoreCase(value)) return new Date();
        SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");
        Date date = null;
        try {
            date = sdf.parse(value);
        }
        catch(ParseException ex) {
            ex.printStackTrace();
            throw new ConverterException (
                new FacesMessage("Date cannot be converted")
            );
        }
        return date;
    }

    public String getAsString(FacesContext context, UIComponent component, Object value) {
        Date date = (Date)value;
        SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");
        String dateText = sdf.format(date);
        if(dateText.equals(sdf.format(new Date()))) return "heute";
        return dateText;
    }
}
----

The converter is configured explicitly here. 
The converter can be found at Specification of the name `dateConverter` can be used. 
For each component, creates a new object of the class.

In this example, a custom converter is developed. 
The converter to be developed should - regardless of the locale set in the browser - a date in the form dd.MM.yyyy (e.g. 07.02.2018) and also accept an entry in the form »today«. 
When the user enters "today" in the field, it automatically becomes the current date used. If the date is to be output, in the event that the to be output date corresponds to the current date, also printed as "today". 
A possible internationalization is left out for the sake of simplicity. 
In the converter, the SimpleDateFormat class is used to convert the String object to transform a Date object and vice versa. 
If the date is the current date, this is a special case: Here »today« is used as the representation used instead of the date. 
In the event of an error, a ConverterException is thrown. 
JSF will then generate an appropriate error message, which is defined by the `h:messages` tag is shown.

Fig.11.3-1 shows the Managed Bean objects involved in the case study.

*Managed Bean-Objects*
+
image::

Fig.11.3-1: Managed Bean objects involved in the converter case study.

Compared to the case study input mask program, only the object `dateConverter` added. 
This is created a new for each component. 
If in a JSF page multiple components use this converter, then one for each component new object created.

== Validation

A central task of a web application is the validation of the data entered by the user. 
Various conditions often have to be checked: Was a value is entered, a text is long enough or a number is high enough. 
In the various aspects of validation are discussed in the next chapters:

* JSF Validation
* Displaying Validation errors
* Suspend validation
* Custom validation
* Bean Validation
* Case Study Blog Application - Validation

=== JSF Validation

Using validation tags added input component tags JSF can perform field validations. 

*JSF brings one support for validations with*
+
Validations can of course be done manually. 
Such an approach is However, JSF is not required. 
JSF already comes with a declarative validation functionality, intended for such tests. 
The data entered by the user are used Values already checked by JSF and only then (via the value binding) in the written managed bean when conforming to the specified validation rules are valid. Incorrect validations therefore mean that the values are not in the managed bean are written.

One of the simplest and at the same time most common checks is whether there is any value in
entered in a field. 
For JSF to check this, the required attribute for the corresponding tag can be set.

*Example 1:*

This could be for text fields that have the two properties lastname and firstname a represent managed bean users, look like this (on the implementation of the class for the managed bean is not received):

requiredfieldsValidation.xhtml
----
<h:inputText value="#{user.lastName}" required="true" />
<h:inputText value="#{user.firstName}" />
----

*Explanation*
+
In this case, JSF will only save the user's two entries in the corresponding form in the user managed bean when the last name has been entered was. 
If only the first name is entered by the user, JSF will neither store the first name nor the last name in the managed bean. 
To have to i.e. all user input must be valid so that JSF accepts the values.

Any JSF tag that accepts input from a user supports the required attribute (e.g. also h:inputTextarea). 
To check this function can an output in the setFirstName() method of the corresponding managed bean class to be added.

If only something is entered in the first name field and the OK button is clicked the value is not set (the setFirstName() method is not executed and thus the output does not appear). 
Only when an entry is made in the surname field both fields are set after pressing the button.

*More Validations*
+
In addition to this simple test, there is also the possibility of more extensive ones to carry out tests. 
So-called validators are used for this. 
validators are attached to an input component as a »child«. 
The validator will then check the input value of the user and save the value in the Managed Bean only allow the bean if it satisfies the relevant validation.

*Example 2:*
+
In this example, JSF will store the values in the managed bean only if the input is at least »three« characters long. 
The `f:validateLength` tag is used for this added.

lengthValidation.xhtml
----
<h:inputText value="#{user.firstName}">
    <f:validateLength minimum="3" />
</h:inputText>
----

*Explanation*
+
Here the `f:validateLength` tag is explicitly added to the `h:inputText` tag. 
The user must now enter at least three characters in the text field.

*Procedure for a value binding without validation*
+
It is easier to understand how this validation works within JSF if you know the normal procedure (without validation) that JSF uses for a value binding. 
This is shown in Fig.12.1-1.

image::

Fig.12.1-1: Procedure: value binding.

Step 1: The user enters some text in the box and hits the save-Button.
Step 2: The user's input is taken from the `h:inputText` component on the Server read from the request and stored in it.
Step 3: The value of the `h:inputText` component is stored in the associated Value Binding, i.e. the corresponding managed bean, is saved.

*Process at one value binding with validation*
+
If a validation is to be carried out using a validation tag, the validation tag is used between step 2 and step 3 to check the input.
Step 3 is only then carried out if the validation is successful. 
The graphic then looks like in Fig.12.1-2.

Fig.12.1-2: Procedure: value binding with validation.

There are several standard validation tags that come standard with JSF. 
A brief overview follows.

The `f:validateLength` tag validates the length of the input. 
It gets the user's input only accept if it is longer than the minimum (if a minimum is specified
becomes) and is not greater than the maximum (if a maximum is specified)
(Ref. Table. 12.1-1).

|====
|Attribute|Description
|minimum
|Minimum input length.
|maximum
|Maximum length of input.
|====
Table. 12.1-1: Attributes of the tag `f:validateLength`.

In this example, the last name entered must have a minimum of three and a maximum of eight characters long.
*Example 3*
+
lengthValidationMinMax.xhtml
----
<h:inputText value="#{user.lastName}">
    <f:validateLength minimum="3" maximum="8" />
</h:inputText>
----

The `f:validateLongRange` tag validates the size of the entered integer value. 
The numeric value must be greater than the minimum (if specified) and less than that maximum (if specified) (see Table. 12.1-2).

|====
|Attribute|Description
|minimum
|Minimum size of the value.
|maximum
|Maximum size of the value.
|====
Table. 12.1-2: Attributes of the tag `f:validateLongRange`.

In this example, the age entered must be between 18 and 120.

*Example 4*
+
numberrangeValidation.xhtml
----
<h:inputText value="#{user.age}">
    <f:validateLongRange minimum="18" maximum="120" />
</h:inputText>
----

The `f:validateDoubleRange` tag also validates the size of an entered numerical value. 
This time, however, it is a double value with decimal places. 
The numeric value must be greater than the minimum (if specified) and less than the maximum (if specified) (ref. Table. 12.1-3).

|====
|Attribute|Description
|minimum
|Minimum size of the value (also as an integer).
|maximum
|Maximum size of the value (also as an integer).
|====
Table. 12.1-2: Attributes of the tag `f:validateDoubleRange`.

*Example 5*
+
numberrangeValidation.xhtml

In this example, the weight is given as a number with decimal places in the range 10.00 and 200.00 expected.

----
<h:inputText value="#{user.weight}">
    <f:validateDoubleRange minimum="10.00" maximum="200.00" />
</h:inputText>
----

The `f:validateRegex` tag validates a value using regular expressions (ref. Table. 12.1-4).

|====
|Attribute|Description
|pattern
|Regular Expressions (searched pattern in a value)
|====
Table.12.1-4: Attributes of the tag `f:validateRegex`.

In the following example, the entered text must be four to ten characters long and contain both a number and a capital letter. 
A valid input value would be 1abC.

*Example 6*
+
regexValidation.xhtml
----
<h:inputText value="#{user.lastName}">
    <f:validateRegex pattern="((?=.*\d)(?=.*[a-z])
        (?=.*[A-Z]).{4,10})" />
</h:inputText>
----

These featured tags are the standard validation tags provided by JSF. 
Additional validation tags are offered by third-party providers (both commercial and non-commercial) that integrate with JSF.

=== Displaying Validation errors

Error messages can be output with the tags `h:message` and `h:messages`.

*Validation without error message*
+
Although JSF prevents the value from being written to the corresponding managed bean, however, the user does not know that there is an error. 
If a Navigation Rule is defined, it will not be executed. 
Here the user might guess that something is wrong. 
However, if the user enters the correct input on the same page and therefore no navigation rule is defined, it will be displayed on a Incorrect input may not notice any difference: the page becomes simple loaded again.

*JSF supports validations*
+
In any case, the user is informed that his input is not valid are, essential. 
However, since JSF cannot guess at which point on the page. 
To present error messages most appropriately, there are two tags, with which error messages can be output. 
So the developer can exactly determine where on the page these messages appear. 
The two tags are used in the explained below.

*h:messages*
+
The `h:messages` tag can be used to output all error messages that are on the page have occurred (ref. Table. 12.2-1).

|====
|Attribute|Description

|globalOnly
|Indicates whether all error messages are displayed or only error messages not caused by a component (more about this type of error message in the chapter »Own Validation«, p. 120).

|showDetail
|Indicates whether details about the error message should be displayed.

|showSummary
|Indicates whether a summary of the error message is displayed.
|====
Table. 12.2-1: Attributes of the `h:messages` tag.

For example, a summary is "validation error", the detailed message: "[ID] input required" (as "[ID]" is displayed a string identifying the component clearly identified).

There are also the following properties:

* errorClass/errorStyle
* fatalClass/fatalStyle
* infoClass/infoStyle
* warnClass/warnStyle

These attributes can be used to specify the respective classes / CSS styles that are used with
of the respective error level (error/fatal/info/warn). 
If you set the value border:1px solid red; to the errorStyle attribute, errors of the type error with a provided with a red frame. 
The following examples of the program demo validation errors should clarify the situation.

The input field for the last name is a mandatory field. 
Example 1 The OK button pressed without entering a last name, an error message is displayed.
*Example 1*
+
messageExample.xhtml
----
<h:messages/>
<h:form>
<h:inputText value="#{user.lastName}" required="true" />
<h:commandButton value="OK" />
</h:form>
----

*Explaination*
+
The error message can be slightly different depending on the JSF implementation used be. 
An error message is output here if the user does not input (Fig. 12.2-1). 
The information j_idt6 and j_idt7 refer to the component IDs in the component tree assigned by the JSF framework will. 
The value j_idt6 refers to the form (h:form) and the value j_idt7 refers to the input field within the form (h:inputText).

image::

Fig.12.2-1: Representation: Simple error message

*h:message*
+
The `h:message` tag can be used to output error messages that occur with a specific component have occurred. 
While with the `h:messages` tag, all error messages can be output here "in one" place on the page
placed meaningfully on the page for a particular component. 
As a general rule this should be near the component that caused the error. 
This Tag should preferably be used as it increases the usability of an application greatly improved. 
The attributes are almost identical to those of the `h:messages` tag. 
It the `globalOnly` attribute is missing, for this there is another attribute that the `h:messages`- tag does not have (ref. Table. 12.2-2).

|====
|Attribute|Description
|for
|Specifies which component to display errors for.
|====
Table.12.2-2: Attribute of the `h:message` tag.

*ID of the components*
+
In order to be able to specify the component in the for attribute for which error messages are to be generated, the components must be provided with an ID. 
The component can then be referenced via this ID.

Usage is shown in the example below:

Example 2:
+
messageForExample.html
----
<h:inputText id="firstName" value="#{benutzer.firstName}"
required="true" />
<h:message for="firstName" />
<h:inputText id="lastName" value="#{benutzer.lastName}"
required="true" />
<h:message for="lastName" />
<h:commandButton value="OK" />
----

*Explanation*
+
With each JSF tag, in addition to the component-specific properties, ties, an ID can also always be assigned. 
Here the first `h:inputText`-Tag is given the ID `firstname`, the second `h:inputText` tag is given the ID `lastname`. 
The IDs can be assigned arbitrarily. 
Once a tag has a unique ID, error messages are output for him with the `h:message` tag. 
This will the respective ID of the input component is specified in the for attribute of the `h:message` tag (Fig. 12.2-2). 
In this example, the error messages are always direct displayed above the respective component.

image::

Fig. 12.2-2: Representation: Two error messages.

*Customize error messages*
+
The quality of the message and the appearance can still be improved. 
Example- the wise is the id (e.g. j_idt5:lastname) represented by JSF for the user
rather confusing. 
The specification j_idt5 refers to the form for which no own ID was assigned. Therefore, an ID was assigned by the JSF framework.

Adjusting the error texts is fairly easy, but it requires understanding the internationalization concept understood by JSF. 
In addition to special property files with texts (also called message bundles) intended for one or more JSF pages are, there is also the possibility to define global files. 
these can then contain customized error messages, for example. 
Adjust demo validation errors in the program this is made clear.

*Adaptation in the faces-config.xml*
+
To configure JSF to pull such a file, the `faces-config.xml` needs to be extended as follows:
----
<application>
    <message-bundle>jsf.beans.errormessages</message-bundle>
</application>
----

*Property file with error messages*
+
The message-bundle tag contains the property file that contains the error messages that are printed instead of the default messages.

An example of a Property file overriding the message for mandatory fields left blank:

*Example 3*
+
errormessages.properties
----
javax.faces.component.UIInput.REQUIRED=This is a mandatory field, please fill out this field.
----

Instead of the error message given in example 2, the error message in the file defined error message. 
Again, it is possible for different Languages different files (with appropriate language abbreviation) use to define the error messages in different languages.

*Place Holder*
+
To output the component causing the error in the form of its ID, the wildcard {0} can be used. 
The form should also get an ID, otherwise the ID automatically assigned by the JSF framework is displayed in the error message becomes.

For example, the Property file looks like this:
*Example 4*
+
errormessages.properties
----
javax.faces.component.UIInput.REQUIRED={0} is a required field, please fill this field.
----

There are numerous other keys that overwrite with appropriate error messages can become. 
A brief listing is shown below, where the ..._detail message is the detail message. The first error message (javax.faces.component.UIInput.REQUIRED) the general error message would be e.g. Validation errors and the detailed message (javax.faces.component.UIInput.REQUIRED_detail) [ID] input required.

|====
|required
|javax.faces.component.UIInput.REQUIRED (REQUIRED_detail)

A required field was not filled out.

Placeholder: {0} (ID)

|f:validateLength
|javax.faces.validator.LengthValidator.MAXIMUM (MAXIMUM_detail)

The value is greater than the maximum.

Placeholder: {0} (maximum), {1} (id)

|javax.faces.validator.LengthValidator.MINIMUM (MINIMUM_detail)

The value is less than the minimum.

Placeholder: {0} (minimum), {1} (ID)
|f:validateDoubleRange

|javax.faces.validator.DoubleRangeValidator.MAXIMUM (MAXIMUM_detail)

The value is greater than the maximum.

Placeholder: {0} (maximum), {1} (ID)
|javax.faces.validator.DoubleRangeValidator.MINIMUM (MINIMUM_detail)

The value is less than the minimum.

Placeholder: {0} (minimum), {1} (ID)
|javax.faces.validator.DoubleRangeValidator.NOT_IN_RANGE (NOT_IN_RANGE_detail)

The value entered is not in the valid range.

Placeholder: {0} (from), {1} (to), {2} (ID)
|f:validateLongRange
|javax.faces.validator.LongRangeValidator.MAXIMUM (MAXIMUM_detail)

The value is greater than the maximum.

Placeholder: {0} (maximum), {1} (id)

javax.faces.validator.LongRangeValidator.MINIMUM (MINIMUM_detail)
|====

=== Suspend validation

Sometimes it may be necessary to validate a page at certain times disable actions. 
For example, if the "Cancel" button is pressed.

When the Cancel button is pressed, validations are usually undesired: The user wants to cancel the current action, the entered Values do not need to be adopted. 
Therefore, there should be no error message appear. 
But for JSF it is also the Cancel button an ordinary button followed by an action. Therefore, also at A validation can be performed when this button is triggered. shows the process (generalized) Fig. 12.3-1.

image::

Fig. 12.3-1: Validation when cancel is triggered.

Step 1: The user enters a text.
Step 2: The text is read from the request by the input component and stored internally.
Step 3: The internally stored text is validated.
Step 4: The text is included in the managed bean (if it was valid).
Step 5: The action of the button is performed.

*Suspend validation*
+
However, there is a way to suspend that. 
That's what you use for that Validation immediate attribute of the button. 
If this attribute is set, the button Action performed before validation (i.e. immediate) and entered Values are neither validated nor by the corresponding value binding transferred to the managed bean. 
Instead, the (via the method Binding) defined action of the button is executed and then accordingly navigates. 
The process is (generalized) as shown in Fig. 12.3-2.
image::
Fig. 12.3-2: Validation when triggering with immediate.

Step 4 and step 5 are shown separated by a line in Fig. 12.3-2 because these steps are no longer performed after the immediate action has been performed. 
The button action is already executed here in step 3.

The relationships are explained in the DemoValidationRelease program.

The example1.xhtml page illustrates the use of the immediate attribute.

Example 1

example1.xhtml
----
<h:message for="firstName" />
<h:inputText value="#{benutzer.eingabe1}"
required="true" id="firstName" />
<h:commandButton immediate="true" value="abbrechen" />
<h:commandButton value="speichern" />
----

*Explanation*
+
Here the user can enter a text (first name) and then save it to press. 
However, the save action is only executed if a text has also been entered. 
This is provided by the `h:inputText` component's required attribute forced. 
However, if the user presses cancel, the cancel-Action performed and no validation takes place. 
In this case he has to User does not enter any text in the text box.

If the first name field is left blank and then the save button pressed, an error message is output. 
When pressing the button no error message is output. 
Instead of triggering the store-button to reload the same page, it would also be possible to go to another page to branch. 
To keep the example simple, this has been omitted.

*More detailed consideration*
+
In addition to these rather superficial observations, something else happens in this example: When canceling, the entered value is not saved in the associated value binding (here #{user.input1}), regardless of whether it is valid or not is saved (as shown in Fig. 12.3-2). 
When saving, the Value, on the other hand, is stored in the value binding (as shown in Fig. 12.3-1).

*Immediate attribute for input components*
+
Besides being able to set the immediate attribute on the `h:commandButton` component, there is also the option to set the immediate attribute on the `h:inputText` component to put.

Setting the immediate attribute on the `h:inputText` component results in the validation before the validation of the other (non-immediate) components and also before executing an action of an immediate -`h:commandButton` component is carried out. 
Fig. 12.3-3 illustrates the process for a page on which there is both an `h:inputText` component that is immediate (here the type) and one that is not immediate (like firstname in the previous examples).

Fig. 12.3-3: Validation with and without immediate.

Step 3 and step 4 are only processed here for the component type, since this is immediate. 
Only step 2 is processed for the first name component. 
Step 5 and 6 would not be processed at all if you clicked on the Cancel button (therefore shown separated by a line).

*Example 2*

The source code example2.xhtml looks like this:

example2.xhtml
----
<h:message for="typ" />
<h:inputText value="#{benutzer.eingabe1}" required="true"
immediate="true" id="typ" />
<h:message for="firstName" />
<h:inputText value="#{benutzer.eingabe2}" required="true"
id="firstName" />
<h:commandButton immediate="true" value="abbrechen" />
<h:commandButton value="speichern" />
----

*Explanation*
+
In this example, there are several ways the user can behave could. 
Each of the possibilities, including the result, is explained below listed (see Tab. 12.3-1).

|Input
|action
|Description

Tab. 12.3-1: Input options.

=== Custom validation

You can also implement your own imperative validations with JSF, which are also carried out before values in the respective value binding of the components are written. 
A distinction is made here between component-dependent and component-independent validations.

*Difference*
+
In a component-dependent validation, the entered value becomes a specific component validated (e.g. an email address). 
error messages refer to this one component.

In a component-independent validation, not only a syntactical one takes place check of a single value instead of a semantic (e.g. authentication username and password combination).

*Component dependent validation*
+
In this case, a separate validation method is implemented. 
To own one Performing validation requires a special method binding on the component
set that is to carry out this check. 
This is how method and component become linked together.

The program DemoValidationOwnSyntactically clarifies the facts.

In a JSF page, validateEmail.xhtml, it looks like this:

Example 1a.

validateEmail.xhtml
----
<h:messages />
<h:inputText value="#{user.email}"
    validator="#{user.validateEmail}">
</h:inputText>
----

This assumes that the managed bean user actually has a method `validateEmail()` exists.

*Method binding for validation*
+
It is not necessary to include the validation method (as shown here) in the Implement managed bean class that also contains the value to be checked. 
It would also be possible to create another class that, for example, only Validation methods and the method binding refer to this class to let. 
To do this, this class must implement the `javax.faces.validator.Validator` interface.
In the JSF page, the tag is `f:validator` specifying the validator class over the Attribute `validatorId` required. 
However, it is often advisable to program parts that are responsible for rendering a specific page, in a managed bean class to summarize.

*conventions for validation methods*
+
A method that accepts validation must have certain accept invocation parameters and have a specific return value so that JSF can use it for validation.

An example of such a method (here: validateEmail()) is listed below:

Example 1b: user.java
----
public void validateEmail(FacesContext context, UIComponent component, Object value) {
    String input = (String) value;
    if (input.indexOf('@')==-1) {
        ((UIInput)component).setValid(false);
        FacesMessage message = new FacesMessage("Invalid e-mail address");
        context.addMessage(component.getClientId(context), message);
    }
}
----

The many call parameters of the validation method may seem confusing, that however, the underlying concept is quite easy to understand (ref. Table-12.4-1).

|====
|Parameter
|Function

|FacesContext context
|This is an object that contains all the information about the keeps current JSF state. 
This object enables direct communication with the framework.

|UIComponent component
|The component that contains the value to validate.

|Object value
|The value to validate, entered by the user.
|====
Table. 12.4-1: Call parameters of the validation method.

These call parameters must be present with every validation method.

The core of the method is checking the entered value (in this case it is checked if
whether the input contains an @ sign). 
The value to be checked is given as a parameter passed value.

*Converter*
+
This does not necessarily have to be a string, as assumed here. 
When adding any object can be expected from a converter to a component will. 
If no converter is used and the property of the value binding is on String (as in this example), a string can also be expected here.

If the check is successful, there are no further steps in the method necessary.

*How to proceed if not valid values*
+
If the value is not valid, two steps must be performed. 
Of the the fourth step is to tell the affected component itself that the value it contains is invalid. 
This is done via the setValid() method.

The user must then also be informed with a message. 
For this purpose, a Faces Message is created with an error message and using the addMessage() method communicated to the JSF framework.

In this case, the addMessage() method is called with two parameters. the
both parameters are explained in Table. 12.4-2.

|====
|Parameter
|Function

|String
|FacesMessage
|====
Table 12.4-2: Parameters of the addMessage() method

The first parameter is a string, that is, the component ID must be passed here as a string. 
To find out the ID of a component, the getClientId() method can be used. 
This returns the ID of the component as String back.

It is important to include the component ID when communicating the error message with addMessage() to use so later with the h:message tag the error messages can be output that belong to a specific component (using of the for attribute).

*Component independent validation*
+
The mechanisms presented so far allow a syntactic single field check. 
However, something more general must often be validated. 
It would be conceivable that checked whether a person's first and last name already exist in the database. 
Here not only one field is checked, but two. 
The exam is in this case not syntactic, but semantic (content-related) nature.

*Method Binding*
+
In order to also be able to take such cases into account, JSF offers the possibility of checking data from several fields at the same time after they have been transferred to the corresponding Managed beans were written. 
So this type of validation does not prevent adoption a value into the managed bean (this has already happened at this point), but is used for subsequent validation and display of corresponding error messages. 
Usually this will happen in the method due to the User action (e.g. pressing a button) or the associated method Bindings is called.

*Example 2*
+
For example, the user may press a "Save" button. 
JSF then first reads the data entered by the user (here, for example, first name and last name) in the managed bean. 
Then the with method linked to the button (via a method binding) storeUser() executed. Before the method finally saves the record, it will conduct an exam. 
Here it is an exam that ensures the pros and Surname does not yet exist in the database (userExists()).

The DemoValidationOwnSemantic program explains the facts.

----
@Inject
private FacesContext context;
public String saveUser() {
    if (userExists(user.getFirstName(), user.getLastName())) {
        FacesMessage message = new FacesMessage();
        message.setSeverity(FacesMessage.SEVERITY_ERROR);
        message.setSummary("Combination of first and last name already exists");
        message.setDetail("A combination of first and last name may only occur once");
        context.addMessage(null,message);
        return "";
    }
    return "ok";
}
----

*Explanation*
+
This example uses the `userExists()` method to determine whether the specified combination of first and last name is already in the database exists. 
In this case, a Faces Message is created with the error message and the error details are set. 
This Faces Message is then sent to the Faces Passing the context (addMessage()) without specifying an ID (in contrast to the addMessage() call for an error message associated with a component becomes). 
The error message is therefore not assigned to any component. 
It is a general error message. 
Finally, JSF is returned using return ""; instructed to reload the current page. 
Important for the return value is only that no navigation rule exists for it. 
It might as well be there return "xyz".

NOTE:
The severity of the message can be specified using the `setSeverity()` method (SEVERITY_INFO, SEVERITY_WARN, SEVERITY_ERROR or SEVERITY_FATAL). the inserted messages may or may not be displayed depending on the setting. 
These setting options are not discussed in detail in this book.
=== Bean Validation

Using bean validation is another declarative way to do this Validating input to managed beans. 
The validation information will be done directly in the managed bean classes.

The specification of the Bean Validation 2.0 was released and made possible in the JSR 380 the use of validation rules directly in the managed bean class. 
As in the validation tags, this is a declarative configuration. 
Next to the specification of the validation rules in the managed bean class are no further tags necessary.

Analogous to the definition of validation rules using validation tags, the passed values are not written to the managed bean until validation is successful was.

*Use*
+
When using bean validation, the necessary restrictions (Constraints) via annotations on the respective properties of the managed bean - class are defined. 
Table. 12.5-1 shows a section of the possible annotations.

|====
|Annotation
|Description

|Min
|Max
|NotBlank
|NotEmpty
|NotNull
|Size
|====

Table. 12.5-1: Bean validation annotations.

The following examples of the program `DemoBeanValidation` clarify the usage from `BeanValidation`.

Two text boxes are inserted on a JSF page with no validation information

Example 1:
user.xhtml
----
<h:messages />
<h:form>
<h:outputText value="firstName" />
<h:inputText value="#{user.firstName}" /><br />
<h:outputText value="lastName" />
<h:inputText value="#{user.lastName}" /><br />
<h:commandButton value="ok" />
</h:form>
----

In the underlying managed bean class users are the constraints determined by annotations.

User.java
----
@Named
@RequestScoped
public class User implements Serializable {
    private String lastName;
    private String firstName;

    @NotNull(message = "Last name is a required field")
    @NotBlank(message = "Last name cannot be empty")
    @Pattern(regexp = "[a-z-A-Z]*", message = "Invalid characters in last name")
    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    @NotNull(message = "First name is a required field")
    @NotBlank(message = "First name cannot be empty")
    @Pattern(regexp = "[a-z-A-Z]*", message = "Invalid characters in first name")
    public String getFirstName() {
        return firstName;
    }
    
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
}
----

The browser display after sending empty input fields shows the Fig. 12.5-1.

Both properties lastName and firstName must not be "null" (@NotNull). 
The inputs must not consist exclusively of spaces (@NotBlank) and must match the pattern "lowercase and uppercase" (@Pattern).

Classic JSF validation aims at validating individual components. 
However, in some areas it makes sense to validate the entire managed bean, for example
a simultaneous check of several fields. 
This mechanism is about the tag that allows `f:validateWholeBean`. 
Simultaneous checks of several fields can also be implemented with your own validation components, but the transferred values into the managed bean when using `f:validateWholeBean` written if the validation was successful. 
Table 12.5-2 shows the attributes this tag.

image::..

Fig. 12.5-1: Class validation.

|====
|Attribute
|Description

|disabled
|id
|validationGroups
|value
|====

Table 12.5-2: Attributes of f:validateWholeBean.

This functionality must be activated via an entry in the configuration file `web.xml`
will.

web.xml
----
<context-param>
<param-name>javax.faces.validator.ENABLE_VALIDATE_WHOLE_BEAN</param-name>
<param-value>true</param-value>
</context-param>
----

Validation information can be refined by using the `f:validateBean` tag will. 
For example, groupings can be specified or implicit validation be deactivated. 
Table. 12.5-3 shows the attributes of this tag.

|====
|Attribute
|Description

|disabled
|validationGroups
|====
Table. 12.5-3: Attributes of f:validateBean.

*Example 2*

A password including password repetition should be entered on a JSF page. 
An entered password is only valid if both entries are identical.

A ValidPasswordGroup tagging interface is set as a validation group.

ValidPasswordGroup.java
----
public interface ValidPasswortGroup { }
----

The JSF page is shown below.
password.xhtml
----
<h:messages />
<h:form>
<h:outputText value="Password" />
<h:inputText value="#{password.password}">
<f:validateBean validationGroups="jsf.beans.ValidPasswortGroup" />
</h:inputText><br />
<h:outputText value="Password (repeat)" />
<h:inputText value="#{password.repeatPassword}">
<f:validateBean validationGroups="jsf.beans.ValidPasswortGroup" />
</h:inputText><br />
<f:validateWholeBean value="#{password}" 
    validationGroups="jsf.beans.ValidPasswortGroup" />
<h:commandButton value="ok" />
</h:form>
----

The validation group is set using the `f:validateBean` tag `jsf.beans.ValidPasswordGroup` for both input fields. 
If one If validation of the individual fields is to be activated, the added to the `javax.validation.groups.Default` validation group. 
The tag `f:validateWholeBean` sets the class validation. 
The validation groups must for the input fields configured with `f:validateBean `and for the tag `f:validateWholeBean` must be identical.

The managed bean class must be annotated with a specially defined annotation will. 
The annotation `ValidPassword` is created for this.

ValidPassword.java
----
@Target(TYPE)
@Retention(RUNTIME)
@Constraint(validatedBy = Password.class)
public @interface ValidPassword {
    String message() default "Invalid passwords";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
----

The annotation should be set at class level (@Target(TYPE)) and to be available at runtime (@Retention(RUNTIME)). 
The actual implementation class for performing the validation, specifying the annotation @Constraint(validatedBy = password.class). 
The message annotation attribute specifies the Returns default text in case of a negative validation check. 
The validation groups are configured via the annotation attribute groups. 
The payload can be used to pass your own user data for validation.

The `ValidPassword` managed bean class does the actual validation.

ValidPassword.java
----
@ValidPassword(groups = jsf.beans.ValidPasswortGroup.class)
public class Password implements Serializable, 
    ConstraintValidator<ValidPassword, Password> {
        private String password;
        private String passwordWdh;
        
        // Getter und Setter
        ...
        
        @Override
        public void initialize(ValidPassword constraintAnnotation) { }

        @Override
        public boolean isValid(Password other, ConstraintValidatorContext context) {
            return other.getPassword().equals(other.getPasswordWdh());
        }
}
----

The validation takes place in the `isValid` method. 
Only if both passwords match, the validation is successful.

The browser display after sending unequal passwords shows the Fig. 12.5-2.

image::..

Fig. 12.5-2: Class validation

=== Case Study Blog Application - Validation

Validations are also necessary in the case study. 
It becomes the input mask appropriately validated for a blog entry.

*GUI*
+
The properties title and text of a blog entry should be validated. 
A title should come with at least three and a maximum of 50 characters. 
The detailed text should contain at least three characters.

*Implementation case study validation*
+
Below are the changes compared to the Case Study input mask program shown.

Only the `addEntry.xhtml` display page needs to be updated.

The `addEntry.xhtml` file looks like this:

addEntry.xhtml
----
<h:body>
<h:form>
<h:outputText value="Title" />
<h:inputText value="#{addEntryBean.blogEntry.title}" id="title">
    <f:validateLength minimum="3" maximum="50" />
</h:inputText>
<h:message for="title" />
<h:outputText value="Text" />
<h:inputTextarea value="#{addEntryBean.blogEntry.text}" rows="5" cols="80" id="text">
    <f:validateLength minimum="3" />
</h:inputTextarea>
<h:message for="text" />
</h:form>
</h:body>
----

The input field for title must have a minimum of three (minimum="3") and a maximum of 50 characters (maximum="50"). 
The input field for text must contain at least three characters (minimum="3") long. 
In addition, an `h:message` tag was added after both fields, that outputs any error messages. 
To allow the notifications are displayed for the respective input components, both components were additionally extended by an ID (title and text).

*Managed Bean-objects*
+
The Managed Bean objects involved are no different from the CaseStudyInputForm program.

== Listener

=== Action Listener

=== Value Change Listener

== Advanced Components

=== Selection lists

==== JSF picklists

==== Case Study Blog Application - Picklists

=== file upload

==== JSF file upload

==== Case Study Blog Application - File Upload

=== Advanced Components - Tables

==== JSF tables

==== Tables - the Master Detail Pattern

==== Case study blog application - table

== component tree

== The JSF lifecycle

== Around the JSF application

== Configuration files

=== web.xml

=== faces-config.xml

== Management of resources

=== JSF resources

=== Case Study Blog Application - Resources

== Asynchronous JavaScript and XML

== HTML5 Friendly Markup

== WebSocket

== JSON Processing

JSON ( JavaScript Object Notation) is a lightweight data exchange format. 
The data is read in a human-readable format and written. 
In JSF applications, the Java API can be used for processing JSON.

JSON only defines two data structures: objects and arrays. 
There is an object a collection of "name/value pairs" and an array is a list of values. 
In JSON, six different data types can be used: string, number, object, array, bool [true, false] or null.

*Object*
+
An object is defined in curly brackets {...}. 
The existing name/value pairs are separated by a »comma«. 
The name is specified as a string and the value is specified as value. 
The separation of name and value is realized by means of a »colon«. 
A value can be one of the six available acceptable data types.

An example of name/value pairs looks like this:

.Example-1[JSON]
----
{
"firstname":"nagaraju",
"lastname":"gumpini",
"age":30
}
----

*Explanation*
+
In this case, there are three name/value pairs: firstname, lastname, and age. 
The age is stored as a number and is therefore not in quotes.

*Array*
+
An array is defined in square brackets [...]. 
The value values ​​are given using an array separated by "commas".

An example of an array looks like this:
.Example-1[JSON]
----
{
"name":"nagaraju",
"telephone":
    [
        { "type":"private", "number":"8886934448" },
        { "type":"business", "nummer":"8886914448" }
    ]
}
----

*Explanation*
+
The object consists of the name/value pairs name and phone, where phone has an array is defined as the value. 
The array consists in turn of the name/value pair type and number.

See JSR 374 for more information [JCP17a].

*Server*
+
The JsonObject interface and the Json class relevant to the creation are shown below.

* javax.json.JsonObject:
+
Represents a JSON object composed of an unordered collection of name/value pairs.
* javax.json.Json:
+
Factory class for creating JSON objects.

*Client*
+
Client-side A JavaScript API is used on the client side, which has the methods JSON.parse() and JSON.stringify() and is built into most web browsers.
* JSON.parse(text [, reviver]):
+
This method converts a text value text into a JSON object. 
The value reviver is optional and transforms the results.
* JSON.stringify(value [, replacer] [, space])
+
This method converts a JavaScript value to a JSON object.

The example JSON1 implements the »chat room« example from the chapter »Web Socket«, p. 201, passing a JSON object. 
The class ChatroomBean contains Getter and setter for a temporary property to pass the input values ​​and a property of type JsonObject.
.Example-3[java]
----
ChatraumBean.java

----

== Reuse

== Faces Flows

== Extend JSF core

== Outlook

== Appendix A Eclipse
