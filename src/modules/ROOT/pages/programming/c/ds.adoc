[[c_ds]]
= Data Structures through C
:page-aliases: ds/ds.adoc
:imagesdir: ../../../../images/programming/c/ds

== Unit 1

=== Data Structures

==== Definition

* Data structures is the concept of set of algorithms used to structure the information.
* These algorithms are implemented in different programming languages like c, c++, java, python, etc.
* Structure the information means store and process data in an efficient manner.
* To store and process data, we may use the following operations:
1. create()
2. insert()
3. delete()
4. display()
5. search()
6. sort()
7. merge()
8. split()
9. traverse()
* So the data structure may contain algorithms, used for different operations implement these algorithms by a programming language.
* For example, for stack data structure, write algorithms for different operations
1. push
2. pop
3. display
* Implement these algorithms in a particular language say C.

==== Classification of Data Structures

Data Structures are normally classified into 2 types:
1. Primitive Data Structures
2. Non-Primitive Data Structures

===== Primitive Data Structures

Primitive data structures are built-in types in most programming languages. They are:
1. Integer:: It is whole numbers i.e. negative value, 0, positive value.
2. Float:: It is fractional numbers.
3. Character:: It is character values.
4. Boolean:: It represents true or false values.

===== Non-Primitive Data Structures

These are derived from primitive data structures. They are:
1. Array
2. Structure
3. Union
4. Files
etc.

Non-Primitive data type is further divided into Linear and Non-Linear data structures:

a. Linear Data Structures:
Here the data elements are connected in a sequence manner.
Examples are:
1. Arrays
2. Linked List
3. Stacks
4. Queues

Array:
It is collection of elements of same type.

a[5] = {10, 20, 30, 40, 50}

|====
|0|1|2|3|4
|10|20|30|40|50
|====

Linked List:
* Linked list or single linked list is a sequence of elements in which every element has link to its next element in the sequence.
* Every element is called as a `node`. 
Every `node` contains two fields, `data` and `link`. 
The `data` is a value or string and 
`link` is an address of next `node`.
* The first `node`` is called as `HEAD` which is an empty node contains an address of the first node so it link to the first `node`.
* The first `node` link to second `node` and so on.
* The last `node` does not link to address but link to `NULL`. 
Let `ptr` be a `pointer` to the linked list. 
THe example is given below:
image::linked-list.png[Linked List]

Stack:
A `stack` is a data structure in which additions and deletions are made at the top of the `stack`. 
So we can perform two operations on `stack`.
1. Adding elements into the stack known as `push`.
2. Removing elements from the stack known as `pop`.
image::stack.png[Stack]

Queue:
A `queue` is a data structure in which additions are made at one end and deletions are made at the other end. 
We can represent a `queue` in an array.

Here we can perform two operations on `queue`.
1. Adding elements into the queue known as insertion at rear.
2. Removing elements from the queue known as deletion at front.
image::queue.png[Queue]

b) Non-Linear Data Structures:
Here the data elements are not connected in a sequence manner.

Examples are:
1. Trees
2. Graphs

Tree:
A `tree` is defined as a finite set of one or more `nodes` such that
1. One `node` is called a root node and
2. Remaining `nodes` are partitioned into sub trees of the root.
image::tree.png[Tree]

Graph:
* A `graph` is a pictorial representation of a set of `points` or `nodes` termed as `vertices` and the `links` that connect the vertices are called `edges`.
* A `graph`(G) consists of two sets `V` and `E` where `V` is called vertices and `E` is called edges. 
We also write G = (V, E) to represent the graph.
* A `graph` may be directed graph or undirected graph.
image::graph.png[Graph]
* Fig(a), Fig(b) are called undirected graph and Fig(c) is called directed graph.

Differences between Linear and Non-Linear Data Structures:
[cols="1,1"]
|===
|Linear Data Structure | Non-Linear Data Structure 

|Every data element is connected to its previous and next element.
|Every data element is connected with many other data elements.

|Data is arranged in a sequence manner.
|Data is not arranged in a sequence manner.

|Data can be traversed in a single run.
|Data cannot be traversed in a single run.

|Ex: Arrays, Linked List, Stacks, Queues
|Ex: Trees, Graphs

|Implementation is easy.
|Implementation is difficult.
|===

==== Operations on Data Structures

The different operations on data structures are:

1. Create:
+
Here we reserve memory for program elements: This can be done using `malloc()` or `calloc()` function. 
We can create a data structure with giving different elements.

2. Insert:
+
Here we reserve memory for program element: This can be done using `malloc()` or `calloc()` function. 
We can insert a data element into a data structure.

3. Delete:
+
It delete memory space allocated for specified data structure using `free()` function.

4. Display:
+
It deals with accessing a particular data element within a data structure.

5. Search:
+
* It finds the data element in the list of data elements.
* It also find the location of all elements.

6. Sort:
+
It is the process of arranging all the data elements in a data structure in a particular order say either in ascending or descending order.

7. Merge:
+
It is the process of combining the data elements of two different sorted list into a single sorted list.

8. Split:
+
It is the process of partitioning single list to multiple list.

9. Traversal:
+
It is the process of visiting each and every node of a list in systematic manner.

==== Abstract Data Types (ADT)

An `Abstract Data Type (ADT)` is a collection of values and a set of operations without specifying its implementation.

For example in Array ADT, set of values are index and item & set of operations are create(), retrieval() and store().

*Purpose*:
+
* The purpose of the ADT is to hide the implementation details of a data structure thus improving software maintenance, reuse and portability.
* The developers of ADT will adapt changing requirements and save time.
* The users of ADT are concerned with the interface, but not the implementation.
* The different ADTs
** String ADT, List ADT, Stack ADT (last-in, first-out(LIFO))
** Queue ADT (first-in, first-out(FIFO))
** Binary Search Tree ADT
etc.

*Example*:
+
* A `List ADT` contain operations known as add element, remove element, etc.
* A `List ADT` can be represented by an `array-based` implementation or a `linked-list` based implementation. 
In this the `linked-list` based implementation is so commonly used.
* Similarly a `Biney Search Tree ADT` can be represented in different ways with the same operations known as insert, remove, display, etc.

==== Array as an Abstract Data Type

The `Array ADT` is a set of values (index, element) and a set of operations known as `Array create()`, `Item Retrieve()` and `Array Store()`.

The `Array ADT` algorithm is given by
+
----
`Array ADT` is
+
*objects*: A set of pairs<index, element> where for each index, there is a corresponding element.
*functions*: for all A€Array, i€index, x€element:
Array create() := It creates a new empty array.
Item retrieve(A, i) := It returns the element with particular index, if the index is valid or an error if the inded is invalid.
Array Strore(A, i, x) := It stores the element
end Array.
----

==== Stack as an Abstract Data Type
+
----
ADT stack is 
*objects*: a finite ordered list with zero or more elements.
*functions*: S € Stack, item € element
Stack create() := creates a new empty stack.
Stack push(S, item) := adds item to the top of the stack.
Element pop(S) := removes the top element of the stack and returns it.
end Stack.
----

==== Queue as an Abstract Data Type
+
----
ADT queue is
*objects*: a finite ordered list with zero or more elements.
*functions*: Q € Queue, item € element
Queue create() := creates a new empty queue.
Queue addq(Q, item) := adds item to the end of the queue.
Element deleteq(Q) := removes and return the item from the queue.
end Queue.
----

==== Binary Tree as an Abstract Data Type
+
----
ADT BinaryTree is
*objects*: a finite set of nodes.
*functions*: for all bt, bt1, bt2 € BinaryTree, item € element
BinaryTree create() := creates a new empty binary tree.
Boolean IsEmpty := if(bt == empty binary tree) return `TRUE` else return `FALSE`
BinaryTree MakeBT(bt1, item, bt2) := return a binary tree whose left subtree is bt1, whose right subtree is bt2 and whose root node contains the date item.
BinaryTree LeftChild(bt) := returns the left subtree of bt.
Element Data(bt) := returns the data of the root node of bt.
BinaryTree RightChild(bt) := returns the right subtree of bt.
End BinaryTree.
----

==== Graph as an Abstract Data Type
+
----
ADT Graph is
*objects*: a set of vertices and edges.
*functions*: for all graph € Graph, v, v1 and v2 € Vertices
Graph create() := creates a new empty Graph.
Boolean IsEmpty() := if(graph == empty graph) return `TRUE` else return `FALSE`
Graph InsertVertex(graph, v) := returns a graph with vertex v inserted.
Graph InsertEdge(graph, v1, v2) := returns a graph with edge (v1, v2) inserted.
Graph DeleteVertex(graph, v) := returns a graph with vertex v removed.
Graph DeleteEdge(graph, v1, v2) := returns a graph with edge (v1, v2) removed.
End ADT Graph.
----

===== Preliminaries of algorithms

Algorithm is step-by-step process or sequence of steps for solving a problem.

Properties of an Algorithm:
+
* The properties of an algorithm are:
Input:
+
The algorithm must have input values from a specified set.
Output:
+
The algorithm must produce the output values from a specified set of input values. 
The output values are the solution to a problem.
Finiteness:
+
For any input the algorithm must terminate after a finite number of steps.
Definiteness:
+
All the steps of an algorithm must be precisely defined.
Effectiveness:
+
It must be possible to perform each step of the algorithm correctly and in a finite amount of time.

* Each step should be well defined. 
It can be divided into 3 types.
+
1. Sequence
* In an algorithm if all steps are shown then it is known as sequence.
* for example an algorithm for adding two values.
+
----
Ex:
Step 1: start
Step 2: read a, b
Step 3: r = a + b
Step 4: print r
Step 5: stop
----
2. Selection
+
* Here we use if condition and the condition is checked only one time.
* if a condition is satisfied then next statement is executed otherwise else statement is executed.
* For example an algorithm to check whether the given number is even or odd.
+
----
Ex:
Step 1: start
Step 2: read n
Step 3: if (n % 2 == 0) goto step 4
        if not goto step 6
Step 4: print "n is even" goto step 7
Step 5: else
Step 6: print "n is odd"
Step 7: stop
----

3. Iteration
+
* Here we use while, do-while and for loop & the condition is checked number of times.
* i.e. The statements in an iteration block are executed no. of times based on some condition.
* For example an algorithm to print 1 to n numbers using while loop.
+
----
Ex:
Step 1: start
Step 2: read n
Step 3: initialize i = 1
Step 4: while (i <= 10) goto step 5
        otherwise goto step 7
Step 5: print i
Step 6: compute i++ goto Step 4
Step 7: stop
----
* When an algorithm get coded in a specified programming language such as C, C++ or Java, it becomes a program that can be executed on a computer.
* Multiple algorithm can exist to solve the same problem or complete the the same task.
* The appropriate algorithm can be determined based on an number of factors:
+
1. How long the algorithm takes to run
2. What resources are required to execute the algorithm
3. How much space or memory is required.
4. How exact is the solution provided by the algorithm.

=== Searching

Searching is the process of finding an element in a list of values.

It is the algorithmic process of finding a particular element in a collection of elements.

1. Linear Search
+
Definition:
+
It starts at the beginning of the list and checks each element of the list.
+
i.e. It sequentially checks each element of the list until a match is found or the whole list has been searched.
So it is called sequential search.

*Example:*
* Let the elements are: 10, 6, 3, 8, 9, 12, 14
* The search element is 12
* Now it compares 12 with each and every element.
* The 12 is available at the 6th position.
* So the searching process is success and element is found.

*Algorithm:*
Step 1: Read elements in array
Step 2: Read the element to be searched
Step 3: Compare the element with each element of the array sequentially
Step 4: If match is found then the search is success
Step 5: If match is not found then the search is unsuccess.

*Program*
include:include::/programs/ds/linear_search.c[]

2. Binary Search
+
Definition:
+
Binary search is the most popular search algorithm. 
It is efficient and also one of the most commonly used techniques that are used to solve problems.

Binary search sorts the records either in ascending or descending order to gain much better performance than linear search.

Now suppose we have an ascending order record. At the time of search it takes the middle record/element, if the searching element is greater than middle element then the element must be located in the second part else it is in the first half. 
In this way this search algorithm divides the records into two parts in each iteration and thus called binary search.

*Example:*
* Let the elements in ascending order are: 2, 4, 6, 8, 10, 12, 15
* The search element is 12
* For searching it compare first middle element.
* The middle element is 8 and is not equal to 12. 
Since 12 is greater than 8 search on right side part of 8. 
12 is equal to right side part middle. 
So element is found.

*Algorithm:*
Step 1: Read sorted elements in array
Step 2: Read the element to be searched
Step 3: Compare the element to search and middle element in array. 
Step 4:If search element is greater than middle element then search in right side of middle element otherwise search on left.
Step 5: This process is repeated for all elements in array. 
If not match is found upto the end then the search is not success.

*Program*
include:include::/programs/ds/binary_search.c[]

3. Fibonacci Search

* Fibonacci search uses Fibonacci numbers to find the element in the sorted array.
* Fibonacci numbers are: 0, 1, 1, 2, 3, 5, 8...
* Fibonacci series generates the subsequent number by adding two previous numbers.
* For example:
Let the elements are give by:
10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100
arr[] = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100}
* Fibonacci numbers are: 0, 1, 1, 2, 3, 5, 8, 13, 21...
Target element x is 85. 
Length of array n = 11.
* Find the smallest Fibonacci number greater than or equal to 11 is 13.
* As per our step, a=5, b=8, c=a+b=13.
* Let offset = -1
* First compute i = min (offset+a, n-1)



=== Sorting

Sorting is a process of placing a list of elements from a collection of dats in some order.

It is nothing but storage of data in sorted order. 
Sorting can be done in ascending or descending order. 
It arranges the data in a sequence which makes searching easier.

==== Insertion Sort
+
* In this sorting technique first elements are stored in an array.
* The process of sorting starts with second element.
* First the second element is picked and is placed in specified order. 
Next third element is picked and is placed in specified order. 
Similarly the fourth, fifth, ...nth element is placed in specified order.
* Finally we get the sorting elements.

*Example*
+
Let us consider the elements of an array: 12, 3, 1, 5, 8
+
1. Checking second element of array with element before it and inserting it in proper position. 
In this case 3 is inserted in position of 12.
+
image::insertion_sort-1.png[]
2. Checking third element of array with elements before it and inserting it in proper position. 
In this case 3 is inserted in position 12.
+
image::insertion_sort-2.png[]
3. Checking fourth element of array with elements before it and inserting it in proper position. 
In this case 5 is inserted in position of 12.
+
image::insertion_sort-3.png[]
4. Checking fifth element of array with elements before it and inserting it in proper position. 
In this case 8 is inserted in position of 12.
+
image::insertion_sort-4.png[]
5. Sorted array in ascending order.
+
image::insertion_sort-5.png[]

*Algorithm*
+
Step 1: Check second element of array with element before it and insert it in proper position.
Step 2: Checking third element of array with element before it and inserting it in proper position.
Step 3: Repeat this till all elements are checked.
Step 4: Stop

*Program*
include::/programs/ds/insertion_sort.c

==== Selection Sort

Selection sort is an algorithm that selects the smallest element from an unsorted list in each iteration and places it at the beginning of the unsorted list.

.Example
image::selection_sort-1.png[]

* In first pass the first element is compared with all remaining elements and exchange element if first one is greater than second so that the smallest value is in first place. 
Leave this element.
* In second pass compare second element to all elements put the next smallest value, in second place. 
Leave this element. 
This process is repeated till all the elements are placed.
* Now we get the sorted elements.

*Algorithm*
+
Step 1: Set min to the first location.
Step 2: Search the minimum element in the array.
Step 3: Swap the first location with the minimum value in the array.
Step 4: Assign the second element as min.
Step 5: Repeat this process until we get a sorted array.

*Program*
include::/programs/ds/selection_sort.c

==== Exchange Sort

The exchange sort is almost similar as the bubble sort. 
The exchange sort compares each element of an array and swap those elements that are not in their proper position, just like a bubble sort does. 
The only difference between the two sorting algorithms is the manner in which they compare the elements.

==== Bubble Sort

Bubble sort is based on the idea of repeatedly comparing pairs of adjacent elements and then swapping positions if they exist in the wrong order.

*Example*
+
The following figure shows the first pass of a bubble sort. 
In first pass the first element is compared with second and exchange element if first one is greater than second.
* Similarly second element is compared with third and exchange element if second one is greater than third.
* Repeat this so that at the end of first pass the largest element is in the last position. 
Leave this element.

image::bubble_sort.png[]

* In second pass compare up to before last place value and put the next largest value, that before last place. 
Leave this element.

* This process is repeated till all the elements are placed. 
Now we get the sorted elements.

*Algorithm*
+
Step 1: The first element is compared with second and exchange element if first one is greater than second.
Step 2: The second element is compared with third and exchange element if second one is greater than third.
Step 3: Repeat this so that at the end the largest value is in last place.
Step 4: Likewise sorting is repeated for all elements.

*Program*
include::/programs/ds/bubble_sort.c

==== Quick Sort

* Quick sort is also one of the exchange sort.
* In a quick sort we take pivot element, then we place all the smaller elements are on one side of pivot, and greater elements on other side of pivot.
* After partitioning we have pivot in the final position. 
After repeatedly partitioning, we get the sorted elements.

*Example*
* Let us consider the elements: 35, 50, 15, 25, 80, 20, 90, 45
* Let us consider the first element 35 as pivot or i. 
The last element 45 as j.
image::quick_sort-1.png[]
* 50 which is greater than pivot taken as i and 20 smaller than pivot taken as j.
image::quick_sort-2.png[]
* Now i is less than j so swap the elements in i and j.
image::quick_sort-3.png[]
* Find greater than 35 (80) is i and less than 35 (25) is j.
image::quick_sort-4.png[]
* Now i is not less than j. 
Swap 35 and j. 
So 35 comes at j place.
image::quick_sort-5.png[]
* Now 35 is in correct position.
* On left side and right side of 35 repeat the process. Consider on left side of 35
image::quick_sort-6.png[]
* Let 25 as pivot. 
The lesser of 25 that is 15 as j and there is no greater. 
So bring i after j. 
i > j so swap pivot and j.
image::quick_sort-7.png[]
* After swaping
image::quick_sort-8.png[]
* Now the left part is sorted. 
Consider right part.
image::quick_sort-9.png[]
* Here 80 as pivot. 
Greater than 80 is i and less than to 80 is j.
image::quick_sort-10.png[]
* Here i is less than j, so swap i and j elements.
image::quick_sort-11.png[]
* After swaping, the sorting elements are given by
image::quick_sort-12.png[]
* Now join all left part j and right part j to get the sorted elements.
image::quick_sort-13.png[]

*Algorithm*
+
Step 1: Let the first element taken as pivot.
Step 2: Find lesser of pivot say i and greater of pivot say j.
Step 3: if i is less than j then swap i and j elements. 
Repeat step 2.
Step 4: Repeat step 3 until i > j. 
Now swap j and pivot.
Step 5: Now the pivot element is in final position. 
Repeat the above procedure for left and right side of pivot elements until all elements are sorted.
Step 6: Stop

*Program*
include::/programs/ds/quick_sort.c

==== Distribution Sort or Radix Sort

Randix sort is one of the sorting algorithms used to sort a list integer numbers in ascending order or descending order.

* In randix sort algorithm, a list of integer numbers will be sorted based on the digits of individual numbers. 
Sorting is performed from least significant digit to the most significant digit.

* Randix sort algorithm requires the number of passes which are equal to the number of digits present in the largest number among the list of numbers.

* For example, if the largest number is a 3 digit number then that list is sorted with 3 passes.

*Example*
Consider the following list of unsorted integers:

82, 901, 100, 12, 150, 77, 55, 23

Step 1: Define 10 queues each represents a bucket for digits from 0 to 9.
image::randix-1.png[]
Step 2: Insert all the numbers of the list into respective queue based on the least significant digit (ones placed digit) of every number.
image::randix-2.png[]
Group all the numbers from queue 0 to 9 in the order they halved inserted & consider the list for next step as input list.
100, 150, 901, 82, 12, 23, 55, 77
Step 3: Insert all the numbers of the list into respective queue based on the next least significant digit (tens placed digit) of every number.
image::randix-3.png[]
Group all the numbers from queue 0 to 9 in the order they halved inserted & consider the list for next step as input list.
100, 901, 12, 23, 150, 55, 77, 82
Step 4: Insert all the numbers of the list into respective queue based on the next least significant digit (hundreds placed digit) of every number.
image::randix-4.png[]
Group all the numbers from queue 0 to 9 in the order they halved inserted & consider the list for next step as input list.
12, 23, 55, 77, 82, 100, 150, 901
List got sorted in the increasing order.

*Algorithm*
+
Step 1 - Define 10 queues each represents a bucket for digits from 0 to 9.
Step 2 - Consider the least significant digit of every number in the list which is to be sorted.
Step 3 - Insert each number into respective queue based on the least significant digit.
Step 4 - Group all the numbers from queue 0 to 9 in the order they have inserted into their respective queues.
Step 5 - Repeat from step 3 based on the next least significant digit.
Step 6 - Repeat from step 2 until all the numbers are grouped based on the most significant digit.

*Program*
include::/programs/ds/distribution_sort.c

==== Merge Sort

It divides input array into two halves, calls itself for the two halves and then sorted and merged that two halves.

*Example*

For example consider the array of elements: 38, 27, 43, 3, 9, 82, 10

Now the array is recursively divided into two halves till the size becomes one which is shown in the following figure.
image::merge_sort-1.png[]

Once the size becomes one, the merge process comes into action and starts merging with sorted array till the complete array is merged.
image::merge_sort-2.png[]

*Algorithm*
+
Step 1: If it is only one element in the list then it is already sorted.
Step 2: Divide the list recursively into two halves till the size becomes one.
Step 3: Once the size becomes 1, the merge process comes into action and starts merging with sorted array till the complete array is merged.
image::merge_sort-3.png[]

*Program*
include::/programs/ds/merge_sort.c


===== Time Complexity

O(n^2) means that for every insert, it takes n*n operations. i.e. 1 operation for 1 item, 4 operations for 2 items, 9 operations for 3 items.

.Comparison of Sorting Algorithms
[cols="1,1,1,1,1"]
|===
|Algorithm|Data Structure 3+^.^|Time Complexity

|
|
|Best
|Average
|Worst

|Quick sort
|Array
|O(n log n)
|O(n log n)
|O(n^2)

|Merge sort
|Array
|O(n log n)
|O(n log n)
|O(n log n)

|Bubble sort
|Array
|O(n)
|O(n^2)
|O(n^2)

|Insertion sort
|Array
|O(n)
|O(n^2)
|O(n^2)

|Selection sort
|Array
|O(n^2)
|O(n^2)
|O(n^2)
|===

== Linked Lists

=== Introduction

A linked list is a collection of data elements called nodes in which the linear representation is given by links from one node to the next node. 
A linked list does not store its elements in consecutive memory locations and the user can add any number of nodes to the list.

The elements in a linked list can be accessed only in a sequential manner. 
But like an array, insertions and deletions can be done at any point in the list in a constant time.

A linked list, in simple terms, is a linear collection of data elements. 
These data elements are called nodes. 
Linked list a data structure which in turn can be used to implement other data structures.

Thus, it acts as a building block to implement data structures like stacks, queues and their variations.

==== Basic Terminology

A linked list can be perceived as a train or a sequence of nodes in which each node contains one or more data fields and a pointer to the next node.
image::linked_lists.png[]

We can see a linked list in which every node contains two parts, an integer and a pointer to the next node. 
The last node will have no next node connected to it, so it will store a special value called `NULL`.

Since in a linked list, every node contains a pointer to another node which is of the same type, it is also called a self-referential data type.

Let us see how a linked list is maintained in the memory. 
When we traverse `DATA` and `NEXT` in this manner, we finally see that the linked list in the above example stores characters that when put together form the `HELLO`.

image::linked_list-memory.png[]

==== Linked List vs. Array

Both arrays and linked lists are a linear collection of data elements. 
But unlike an array, a linked list does not stores its nodes in consecutive memory locations. 
Another point of difference between an array and a linked list is that a linked list does not allow random access to data. 
Nodes in a linked list can be accessed only in a sequential manner.

Another advantage of a linked list over an array is that we can add any number of elements in the list. 
This is not possible in case of an array.

==== Memory Allocation and De-allocation for a Linked List

If we want to add a node to an already existing linked list in the memory, we first find free space in the memory and then use it to store the information.

Now, the question is which part of the memory is available and which part is occupied? 
When we delete a node from a linked list, then who changes the status of the memory occupied by it from occupied to available? 
The answer is the operating system.

The operating system scans through all the memory cells and marks those cells that are being used by some program. 
Then it collects all the cells which are not being used adds their address to the free pool, so that these cells can be reused by other programs. 
The process is called garbage collection.

=== Single Linked Lists

A singly linked list is the simplest type of linked list in which every node contains some data and a pointer to the next node of the same data type.

image::single_linked_lists.png[]

Traversing a linked list means accessing the nodes of the list in order to perform some processing on them. 
Remember a linked list always contains a pointer variable `START` which stores the address of the first node of the list. 
End of the list is marked by storing `NULL` or -1 in the `NEXT` field of the last node.

==== Operations

===== Traversing a Linked List

For traversing a linked list, we also make use of another pointer variable `PTR` which points to the node that is currently being accessed. 
Algorithm for traversing a linked list.

----
Step 1: [INITIALIZE] SET `PTR` to `START`
Step 2: Repeat Steps 3 & 4 [LOOP] WHILE `PTR` is not `NULL`
Step 3: [PROCESS] PROCESS `PTR` -> `DATA`
Step 4: [UPDATE] SET `PTR` to `NEXT`
Step 5: [TERMINATE] END
----

image::linked_lists.png[]

===== Searching for a value in a Linked List

Searching a linked list means to find a particular element in the linked list. 
So searching means finding whether a given value is present in the information part of the node or not. 
If it is present, the algorithm returns the address of the node that contains the value. 
However, if the search is unsuccessful, `POS` is set to `NULL` which indicates that `VAL` is not present in the linked list.

Consider the linked list shown below. 
If we have `VAL = 4`, then the flow of algorithm can be explained as shown in the figure.

image::linked_list-search.png[]

*Algorithm*
----
Step 1: [INITIALIZE] SET `PTR` to `START`
Step 2: Repeat Steps 3  [LOOP] WHILE `PTR` is not `NULL`
Step 3: [PROCESS]                       IF `PTR` -> `DATA` = `VAL`
        [UPDATE]                                SET `POS` to `PTR`
                                                GOTO Step 5
                                        ELSE
                                                SET `PTR` to `NEXT`
                                        [END OF IF]
                                [END OF LOOP]
Step 4: [UPDATE] SET `POS` to `NULL`
Step 4: [TERMINATE] EXIT
----

===== Inserting a new node in a Linked List

We will see how a new node is added into an existing linked list. 
We will take four cases and then see how insertion is done in each.

* Case 1: New node is inserted at the beginning
* Case 2: New node is inserted at the end
* Case 3: New node is inserted after given node
* Case 4: New node is inserted before given node

Let us first discuss an important term called `OVERFLOW`. 
Overflow is a condition that occurs when AVAIL = NULL or no free memory cell is present in the system. 
when this condition occurs, the program must give an appropriate message.

===== Case 1: New node is inserted at the beginning

Inserting a node at the beginning of a Linked List. 
Consider the linked list shown in the below figure. 
Suppose we want to add a new node with data 9 and add it as the first node of the list.

image::linked_list-insert-case1.png[]

*Algorithm*
----
Step 1: IF AVAIL = NULL
                [PROCESS] Write OVERFLOW
                [TERMINATE] GOTO Step 7
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET NEW_NODE -> NEXT = START
Step 6: SET START = NEW_NODE
Step 7: [TERMINATE] EXIT
----
===== Case 2: New node is inserted at the end
image::linked_list-insert-case2.png[]
*Algorithm*
----
Step 1: IF AVAIL = NULL
                [PROCESS] Write OVERFLOW
                [TERMINATE] GOTO Step 9
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET NEW_NODE -> NEXT = NULL
Step 6: SET PTR = START
Step 7: WHILE PTR -> NEXT != NULL
                [PROCESS] SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 8: SET PTR -> NEXT = NEW_NODE
Step 9: [TERMINATE] EXIT
----

===== Case 3: New node is inserted after given node
Consider the liked list shown in the below figure. 
Suppose we want to add a new node with value 9 after the node with value 3.
image::linked_list-insert-case3.png[]
*Algorithm*
----
Step 1: IF AVAIL = NULL
                [PROCESS] Write OVERFLOW
                [TERMINATE] GOTO Step 12
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET PTR = START
Step 6: SET PREPTR = PTR
Step 7: WHILE PREPTR -> DATA != NUM
Step 8:         [PROCESS] SET PREPTR = PTR
Step 9:         [PROCESS] SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 10: SET NEW_NODE -> NEXT = PREPTR -> NEXT
Step 11: SET PREPTR -> NEXT = NEW_NODE
Step 12: [TERMINATE] EXIT
----

===== Case 4: New node is inserted before given node

Consider the linked list shown in the below figure. 
Suppose we want to add a new node with value 9 before the node with value 3.
image::linked_list-insert-case4.png[]
*Algorithm*
----
Step 1: IF AVAIL = NULL
                [PROCESS] Write OVERFLOW
                [TERMINATE] GOTO Step 12
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET PTR = START
Step 6: SET PREPTR = PTR
Step 7: WHILE PTR -> DATA != NUM
Step 8:         [PROCESS] SET PREPTR = PTR
Step 9:         [PROCESS] SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 10: SET PREPTR -> NEXT = NEW_NODE
Step 11: SET NEW_NODE -> NEXT = PTR
Step 12: [TERMINATE] EXIT
----

==== Deleting a node from a Linked List

We will discuss how a node is deleted from an already existing linked list. 
We will consider 3 cases and then see how deletion is done in each case.

* Case 1: Delete the first node
* Case 2: Delete the last node
* Case 3: Delete a node after a given node

===== Case 1: Deleting a First Node from a Linked List
image::linked_list-delete-case1.png[]
*Algorithm*
----
Step 1: IF START = NULL
                [PROCESS] Write UNDERFLOW
                [TERMINATE] GOTO Step 5
        [END OF IF]
Step 2: SET PTR = START
Step 3: SET START = START -> NEXT
Step 4: FREE PTR
Step 5: [TERMINATE] EXIT
----

===== Case 2: Deleting the Last Node from a Linked List
image::linked_list-delete-case2_1.png[]
image::linked_list-delete-case2_2.png[]
*Algorithm*
----
Step 1: IF START = NULL
                [PROCESS] Write UNDERFLOW
                [TERMINATE] GOTO Step 8
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> NEXT != NULL
Step 4:         [PROCESS] SET PREPTR = PTR
Step 5:         [PROCESS] SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 6: SET PREPTR -> NEXT = NULL
Step 7: FREE PTR
Step 8: [TERMINATE] EXIT
----

===== Case 3: Deleting After a Given Node in a Linked List

Consider the linked list shown in the below figure. 
Suppose we want to delete the node that succeeds the node with value 4.
image::linked_list-delete-case3.png[]
*Algorithm*
----
Step 1: IF START = NULL
                [PROCESS] Write UNDERFLOW
                [TERMINATE] GOTO Step 
        [END OF IF]
Step 2: SET PTR = START
Step 3: SET PREPTR = PTR
Step 4: WHILE PREPTR -> DATA != NUM
Step 5:         [PROCESS] SET PREPTR = PTR
Step 6:         [PROCESS] SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 7: SET PREPTR -> NEXT = PTR -> NEXT
Step 8: FREE PTR
Step 9: [TERMINATE] EXIT
----

=== Reversing Single Linked Lists
todo::

=== Applications on Single Linked List

* Implementations of stacks and queues.
* Implementation of graphs: Adjacency list representation of graphs is most popular which uses linked list to store adjacent vertices.
* Dynamic memory allocation: we use linked list of free blocks.
* Maintaining directory of names. 
Performing arithmetic operations on long integers.
* Manipulation of polynomials by storing constants in the nodes of a linked list. 
Representing sparse matrices.

==== Polynomial Expression Representation

A polynomial is composed of different terms where each of them holds a coefficient and an exponent. 
An essential characteristic of the polynomial is that each term in the polynomial expression consists of two parts: one is the coefficient and other is the exponent.

*Example*
10x^2 + 26x, here 10 and 26 are coefficients and 2, 1 are its exponential values.
image::polynomial.png[]

===== Addition of two polynomials

----
Input:
        poly1 = 5x^2 + 4x^1 + 2x^0
        poly2 = 5x^1 + 5x^0
Output:
        Sum = 5x^2 + 9x^1 + 7x^0

Input:
        poly2 = 5x^3 + 4x^2 + 2x^0
        poly2 = 5x^1 + 5x^0
Output:
        Sum = 5x^3 + 4x^2 + 5x^1 + 7x^0
----

image::poly-addition.png[]

===== Multiplication of two polynomials

----
Input:
        poly1 = 3x^2 + 5x^1 + 6
        poly2 = 6x^1 + 8
Output: 
        Product = 18x^3 + 54x^2 + 76x^1 + 48
On multiplying each element of poly1 with elements of poly2, we get:
        18x^3 + 30x^2 + 36x^1 + 24x^2 + 40x^1 + 48
        On adding values with same power of x, we get:
        18x^3 + 54x^2 + 76x^1 + 48

Input:
        poly1 = 3x^3 + 6x^1 + 9
        poly2 = 9x^3 + 8x^2 + 7x^1 + 2
Output: 
        Product = 27x^6 + 24x^5 + 75x^4 + 135x^3 + 114x^2 + 75x^1 + 18
----
image::poly-multiplication.png[]

==== Sparse Matrix Representation using Linked List

A matrix is a two-dimensional data object made of m rows and n columns, therefore having total m x n elements. 
If most of the elements of the matrix have 0 value, then it is called a sparse matrix.

Example:
0 0 3 0 4
0 0 5 7 0
0 0 0 0 0
0 2 6 0 0

===== Sparse Matrix Representation using arrays

Method 1: Using Arrays
2D array is used to represent a sparse matrix in which there are 3 rows named as
Row: Index of row, where non-zero element is located.
Column: Index of column, where non-zero element is located.
Value: Value of non-zero element located at index - (row, column)

image::sparse-matrix-array.png[]

===== Sparse Matrix Representation using Linked List

Method 2: Using Linked List
In linked list, each node has four fields:
Row: Index of row, where non-zero element is located.
Column: Index of column, where non-zero element is located.
Value: Value of non-zero element located at index - (row, column)
Next node: Address of the next node.

image::sparse-matrix-linked-list.png[]

==== Advantages of Single Linked list

* Insertion and deletions can be done easily
* It does not need movement of elements for insertion and deletion
* Space is not wasted as we can get space according to our requirements.
* Its size is not fixed. 
It can be extended or reduced according to requirements.
* Elements may or may not be stored in consecutive memory available, even then we can store the data in computer.
* It is less expensive.

==== Disadvantages of Single Linked list

* It requires more space as pointers are also stored with information.
* Different amount of time is required to access each element.
* If we have to go to a particular element the we have to go through all those elements that come before it.
* We cannot traverse it from last and only from the beginning.
* It is not easy to sort the elements stored in the linear linked list.

=== Doubly Linked Lists

A doubly linked list or a two-way linked list is a more complex type of linked list which contains a pointer to next as well as the previous node in the sequence.

Therefore, it consists of 3 parts - data, a pointer to the next node and a pointer to the previous node.

image::doubly-linked_list.png[]


A doubly linked list provides the ease to manipulate the elements in the list as it maintains pointers to nodes in both the directions (forward and backward).

The main advantage of using a doubly linked list is that it makes searching twice as efficient.

Let us view how a doubly linked list is maintained in the memory.
image::doubly-linked_list-memory.png[]

==== Inserting a New Node in a Doubly Linked List

In this section, we will discuss how a new node is added into an already existing doubly linked list. 
We will take four cases and then see how insertion is done in each case.

* Case 1: The new node is inserted at the beginning
* Case 2: The new node is inserted at the end
* Case 3: The new node is inserted after a given node
* Case 4: The new node is inserted before a given node

===== Case 1: Inserting a Node at the Beginning of a Doubly Linked List

image::doubly-linked_list-insert-case1_1.png[]
image::doubly-linked_list-insert-case1_2.png[]

*Algorithm*
+
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step 9
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET NEW_NODE -> PREV = NULL
Step 6: SET NEW_NODE -> NEXT = START
Step 7: SET START -> PREV = NEW_NODE
Step 8: SET START = NEW_NODE
Step 9: EXIT
----

===== Case 2: Inserting a Node at the end of a Doubly Linked List

image::doubly-linked_list-insert-case2.png[]
*Algorithm*
+
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET NEW_NODE -> NEXT = NULL
Step 6: SET PTR = START
Step 7: WHILE PTR -> NEXT != NULL
Step 8:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 9: SET PTR -> NEXT = NEW_NODE
Step 10: SET NEW_NODE -> PREV = PTR
Step 11: EXIT
----

===== Case 3: Inserting a Node After a Given Node in a Doubly Linked List
image::doubly-linked_list-insert-case3.png[]
*Algorithm*
+
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step 12
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET PTR = START
Step 6: WHILE PTR -> DATA != NUM
Step 7:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 8: SET NEW_NODE -> NEXT = PTR -> NEXT
Step 9: SET NEW_NODE -> PREV = PTR
Step 10: SET PTR -> NEXT -> PREV = NEW_NODE
Step 11: SET PTR -> NEXT = NEW_NODE
Step 12: EXIT
----

===== Case 4: Inserting a Node Before a Given Node in a Doubly Linked List
image::doubly-linked_list-insert-case4.png[]
*Algorithm*
+
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step 12
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET PTR = START
Step 6: WHILE PTR -> DATA != NUM
Step 7:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 8: SET NEW_NODE -> NEXT = PTR
Step 9: SET NEW_NODE -> PREV = PTR -> PREV
Step 10: SET PTR -> PREV = NEW_NODE
Step 11: SET PTR -> PREV -> NEXT = NEW_NODE
Step 12: EXIT
----

==== Deleting a Node from a Doubly Linked List

In this section, we will see how a node is deleted from an already existing doubly linked list. 
We will take four cases and then see how deletion is done in each case.

* Case 1: The first node is deleted
* Case 2: The last node is deleted
* Case 3: The node after a given node is deleted
* Case 4: The node before a given node is deleted

===== Case 1: Deleting the First Node from a Doubly Linked List

image::doubly-linked_list-delete-case1.png[]
*Algorithm*
+
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 6
        [END OF IF]
Step 2: SET PTR = START
Step 3: SET START = START -> NEXT
Step 4: SET START -> PREV = NULL
Step 5: FREE PTR
Step 6: EXIT
----

===== Case 2: Deleting the Last Node from a Doubly Linked List

image::doubly-linked_list-delete-case2_1.png[]
image::doubly-linked_list-delete-case2_2.png[]
*Algorithm*
+
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 6
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> NEXT != NULL
Step 4:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 5: SET PRT -> PREV -> NEXT = NULL
Step 6: FREE PTR
Step 7: EXIT
----

===== Case 3: Deleting the Node After a Given Node in a Doubly Linked List

image::doubly-linked_list-delete-case3.png[]
*Algorithm*
+
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 9
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> DATA != NUM
Step 4:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 5: SET TEMP = PTR -> NEXT
Step 6: SET PTR -> NEXT = TEMP -> NEXT
Step 7: SET TEMP -> NEXT -> PREV = PTR
Step 8: FREE TEMP
Step 9: EXIT
----

===== Case 4: Deleting the Node Before a Given Node in a Doubly Linked List

image::doubly-linked_list-delete-case4.png[]
*Algorithm*
+
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 9
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> DATA != NUM
Step 4:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 5: SET TEMP = PTR -> PREV
Step 6: SET TEMP -> PREV -> NEXT = PTR
Step 7: SET PTR -> PREV = TEMP -> PREV
Step 8: FREE TEMP
Step 9: EXIT
----

=== Circular Linked Lists

In a circular linked list, the last node contains a pointer to the first node of the list. 
We can have a circular singly linked list as well as a circular doubly linked list.

While traversing a circular linked list, we can begin at any node and traverse the list in any direction, forward or backward, until we reach the same node where we started. 
Thus a circular linked list has no beginning or no ending.

Note that there are no NULL values in the NEXT part of any of the nodes of list.

==== Operation

===== Inserting a New Node in a Circular Linked List

In this section, we will see how a new node is added into an already existing linked list. 
We will take two cases and then see how insertion is done in each case.

* Case 1: The new node is inserted at the beginning of the circular linked list
* Case 2: The new node is inserted at the end of the circular linked list

====== Case 1: Inserting a Node at the Beginning of a Circular Linked List

image::circular-linked_list-insert-before-1.png[]
image::circular-linked_list-insert-before-2.png[]
*Algorithm*
+
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step 11
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET PTR = START
Step 6: WHILE PTR -> NEXT != START
Step 7:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 8: SET NEW_NODE -> NEXT = START
Step 9: SET PTR -> NEXT = NEW_NODE
Step 10: SET START = NEW_NODE
Step 11: EXIT
----

====== Case 2: Inserting a Node at the End of a Circular Linked List

image::circular-linked_list-insert-end-1.png[]
image::circular-linked_list-insert-end-2.png[]
*Algorithm*
+
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step 10
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET NEW_NODE -> NEXT = START
Step 6: SET PTR = START
Step 7: WHILE PTR -> NEXT != START
Step 8:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 9: SET PTR -> NEXT = NEW_NODE
Step 10: EXIT
----

===== Deleting a Node from a Circular Linked List

In this section, we will discuss how a node is deleted from an already existing circular linked list. 
We will take 2 cases and then see how deletion is done in each case. 
Rest of the cases of deletion are same as that given for singly linked lists.

* Case 1: The first node is deleted
* Case 2: The last node is deleted

===== Case 1: Deleting the First Node from a Circular Linked List

image::circular-linked_list-delete-first.png[]
+
*Algorithm*
+
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 8
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> NEXT != START
Step 4:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 5: SET PTR -> NEXT = START -> NEXT
Step 6: FREE START
Step 7: SET START = PTR -> NEXT
Step 8: EXIT
----

===== Case 2: Deleting the Last Node from a Circular Linked List

image::circular-linked_list-delete-last.png[]
+
*Algorithm*
+
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 8
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> NEXT != START
Step 4:         SET PREPTR = PTR
Step 5:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 6: SET PREPTR -> NEXT = START
Step 7: FREE PTR
Step 8: EXIT
----

== Queues & Stacks

=== Queues

==== Introduction to Queues

Let us explain the concept of queues using the analogies given below.

* People moving on an escalator. 
The people who got on the escalator first will be the first one to step out of it.
* People waiting for a bus. 
The first person standing in the line will be the first to get into the bus.
* People standing outside the ticketing window of a cinema hall. 
The first person in the line will get the ticket first and thus will be the first one to move out of it.
* Luggage kept on conveyor belts. 
The bag which was placed first will be the first to come out at the other end.
* Cars lined at a toll bridge. 
The first car to reach the bridge will be the first to leave.

In all these examples, we see that the element at the first position is served first. 
Same is the case with queue data structure. 
A queue is FIFO (First In First Out) data structure in which the element that is inserted first is the first one to be taken out. 
The elements in a queue are added at one end called the `REAR` and removed from the other end called the `FRONT`. 
Queues can be implemented by using either array or linked list. 
In this section we will see how queues are implemented using each of these data structures.

==== Array Representation and Implementation of Queues

Queues can be easily represented using linear arrays. 
As stated earlier, every queue has front and rear variables that point to the position from where deletions and insertions can be done, respectively.

The array representation of a queue is shown in Fig. 3.1.

image::queues-array.png[]

===== Operations on Queues

In Fig.3.1, FRONT = 0 and REAR = 5. 
Suppose we want to add another element with value 45, the REAR would be incremented by 1 and the value would be stored at the position pointed by REAR.

The queue after addition would be as shown in Fig. 3.2. 
Here, FRONT = 0 and REAR = 6. 
Every time  new element has to be added, we repeat the same procedure.

If we want to delete an element from the queue, then the value of FRONT will be incremented. 
Deletions are done from only this end of the queue.      
The queue after deletion would be as shown in Fig. 3.3. 
Here, FRONT = 1 and REAR = 6.

However, before inserting an element in a queue, we must check for overflow conditions. 
An overflow will occur when we try to insert an element into a queue that is already full. 
When REAR = MAX - 1, where MAX is the size of the queue, then we have an overflow condition. 
Note that we have written MAX -1 because the index starts from 0. 
Similarly, before deleting an element from a queue, we must check for underflow conditions. 
An underflow condition occurs when we try to delete an element from a queue that is already empty. 
If FRONT = -1 and REAR = -1, it means there is no element in the queue.

* Algorithm for Insertion in Queues*
+
----
Step 1: IF REAR = MAX - 1
                Write OVERFLOW
                GOTO Step 4
        [END OF IF]
Step 2: IF FRONT = -1 and REAR = -1
                SET FRONT = REAR = 0
        ELSE
                SET REAR = REAR + 1
        [END OF IF]
Step 3: SET QUEUE[REAR] = NUM
Step 4: EXIT
----

* Algorithm for Deletion in Queues*
+
----
Step 1: IF FRONT = -1 and FRONT > REAR
                Write UNDERFLOW
        ELSE
                SET VAL = QUEUE[FRONT]
                SET FRONT = FRONT + 1
        [END OF IF]
Step 2: EXIT
----

Note: The process of inserting an element in the queue is called enqueue and the process of deleting an element from the queue is called dequeue.

==== Linked List Representation and Implementation of Queues

We have seen how a queue is created using an array. 
Although this technique of creating queue is easy, its drawback is that the array must be declared to have some fixed size. 
If we allocate space for 50 elements in the queue and it hardly uses 20-25 locations, then half of the space will be wasted.

And in case we allocate less memory locations for a queue that might end up growing large and large, then a lot of re-allocations will have to be done, thereby creating a lot of overhead and consuming a lot of time.

In case the queue is a very small one or its maximum size is known in advance, then the array implementation of the queue gives an efficient implementation, 
But if the array size cannot be determined in advance, the other alternative i.e., the linked representation.

The storage requirement of linked representation of a queue with n elements is O(n) and the typical time requirement for operations is O(1).

In a linked queue, every element has two parts, one that stores the data and another that stores the address of the next element. 
The `START` pointer of the linked list is used as `FRONT`. 
Here we will also use another pointer called `REAR`, which will store the address of the last element in the queue.

All insertions will be done at the rear end and all the deletions will be done at the front end. 
If `FRONT` = `REAR` = `NULL`, then it indicates that the queue is empty. 
The linked representation of a queue is shown in Fig.3.4.


===== Insert Operation

The insert operation is used to insert an element into a queue. 
The new element is added as the last element of the queue. 
Consider the linked queue shown in Fig.3.5.
image::queue-linked_list-insert.png[]

To insert an element with value 9, we first check if `FRONT == NULL`. 
If the condition holds, then the queue is empty. 
So, we allocate memory for a new node, store the value in its data part and `NULL` in its next part. 
The new node will then be called both `FRONT` and `REAR`. 
However, if `FRONT != NULL`, then we will insert the new node at the `REAR` end of the linked queue and name this new node as `REAR`. 
Thus the updated queue becomes as shown in Fig.3.6.

.Algorithm to insert an element in a linked queue
----
Step 1: Allocate memory for the new node and name it as PTR
Step 2: SET PTR -> DATA = VAL
Step 3: IF FRONT = NULL
                SET = FRONT = REAR = PTR
                SET FRONT -> NEXT = REAR -> NEXT = NULL
        ELSE
                SET REAR -> NEXT = PTR
                SET REAR = PTR
                SET REAR -> NEXT = NULL
        [END OF IF]
Step 4: END
----

The algorithm shows that inserting an element in a linked queue. 
In step 1, the memory is allocated for the new node. 
In step 2, the `DATA` part of the new node is initialize with the value to be stored in the node. 
In step 3, we check if the new node is the first node of the linked queue. 
This is done by checking if `FRONT = NULL`. 
If this is the case, then the new node is tagged as `FRONT` as well as `REAR`. 
Also `NULL` is stored in the `NEXT` part of the node. 
However, if the new node is not the first node in the list, then it is added at the `REAR` end of the linked queue (or the last node of the queue).

===== Delete Operation

The delete operation is used to delete the element that is first inserted in a queue, i.e., the element whose address is stored in `FRONT`. 
However, for deleting the value, we must first check if `FRONT == NULL` because if this is the case, then the queue is empty and no more deletions can be done. 
If an attempt is made to delete a value from a queue that is already empty, an underflow message is printed. 
Consider the queue shown in Fig.3.7
image::queue-linked_list-delete.png[]

.Algorithm to delete an element in a linked queue
----
Step 1: IF FRONT = NULL
                Write "Underflow"
                Go to Step 5
        [END OF IF]
Step 2: SET PTR = FRONT
Step 3: SET FRONT = FRONT -> NEXT
Step 4: FREE PTR
Step 5: END
----

==== Applications of Queues

* Queues are widely used as waiting lists for a single shared resource like printer, disk, CPU
* Queues are used to transfer data asynchronously (data  not necessarily received at same rate as sent) between two processes (IO buffers), e.g., pipes, file IO, sockets.
* Queues are used as buffers on MP3 players and portable CD players, iPod playlist.
* Queues are used in playlist for jukebox to add songs to the end, play from the front of the list.
* Queues are used in operating system for handling interrupts. 
When programming a real-time system that can interrupted, for example, by a mouse click, it is necessary to process the interrupts immediately, before proceeding with the current job. 
If the interrupts have to be handled in the order of arrival, then a FIFO queue is the appropriate data structure.

==== Types of Queues

A queue data structure can be classified into the following types:
1. Circular Queue
2. Deque
3. Priority Queue
4. Multiple Queue

We will discuss each of these in detail in the following sections.

===== Circular Queues

In linear queues, we have discussed so far that insertions can be done only at one end called the `REAR` and deletions are always done from the other end called the `FRONT`. 
Look at the queue shown in Fig.3.9.

image::queue-linear.png[]

Here, FRONT = 0 and REAR = 9

Now, if you want to insert another value, it will not be possible because the queue is completely full. 
There is no empty space where the value can be inserted. 
Consider a scenario in which two successive deletions are made. 
The queue will then be given as shown in Fig.3.10.

image::queue-linear-deletions.png[]

Here, FRONT = 2 and REAR = 9

Suppose we want to insert a new element in the queue shown in Fig.3.10. 
Even though there is space available, the overflow condition still exists because the condition `REAR = MAX -1` still holds true. 
This is a major drawback of a linear queue.

To resolve this problem, we have two solutions. 
First, shift the elements to the left so that the vacant space can be occupied and utilized efficiently. 
But this can be very time-consuming, especially when the queue is quite large.

The second option is to use a circular queue. 
In the circular queue, the index comes right after the last index. 
Conceptually, you can think of a circular queue as shown in Fig.3.11.

image::queue-circualr.png[]

The circular queue will be full only when `FRONT = 0` and `REAR = Max -1`. 
A circular queue is implemented in the same manner as a linear queue is implemented. 
The only difference will be in the code that performs insertion and deletion operations.

===== Insertion

For insertion, we now have to check for the following 3 conditions:
* If `FRONT = 0` and `REAR = MAX - 1`, then the circular queue if full. 
Look at the queue given in Fig.3.12 which illustrates this point.
* If `REAR != MAX - 1`, then `REAR` will be incremented and the value will be inserted as illustrated in Fig.3.13.
* If `FRONT != 0` and `REAR = MAX - 1`, then it means that the queue is not full. 
So, set `REAR = 0` and insert the new element there, as shown in Fig.3.14.

image::queue-circular-inset.png[]

*Algorithm*
+
----
Step 1: IF FRONT = 0 and REAR = MAX -1
                Write "Overflow"
                GOTO step 4
        [END OF IF]
Step 2: IF FRONT = -1 and REAR = -1
                SET FRONT = REAR = 0
        ELSE IF REAR = MAX - 1 and FRONT != 0
                SET REAR = 0
        ELSE
                SET REAR = REAR + 1
        [END OF IF]
Step 3: SET QUEUE[REAR] = VAL
Step 4: EXIT
----

Let us look at the algorithm to insert an element in a circular queue. 
In step 1, we check for the overflow condition. 
In step 2, we make two checks. 
First to see if the queue is empty, and second to see if the `REAR` end has already reached the maximum capacity while there are certain free locations before the `FRONT` end. 
In step 3, the value is stored in the queue at the location pointed by `REAR`.

===== Deletion

Let us now discuss how deletions are performed in this case. 
To delete an element, again we check for 3 conditions.

* Look at Fig.3.15. 
If `FRONT = -1`, then there are no elements in the queue. 
So, an underflow condition will be reported.
* If the queue is not empty and `FRONT = REAR`, then after deleting the element at the front the queue becomes empty and so `FRONT` and `REAR` are set to -1. 
This is illustrated in Fig.3.16.
* If the queue is not empty and `FRONT = MAX - 1`, then after deleting the element at the `FRONT`, `FRONT` is set to 0. 
This is shown in Fig.3.17.

image::queue-circular-delete.png[]

*Algorithm*
+
----
Step 1: IF FRONT = -1
                Write "Underflow"
                GOTO step 4
        [END OF IF]
Step 2: SET VAL = QUEUE[FRONT]
Step 3: IF FRONT = REAR
                SET FRONT = REAR = -1
        ELSE
                IF FRONT = MAX - 1
                        SET FRONT = 0
                ELSE
                        SET FRONT = FRONT + 1
                [END OF IF]
        [END OF IF]
Step 4: Exit
----

Let us look at the algorithm to delete an element form a circular queue. 
In step 1, we check for the underflow condition. 
In step 2, the value of the queue at the location point by `FRONT` is stored in VAL. 
In step 3, we make 2 checks. 
First to see if the queue has become empty after deletion and 
second to see if `FRONT` has reached the maximum capacity of the queue. 
The value of `FRONT` is then updated based on the outcome of these checks.

===== Deques

A deque (pronounced as 'deck' or 'dequeue') is a list in which the elements can be inserted or deleted at either end. 
It is also known as a head-tail linked list because elements can be added to or removed from either the front (head) or the back (tail) end.

However, no element can be added and deleted from the middle. 
In the computer's memory, a deque is implemented using either a circular array or a circular doubly linked list.

In a deque, two pointers are maintained, LEFT and RIGHT, which point to either end of the dequeue. 
The elements in a deque extend from the LEFT end to the RIGHT end and since it is circular, Dequeue[N-1] is followed by Dequeue[0].
Consider the deques shown in Fig.3.18

image::queue-dequeue.png[]

There are 2 variants of a double-ended queue. 
They include
* `Input restricted deque`. In this dequeue, insertions can be done only at one of the ends, while deletions can be done from both ends.
* `Output restricted deque`. In this dequeue, deletions can be done only at one of the ends, while insertions can be done from both ends.

===== Priority Queues

A priority queue is a data structure in which each element is assigned a priority. 
The priority of the element will be used to determine the order in which the elements will be processed. 
The general rules of processing the elements of a priority queue are
* An element with higher priority is processed before an element with a lower priority.
* 2 elements with the same priority are processed on the first-come-first-served (FCFS) basis.

A priority queue can be thought of as a modified queue in which when an element has to be removed from the queue, the one with the highest-priority is retrieved first. 
The priority of the element can be set based on various factors. 
Priority queues are widely used in operation systems to execute the highest priority process first. 
The priority of the process may be set based on the CPU time it requires to get executed completely.

====== Implementation of a Priority Queue

There are 2 ways to implement a priority queue. 
We can either use a sorted list to store the elements so that when an element has to taken out, the queue will not have to be searched for the element with the highest priority or we can use an unsorted list so that insertions are always done at the end of the list.

Every time when an element has to be removed from the list, the element with the highest priority will be searched and removed. 
While a sorted list takes O(n) time to insert an element in the list, it takes only O(1) time to delete an element. 
On the contrary, an unsorted list will take O(1) time to insert an element and O(n) time to delete and element from the list.

Practically, both these techniques are inefficient and usually a blend of these two approaches is adopted that takes roughly O(log n) time or less.

===== Multiple Queues

When we implement a queue using an array, the size of the array must be known in advance. 
If the queue is allocated less space, then frequent overflow conditions will be encountered.

To deal with this problem, the code will have to be modified to reallocate more space for the array. 
In case we allocate a large amount of space for the queue, it will result in sheer wastage of memory.

Thus, there lies a tradeoff between the frequency of overflows and the space allocated. 
So a better solution to deal with this problem is to have multiple queues or to have more than one queue in the same array of sufficient size. 
Fig.3.19 illustrates this concept.

image::queue-multiple-queues.png[]

In the figure, an array Queue[n] is used to represent 2 queues, Queue A and Queue B. 
The value of n is such that the combined size of both the queues will never exceed n. 
While operating on these queues, it is important to note one thing, Queue A will grow from left to right, 
whereas Queue B will grow from right to left at the same time. 
Extending the concept to multiple queues, a queue can also be used to represent n number of queues in the same array. 
That is, if we have a QUEUE[n], then each queue will be allocated an equal amount of space bounded by indices b[i] and e[i]. 
This is shown in Fig.3.20.

=== Stacks

==== Introduction to Stacks

Stack is an important data structure which stores its elements in an ordered manner. 
We will explain the concept of stacks using an analogy. 
You must have seen a pile of plates where one plate is placed on top of another as shown in Fig.3.21.

Now, when you want to remove a plate, you remove the topmost plate first. 
Hence, you can add and remove an element (i.e. a plate) only at/from on position whish is topmost position.

image::stack-plates.png[]

A stack is a linear data structure which uses the same principle, i.e. the elements in a stack are added and removed only from one end, which is called `TOP`.

Hence, a stack is called LIFO (Last-In-First-Out) data structure, as the element that was inserted last is the first one to be taken out.

==== Array Representation of Stacks

In the computer's memory, stacks can be represented as a linear array. 
Every stack has a variable called `TOP` associated with it, which is used to store the address of the topmost element of the stack. 
It is this position where the element will be added to or deleted from.

The is another variable called `MAX`, which is used to store the maximum number of elements that the stack can hold. 
If `TOP = NULL`, then it indicates that the stack is empty and if `TOP = MAX -1`, then the stack is full. 
You must be wondering why we have written MAX-1. 
It is because array indices start from 0. 
Look at fig.3.22.

image::stack-1.png[]

=== Operations on Stacks

A stack supports 3 basic operations:
1. push
2. pop
3. peek

The `push` operation add an element to top of the stack and 
the `pop` operation removes an element from top of stack. 
The `peek` operation returns the value of the topmost element of the stack.

==== Push Operation

* The `push` operation is used to insert an element into the stack.
* The new element is added at the topmost position of the stack.
* To insert an element with value 6, we first check if `TOP = MAX - 1`.
* If the condition is false, then we increment the value of `TOP` and store the new element at the position given by stack[TOP].

image::stack-push.png[]

.Algorithm stack push
----
Step 1: IF TOP = MAX - 1
                PRINT "OVERFLOW"
                GOTO step 4
        [END OF IF]
Step 2: SET TOP = TOP + 1
Step 3: SET STACK[TOP] = VALUE
Step 4: END
----

==== Pop Operation

* The `pop` operation is used to delete the topmost element from the stack.
* However, before deleting the value, we must first check if `TOP = NULL` because if that is the case, then it means the stack is empty and no more deletions can be done.
* To delete the topmost element, we first check if `TOP = NULL`. 
IF the condition is false, then we decrement the value pointed by `TOP`.

image::stack-pop.png[]

.Algorithm Stack POP
----
Step 1: IF TOP = NULL
                PRINT "UNDERFLOW"
                GOTO Step 4
        [END OF IF]
Step 2: SET VAL = STACK[TOP]
Step 3: SET TOP = TOP - 1
Step 4: END
----

==== Peek Operation

* Peek is an operation that returns the value of the topmost element of the stack without deleting it from the stack.
* However, the peek operation first checks if the stack is empty, i.e. if TOP = NULL, then an appropriate message is printed, else the value is returned.
* Here, the peek operation will return 5, s it is the value of the topmost element of the stack.

.Algorithm Stack Peek
----
Step 1: IF TOP = NULL
                PRINT "STACK IS EMPTY"
                GOTO Step 3
Step 2: RETURN STACK[TOP]
Step 3: END
----

*EXAMPLE*:
image::stack-example.png[]

=== Linked Representation of Stacks

We have seen how a stack is created using an array. 
This technique of creating a stack is easy, but the drawback is that the array must be declared to have some fixed size. 
In case the stack is very small one or its maximum size is known in advance, then the array implementation of the stack gives an efficient implementation. 
But if the array size cannot be determined in advance, then the other alternative, i.e. linked representation, is used.

The storage requirement of linked representation of the stack with `n` elements is O(n), and the typical time requirement for the operation is O(1).

In a linked stack, every node has 2 parts - 
one that stores data and another that stores the address of the next node. 
The `START` pointer of the linked list is used as `TOP`. 
All insertions and deletions are done at the node pointed by `TOP`. 
If `TOP = NULL`, then it indicates that the stack is empty. 
The linked representation of a stack is shown in below figure.

image::stack-linked_list.png[]

==== Push Operation

The push operation is used to insert an element into the stack. 
The new element is added at the topmost position of the stack. 
Consider the linked stack shown in below figure.
image::stack-linked_list-pop-1.png[]

To insert an element with value 9, 
we first check if `TOP = NULL`. 
If this is the case, then we allocate memory for a new node, store the value in its `DATA` part and `NULL` in its `NEXT` part. 
The new node will then be called `TOP`. 
However, if `TOP != NULL`, then we insert the new node at the beginning of the linked stack and name this new node as `TOP`.
image::stack-linked_list-pop-2.png[]

The algorithm to push an element into a linked stack. 
In step 1, memory is allocated for the new node. 
In step 2, the DATA part of the new node is initialized with the value to be stored in the node. 
In step 3, we check if the new node is the first node of the linked list, is done by checking if TOP = NULL. 
In case the IF statement evaluates to true, then NULL is stored in the NEXT part of the node and new node is called `TOP`.

However, if the new node is not the first node in the list, then it is added before the first node of the list (i.e., the `TOP` node) and termed as `TOP`.

.Algorithm Stack Linked Push
----
Step 1: Allocate memory for the new node and name it as NEW_NODE
Step 2: SET NEW_NODE -> DATA = VAL
Step 3: IF TOP = NULL
                SET NEW_NODE -> NEXT = NULL
                SET TOP = NEW_NODE
        ELSE
                SET NEW_NODE -> NEXT = TOP
                SET TOP = NEW_NODE
        [END OF IF]
Step 4: END
----

==== POP Operation

The `pop` operation is used to delete the topmost element from a sack. 
However, before deleting the value, we must first check if TOP = NULL, because if this is the case, then it means that the stack is empty and no more deletions can be done. 
If an attempt is made to delete a value from a stack that is already empty, an `UNDERFLOW` message is printed. 
Consider the stack shown in below figure.

image::stack-linked_list-pop-1.png[]

In case TOP != NULL, then we will delete the node pointed by TOP, and make TOP point to the second element of the linked stack. 
Thus, the updated stack becomes as shown in below figure.
image::stack-linked_list-pop-2.png[]

.Algorithm Stack Linked POP
----
Step 1: IF TOP = NULL
                PRINT "UNDERFLOW"
                GOTO step 5
        [END OF IF]
Step 2: SET PTR = TOP
Step 3: SET TOP = TOP -> NEXT
Step 4: FREE PTR
Step 5: END
----

The algorithm to delete an element from a stack:
In step 1, we first check for the UNDERFLOW condition.
In step 2, we use a pointer PTR that points to TOP.
In step 3, TOP is made to point to the next node in sequence.
In step 4, the memory occupied by PTR is given back to the free pool.

=== Applications of Stacks

In this section we will discuss typical problems where stacks can be easily applied for a simple and efficient solution. 
The topics that will be discussed in this section include the following:

* Reversing a list
* Parentheses checker
* Conversion of an infix expression into a postfix expression
* Evaluation of a postfix expression
* Conversion of an infix expression into a prefix expression
* Evaluation of a prefix expression
* Recursion
* Tower of Hanoi

==== Reversing List

==== Evaluation of Arithmetic Expressions


== Trees

=== Basic Terminology in Trees

A tree is recursively defined as a set of one or more nodes where on node is designates as root of the tree and all the remaining nodes can partitioned into non-empty sets each of which is sub-tree of the root. 
Figure 4.1 shows a tree where node A is the root node; nodes B, C and D are children of the root node and form sub-trees of the tree rooted at node A.
image::tree-detail.png[]

Root Node:: The root node R is the topmost node in the tree. 
If R = NULL, then it means the tree is empty.

Sub-trees:: If the root node R is not NULL, then the trees T1, T2 and T3 are called the sub-trees of R.

Leaf-node:: Anode that has no children is called the leaf node or the terminal node.

Path:: A sequence of consecutive edges is called a path. 
For example in Fig.4.1, the path from the root node A to node I is given as: A, D and I.

Ancestor node:: An ancestor of a node is any predecessor node on the path from root to that node. 
The root node does not have any ancestors. 
In the tree given in Fig.4.1, nodes C, G, J and K are the descendants of node A.

Level number:: Every node in the tree is assigned a level number in such a way that the root node is at level 0, children of the root node are at level number 1. 
Thus, every node is at one level higher that its parent. 
So, all child nodes have a level number given by parent's level number + 1.

Degree:: Degree of a node is equal to the number of children that a node has. 
The degree of a leaf node is zero.

* In-degree:: In-degree of a node is the number of edges arriving at the node.
* Out-degree:: Out-degree of a node is the number of edges leaving that node.

=== Binary Trees

A binary tree is a data structure that is defined as a collection of elements called nodes. 
In a binary tree, the topmost element is called the root node, and each node has 0, 1 or at the most 2 children.

A node that has zero children is called a leaf node or a terminal node. 
Every node contains a data element, a leaf pointer which points to the left child and a right pointer which points to the right child. 
The root element is pointed by a 'root' pointer. 
If root = NULL, then it means the tree is empty.

Figure 4.2 shows a binary tree. 
In figure, R is the root node and the two trees T1 and T2 are called the left and right sub-trees of R. 
T1 is said to be the left successor of R. 
Likewise, T2 is called the right successor of R.

image::tree-binary.png[]

Note that the left sub-tree of the root node consists of the nodes: 2, 4, 5, 8 and 9. 
Similarly, the right sub-tree of the root node consists of nodes: 3, 6, 7, 10, 11 and 12.

In the tree, root node 1 has two successors: 2 and 3. 
Node 2 has two successor nodes: 4 and 5. 
Node 4 has two successors: 8 and 9. 
Node 5 has no successor. 
Node 3 has two successor nodes: 6 and 7. 
Node 6 has two successors: 10 and 11. 
Finally, node 7 has only one successor: 12.

A binary tree is recursive by definition as every node in the tree contains a left sub-tree and a right sub-tree. 
Even the terminal nodes contain an empty left sub-tree and an empty right sub-tree.
Look at Fig.4.2, nods 5, 8, 9, 10, 11 and 12 have no successors and thus said to have empty sub-trees.

==== Terminology

Parent:: If N is any node in T that has left successor S1 and right successor S2, then N is called the parent of S1 and S2. 
Correspondingly, S1 and S2 are called the left child and right child of N. 
Every node other than the root node has a parent.

image::tree-binary-levels.png[]

Level Number:: Every node in the binary tree is assigned a level number (refer Fig.4.3). 
The root node is defined to be at level 0. 
The left and the right child of the root node have a level number 1. 
Similarly, every node is at one level higher than its parents. 
So all child nodes are defined to have level number as parent's level number + 1.

Degree of a node:: It is equal to the number of children that a node has. 
The degree of a leaf node is zero. 
For example, in the tree, degree of node 4 is 2, degree of node 5 is zero and degree of node 7 is 1.

Sibling:: All nodes that are at same level and share the same parent are called siblings (brothers). 
For example, nodes 2 and 3; nodes 4 and 5; nodes 6 and 7; nodes 8 and 9; and nodes 10 and 11 are siblings.

Leaf node:: A node that has no children is called a leaf node or a terminal node. 
The leaf nodes in the tree are: 8, 9, 5, 10, 11 and 12.

Similar binary trees:: Two binary trees T and T' are said to be similar if both these trees have the same structure. 
Figure 4.4 shows two similar binary trees.
image::tree-binary-similar.png[]

Copies:: Two binary trees T and T' are said to be copies if they have similar structure and if they have same content at the corresponding nodes. 
Figure 4.5 shows that T' is a copy of T.
image::tree-binary-copy.png[]

Edge:: It is the line connecting a node N to any of its successors. 
A binary tree of n nodes has exactly n - 1 edges because every node except the root node is connected to tits parent via an edge.

Path:: A sequence of consecutive edges. 
For example, in Fig.4.3, the path from the root node to the node 8 is given as: 1, 2, 4 and 8.

Depth:: The depth of a node N is given as the length of the path from the root R to the node N. 
The depth of the root node is Zero.

Height of a tree:: It is the total number of nodes on the path from the root node to the deepest node in the tree. 
A tree with only a root node has a height of  1.

A binary tree of height h has at least h nodes and at most 2^h^ - 1 node. 
This is because every level will have at lease one node and can have at most 2 nodes. 
SO, if every level has two nodes then a tree with height h will have at most 2^h^ - 1 nodes as at level 0, there is only one element called the root. 
The height of a binary tree with n nodes is at least log~2~(n+1) and at most n.

In-degree/out-degree of a node:: It is the number of edges arriving at a node. 
The root node is the only node that has an in-degree equal to zero. 
Similarly, out-degree of a node is the number of edges leaving that node. 
Binary trees are commonly used to implement binary search trees, expression trees, expression trees, tournament trees and binary heaps.

*Complete Binary Trees*

A complete binary tree is a binary tree that satisfies two properties. 
First, in a complete binary tree, every level, expect possibly the last, is completely filled. 
Second, all nodes appear as far left as possible.

In a complete binary tree T~n~, there are exactly n nodes and level r of T can have at most 2^r^ nodes. 
Figure 4.7 shows a complete binary tree.

image::tree-binary-complete.png[]

Note that in Fig.4.6, 
level 0 has 2^0^ = 1 node, 
level 1 has 2^1^ = 2 nodes, 
level 2 has 2^2^ = 4 nodes, 
level 3 has 2^3^ = 8 nodes.

In Fig.4.6, tree T~13~ has exactly 13 nodes. 
They have been purposely labelled from 1 to 13, so that it is easy for the reader to find the parent node, the right child node, and the left child node of the given node.

The formula can be given as - if K is a parent nofe, then its left child can be calculated as 2 x K and its right child can be calculate as 2 x K + 1.

For example, the children of the node 4 are 8 (2 x 4) and 9 (2 x 4 + 1).
Similarly, the parent of the node K can be calculated as |K/2|. 
Given the node 4, its parent can be calculated as |4/2| = 2. 
The height of a tree T~n~ having exactly n nodes is given as: H~n~ = |log~2~(n + 1)|

Note: This means, if a tree T has 1000000 nodes, then its height is 21.

*Extended Binary Trees*

A binary tree T is said to be an extended binary tree (or a 2-tree) if each node in the tree has either no child or exactly two children. 
Figure 4.7 shows how an ordinary binary tree is converted into an extended binary tree.

In an extended binary tree, nodes having two children are called internal nodes and nodes having no children are called external nodes. 
In Fig.4.7, the internal nodes are represented using circles and the external nodes are represented using squares.

To convert a binary tree into an extended tree, every empty sub-tree is replaced by a new node. 
The original nodes in the tree are the internal nodes, and the new nodes added are called the external nodes.

image::tree-binary-extended.png[]

=== Representation of Binary Trees in the Memory

In the computer's memory, a binary tree can be maintained either by using a linked representation or by using a sequential representation.

*Linked representation of binary trees*
+
In the linked representation of a binary tree, every node will have 3 parts:
1) data element
2) a pointer to the left node and
3) a pointer to the right node.

So in C, the binary tree is built with a node type given below:
+
[source, c]
----
struct node
{
        struct node * left;
        int data;
        struct node * right;
}
----

Every binary tree has a pointer ROOT, which points to the root element (topmost element) of the tree. 
If ROOT = NULL, then the tree is empty. 
Consider the binary tree given in Fig.4.2. 
The schematic diagram of the linked representation of the binary tree is shown in Fig.4.8.

In Fig.4.8, the left position is used to point to the left child of the node or to store the address of the left child of the node. 
The middle position is used to store the data. 
Finally, the right position is used to point to the right child of the node or to store the address of the right child of the node. 
Empty sub-trees are represented using X (meaning NULL).

image::tree-binary-linked.png[]

Sequential representation of binary trees is done using single or one-dimensional arrays. 
Thought it is the simplest technique for memory representation, it is inefficient as it requires a lot of memory space.

A sequential binary tree follows the following rules:
* A one-dimensional array, called TREE, is used to store the element of tree.
* The root of the tree will be stored in the first location. 
That is, TREE[1] will store the data of the root element.
* The children of a node stored in location K will be stored in locations (2 x K) and (2 x K + 1).
* The maximum size of the array TREE is given as (2h -1), where h is the height of the tree.
* An empty tree or sub-tree is specified using NULL. 
If TREE[1] = NULL, then the tree is empty.

Fig.4.9 shows a binary tree and it's corresponding sequential representation. 
The tree has 11 nodes and it's height is 4.

image::tree-binary-sequential.png[]

=== Traversing a Binary Tree

=== Binary Search Trees

=== Balanced Binary Trees - AVL Trees

==== Operations on AVL Trees

=== Applications of Trees

==== Expression Trees

==== Heap Sort






