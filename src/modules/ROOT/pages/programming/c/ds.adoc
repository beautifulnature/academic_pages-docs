[[c_ds]]
= Data Structures through C
:page-aliases: ds/ds.adoc
:imagesdir: ../../../../images/programming/c/ds

== Unit 1

=== Data Structures

==== Definition

* Data structures is the concept of set of algorithms used to structure the information.
* These algorithms are implemented in different programming languages like c, c++, java, python, etc.
* Structure the information means store and process data in an efficient manner.
* To store and process data, we may use the following operations:
1. create()
2. insert()
3. delete()
4. display()
5. search()
6. sort()
7. merge()
8. split()
9. traverse()
* So the data structure may contain algorithms, used for different operations implement these algorithms by a programming language.
* For example, for stack data structure, write algorithms for different operations
1. push
2. pop
3. display
* Implement these algorithms in a particular language say C.

==== Classification of Data Structures

Data Structures are normally classified into 2 types:
1. Primitive Data Structures
2. Non-Primitive Data Structures

===== Primitive Data Structures

Primitive data structures are built-in types in most programming languages. They are:
1. Integer:: It is whole numbers i.e. negative value, 0, positive value.
2. Float:: It is fractional numbers.
3. Character:: It is character values.
4. Boolean:: It represents true or false values.

===== Non-Primitive Data Structures

These are derived from primitive data structures. They are:
1. Array
2. Structure
3. Union
4. Files
etc.

Non-Primitive data type is further divided into Linear and Non-Linear data structures:

a. Linear Data Structures:
Here the data elements are connected in a sequence manner.
Examples are:
1. Arrays
2. Linked List
3. Stacks
4. Queues

Array:
It is collection of eleements of same type.

a[5] = {10, 20, 30, 40, 50}

|====
|0|1|2|3|4
|10|20|30|40|50
|====

Linked List:
* Linked list or single linked list is a sequence of elements in which every element has link to its next element in the sequence.
* Every element is called as a `node`. 
Every `node` contains two fields, `data` and `link`. 
The `data` is a value or string and 
`link` is an address of next `node`.
* The first `node`` is called as `HEAD` which is an empty node contains an address of the first node so it link to the first `node`.
* The first `node` link to second `node` and so on.
* The last `node` does not link to address but link to `NULL`. 
Let `ptr` be a `pointer` to the linked list. 
THe example is given below:
image::linked-list.png[Linked List]

Stack:
A `stack` is a data structure in which additions and deletions are made at the top of the `stack`. 
So we can perform two operations on `stack`.
1. Adding elements into the stack known as `push`.
2. Removing elements from the stack known as `pop`.
image::stack.png[Stack]

Queue:
A `queue` is a data structure in which additions are made at one end and deletions are made at the other end. 
We can represent a `queue` in an array.

Here we can perform two operations on `queue`.
1. Adding elements into the queue known as insertion at rear.
2. Removing elements from the queue known as deletion at front.
image::queue.png[Queue]

b) Non-Linear Data Structures:
Here the data elements are not connected in a sequence manner.

Examples are:
1. Trees
2. Graphs

Tree:
A `tree` is defined as a finite set of one or more `nodes` such that
1. One `node` is called a root node and
2. Remaining `nodes` are partitioned into sub trees of the root.
image::tree.png[Tree]

Graph:
* A `graph` is a pictorial representation of a set of `points` or `nodes` termed as `vertices` and the `links` that connect the vertices are called `edges`.
* A `graph`(G) consists of two sets `V` and `E` where `V` is called vertices and `E` is called edges. 
We also write G = (V, E) to represent the graph.
* A `graph` may be dircted graph or undirected graph.
image::graph.png[Graph]
* Fig(a), Fig(b) are called undirected graph and Fig(c) is called directed graph.

Differences between Linear and Non-Linear Data Structures:
[cols="1,1"]
|===
|Linear Data Structure | Non-Linear Data Structure 

|Every data element is connected to its previous and next element.
|Every data element is connected with many other data elements.

|Data is arranged in a sequence manner.
|Data is not arranged in a sequence manner.

|Data can be travered in a single run.
|Data cannot be traversed in a single run.

|Ex: Arrays, Linked List, Stacks, Queues
|Ex: Trees, Graphs

|Implementation is easy.
|Implementation is difficult.
|===

==== Operations on Data Structures

The different operations on data structures are:

1. Create:
+
Here we reserve memory for program elements: This can be done using `malloc()` or `calloc()` function. 
We can create a data structure with giving different elements.

2. Insert:
+
Here we reserve memory for program element: This can be done using `malloc()` or `calloc()` function. 
We can insert a data element into a data structure.

3. Delete:
+
It delete memory space allocated for specified data structure using `free()` function.

4. Display:
+
It deals with accessing a particular data element within a data structure.

5. Search:
+
* It finds the data element in the list of data elements.
* It also find the location of all elements.

6. Sort:
+
It is the process of arraning all the data elements in a data structure in a particular order say either in ascending or descending order.

7. Merge:
+
It is the process of combining the data elements of two different sorted list into a single sorted list.

8. Split:
+
It is the process of partitioning single list to multiple list.

9. Traversal:
+
It is the process of visiting each and every node of a list in systematic manner.

==== Abstract Data Types (ADT)

An `Abstract Data Type (ADT)` is a collection of values and a set of operations without specifying its implementation.

For example in Array ADT, set of values are ind element & set of operations are create(), retrieval() and store().

*Purpose*:
+
* The purpose of the ADT is to hide the implementation details of a data structure thus improving software maintenance, reuse and portability.
* The developers of ADT will adapt changing requirements and save time.
* The users of ADT are concerned with the interface, but not the implementation.
* The different ADTs
** String ADT, List ADT, Stack ADT (last-in, first-out(LIFO))
** Queue ADT (first-in, first-out(FIFO))
** Binary Search Tree ADT
etc.

*Example*:
+
* A `List ADT` contain operations known as add element, remove element, etc.
* A `List ADT` can be represented by an `array-based` implementation or a `linked-list` based implementation. 
In this the `linked-list` based implementation is so commonly used.
* Similary a `Biney Search Tree ADT` can be represented in different ways with the same operations known as insert, remove, display, etc.

==== Array as an Abstract Data Type

The `Array ADT` is a set of values (index, element) and a set of operations known as `Array create()`, `Item Retrieve()` and `Array Store()`.

The `Array ADT` algorithm is given by
+
----
`Array ADT` is
+
*objects*: A set of pairs<index, element> where for each index, there is a corresponding element.
*functions*: for all A€Array, i€index, x€element:
Array create() := It creates a new empty array.
Item retrieve(A, i) := It returns the element with particular index, if the index is valid or an error if the inded is invalid.
Array Strore(A, i, x) := It stores the element
end Array.
----

==== Stack as an Abstract Data Type
+
----
ADT stack is 
*objects*: a finite ordered list with zero or more elements.
*functions*: S € Stack, item € element
Stack create() := creates a new empty stack.
Stack push(S, item) := adds item to the top of the stack.
Element pop(S) := removes the top element of the stack and returns it.
end Stack.
----

==== Queue as an Abstract Data Type
+
----
ADT queue is
*objects*: a finite ordered list with zero or more elements.
*functions*: Q € Queue, item € element
Queue create() := creates a new empty queue.
Queue addq(Q, item) := adds item to the end of the queue.
Element deleteq(Q) := removes and return the item from the queue.
end Queue.
----

==== Binary Tree as an Abstract Data Type
+
----
ADT BinaryTree is
*objects*: a finite set of nodes.
*functions*: for all bt, bt1, bt2 € BinaryTree, item € element
BinaryTree create() := creates a new empty binary tree.
Boolean IsEmpty := if(bt == empty binary tree) return `TRUE` else return `FALSE`
BinaryTree MakeBT(bt1, item, bt2) := return a binary tree whose left subtree is bt1, whose right subtree is bt2 and whose root node contains the date item.
BinaryTree LeftChild(bt) := returns the left subtree of bt.
Element Data(bt) := returns the data of the root node of bt.
BinaryTree RightChild(bt) := returns the right subtree of bt.
End BinaryTree.
----

==== Graph as an Abstract Data Type
+
----
ADT Graph is
*objects*: a set of vertices and edges.
*functions*: for all graph € Graph, v, v1 and v2 € Vertices
Graph create() := creates a new empty Graph.
Boolean IsEmpty() := if(graph == empty graph) return `TRUE` else return `FALSE`
Graph InsertVertex(graph, v) := returns a graph with vertex v inserted.
Graph InsertEdge(graph, v1, v2) := returns a graph with edge (v1, v2) inserted.
Graph DeleteVertex(graph, v) := returns a graph with vertex v removed.
Graph DeleteEdge(graph, v1, v2) := returns a graph with edge (v1, v2) removed.
End ADT Graph.
----

===== Preliminaries of algorithms

Algorithm is step-by-step process or sequence of steps for solving a problem.

Properties of an Algorithm:
+
* The properties of an algorithm are:
Input:
+
The algorithm must have input values from a specified set.
Output:
+
The algorithm must produce the output values from a specified set of input values. 
The output values are the solution to a problem.
Finiteness:
+
For any input the algorithm must terminate after a finite number of steps.
Definiteness:
+
All the steps of an algorithm must be precisely defined.
Effectiveness:
+
It must be possible to perform each step of the algorithm correctly and in a finite amount of time.

* Each step should be well defined. 
It can be divided into 3 types.
+
1. Sequence
* In an algorithm if all steps are shown then it is known as sequence.
* for example an algorithm for adding two values.
+
----
Ex:
Step 1: start
Step 2: read a, b
Step 3: r = a + b
Step 4: print r
Step 5: stop
----
2. Selection
+
* Here we use if condition and the condition is checked only one time.
* if a condition is satisfied then next statement is executed otherwise else statement is executed.
* For example an algorithm to check whether the given number is evene or odd.
+
----
Ex:
Step 1: start
Step 2: read n
Step 3: if (n % 2 == 0) goto step 4
        if not goto step 6
Step 4: print "n is even" goto step 7
Step 5: else
Step 6: print "n is odd"
Step 7: stop
----

3. Iteration
+
* Here we use while, do-while and for loop & the condition is checked number of times.
* i.e. The statements in an iteration block are executed no. of times based on some condition.
* For example an algorithm to print 1 to n numbers using while loop.
+
----
Ex:
Step 1: start
Step 2: read n
Step 3: initialize i = 1
Step 4: while (i <= 10) goto step 5
        otherwise goto step 7
Step 5: print i
Step 6: compute i++ goto Step 4
Step 7: stop
----
* When an algorithm get coded in a specified programming language such as C, C++ or Java, it becomes a program that can be executed on a computer.
* Multiple algorithm can exist to solve the same problem or complethe the same task.
* The appropriate algorithm can be determined based on an number of factors:
+
1. How long the algorithm takes to run
2. What resources are required to execute the algorithm
3. How much space or memory is required.
4. How exact is the solution provided by the algorithm.

=== Searching

Searching is the process of finding an element in a list of values.

It is the algorithimic process of finding a particular element in a colletion of elements.

1. Linear Search
+
Defination:
+
It starts at the beginning of the list and checks each element of the list.
+
i.e. It sequencially checks each element of the list until a match is found or the whole list has been searched.
So it is called sequential search.

*Example:*
* Let the elements are: 10, 6, 3, 8, 9, 12, 14
* The search element is 12
* Now it compares 12 with each and every element.
* The 12 is available at the 6th position.
* So the searching process is success and element is found.

*Algorithm:*
Step 1: Read elements in array
Step 2: Read the element to be searched
Step 3: Compare the element with each element of the array sequentially
Step 4: If match is found then the search is success
Step 5: If match is not found then the search is unsuccess.

*Program*
include:include::/programs/ds/linear_search.c[]

2. Binary Search
+
Defination:
+
Bineary search is the most popular search algorithm. 
It is efficient and also one of the most commonly used techniques that are used to solve problems.

Binary search sorts the records either in ascending or descending order to gain much better performance than linear search.

Now suppose we have an ascending order record. At the tiem of search it takes the middle record/element, if the searching element is greater than middle element then the element must be located in the second part else it is in the first half. 
In this way this search algorithm divides the records into two parts in each iteration and thus called binary search.

*Example:*
* Let the elements in ascending order are: 2, 4, 6, 8, 10, 12, 15
* The search element is 12
* For searching it compare first middle element.
* The middle element is 8 and is not equal to 12. 
Since 12 is greater than 8 search on right side part of 8. 
12 is equal to right side part middle. 
So element is found.

*Algorithm:*
Step 1: Read sorted elements in array
Step 2: Read the element to be searched
Step 3: Compare the element to search and middle element in array. 
Step 4:If search element is greater than middle element then search in right side of middle element otherwise search on left.
Step 5: This process is repeated for all eleements in array. 
If not match is found upto the end then the search is not success.

*Program*
include:include::/programs/ds/binary_search.c[]

3. Fibonacci Search

* Fibonacci search uses Fibonacci numbers to find the element in the sorted array.
* Fibonacci numbers are: 0, 1, 1, 2, 3, 5, 8...
* Fibonacci series generates the subsequent number by adding two previous numbers.
* For example:
Let the elements are give by:
10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100
arr[] = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100}
* Fibonacci numbers are: 0, 1, 1, 2, 3, 5, 8, 13, 21...
Target element x is 85. 
Length of array n = 11.
* Find the smallest Fibbonacci number greater than or equal to 11 is 13.
* As per our step, a=5, b=8, c=a+b=13.
* Let offset = -1
* First compute i = min (offset+a, n-1)



=== Sorting

Sorting is a process of placing a list of elements from a collection of dats in some order.

It is nothing but storage of data in sorted order. 
Sorting can be done in ascending or descending order. 
It arranges the data in a squence which makes searching easier.

==== Insertion Sort
+
* In this sorting technique first elements are stored in an array.
* The process of sorting starts with second element.
* First the second element is picked and is placed in specified order. 
Next third element is picked and is placed in specified order. 
Similarly the fourth, fifth, ...nth element is placeed in specified order.
* Finally we get the sorting elements.

*Example*
+
Let us consider the elements of an array: 12, 3, 1, 5, 8
+
1. Checking second element of array with element before it and inserting it in proper position. 
In this case 3 is inserted in position of 12.
+
image::insertion_sort-1.png[]
2. Checking third element of array with elements before it and inserting it in proper position. 
In this cas 3 is inserted in position 12.
+
image::insertion_sort-2.png[]
3. Checking fourth element of array with elements before it and inserting it in proper position. 
In this case 5 is inserted in position of 12.
+
image::insertion_sort-3.png[]
4. Checking fifth element of array with elements before it and inserting it in propoer position. 
In this case 8 is inserted in position of 12.
+
image::insertion_sort-4.png[]
5. Sorted array in ascending order.
+
image::insertion_sort-5.png[]

*Algorithm*
+
Step 1: Check second element of array with element before it and insert it in proper position.
Step 2: Checking third element of array with element before it and inserting it in proper position.
Step 3: Repeat this till all emements are checked.
Step 4: Stop

*Program*
include::/programs/ds/insertion_sort.c

==== Selection Sort

Selection sort is an algorithm that selects the smallest element from an unsorted list in each iteration and places it at the beginning of the unsorted list.

.Example
image::selection_sort-1.png[]

* In first pass the first element is compared with all remaining elements and exchange element if first one is greater than second so that the smallest value is in first place. 
Leave this element.
* In second pass compare second element to all elements put the next smallest value, in second place. 
Leave this element. 
This process is repeated till all the elements are placed.
* Now we get the sorted elements.

*Algorithm*
+
Step 1: Set min to the first location.
Step 2: Search the minimum element in the array.
Step 3: Swap the first location with the minimum value in the array.
Step 4: Assign the second element as min.
Step 5: Repeat this process until we get a sorted array.

*Program*
include::/programs/ds/selection_sort.c

==== Exchange Sort

The exchange sort is almost similar as the bubble sort. 
The exchange sort compares each element of an array and swap those elements that are not in their proper position, just like a bubble sort does. 
The only difference between the two sorting algorithms is the manner in which they compare the elements.

==== Bubble Sort

Bubble sort is based on the idea of repeatedly comparing pairs of adjacent elements and then swapping positions if they eixst in the wrong order.

*Example*
+
The following figure shows the first pass of a bubble sort. 
In first pass the first element is compared with second and exchange element if first one is greater than second.
* Similarly second element is compared with third and exchange element if second one is greater than third.
* Repeat this so that at the end of first pass the largest element is in the last position. 
Leave this element.

image::bubble_sort.png[]

* In second pass compare up to before last place value and put the next largest value, that before last place. 
Leave this element.

* This process is repeated till all the elements are placed. 
Now we get the sorted elements.

*Algorithm*
+
Step 1: The first element is compared with second and exchange element if first one is greater than second.
Step 2: The second element is compared with third and exchange element if second one is greater than third.
Step 3: Repeat this so that at the end the largest value is in last place.
Step 4: Likwise sorting is repeated for all elements.

*Program*
include::/programs/ds/bubble_sort.c

==== Quick Sort

* Quick sort is also one of the exchange sort.
* In a quick sort we take pivot element, then we place all the smaller elements are on one side of pivot, and greater elements on other side of pivot.
* After partitioning we have pivot in the final position. 
After repeatedly partioning, we get the sorted elements.

*Example*
* Let us consider the elements: 35, 50, 15, 25, 80, 20, 90, 45
* Let us consider the first element 35 as pivot or i. 
The last element 45 as j.
image::quick_sort-1.png[]
* 50 which is greater than pivot taken as i and 20 smaller than pivot taken as j.
image::quick_sort-2.png[]
* Now i is less than j so swap the elements in i and j.
image::quick_sort-3.png[]
* Find greater than 35 (80) is i and less than 35 (25) is j.
image::quick_sort-4.png[]
* Now i is not less than j. 
Swap 35 and j. 
So 35 comes at j place.
image::quick_sort-5.png[]
* Now 35 is in correct position.
* On left side and right side of 35 repeat the process. Consider on left side of 35
image::quick_sort-6.png[]
* Let 25 as pivot. 
The lesser of 25 that is 15 as j and there is no greater. 
So bring i after j. 
i > j so swap pivot and j.
image::quick_sort-7.png[]
* After swaping
image::quick_sort-8.png[]
* Now the left part is sorted. 
Consider right part.
image::quick_sort-9.png[]
* Here 80 as pivot. 
Greater than 80 is i and less than to 80 is j.
image::quick_sort-10.png[]
* Here i is less than j, so swap i and j elements.
image::quick_sort-11.png[]
* After swaping, the sorting elements are given by
image::quick_sort-12.png[]
* Now join all left part j and right part j to get the sorted elements.
image::quick_sort-13.png[]

*Algorithm*
+
Step 1: Let the first element taken as pivot.
Step 2: Find lesser of pivot say i and greater of pivot say j.
Step 3: if i is less than j then swap i and j elements. 
Repeat step 2.
Step 4: Repeat step 3 until i > j. 
Now swap j and pivot.
Step 5: Now the pivot element is in final position. 
Repeat the above procedure for left and right side of pivot elements until all elements are sorted.
Step 6: Stop

*Program*
include::/programs/ds/quick_sort.c

==== Distribution Sort or Radix Sort

Randix sort is one of the sorting algorithms used to sort a list integer numbers in ascending order or descending order.

* In randix sort algorithm, a list of integer numbers will be sorted based on the digits of individual numbers. 
Sorting is performed from least significant digit to the most significant digit.

* Randix sort algorithm requires the number of passes which are equal to the number of digits present in the largest number among the list of numbers.

* For example, if the largest number is a 3 digit number then that list is sorted with 3 passes.

*Example*
Consider the following list of unsorted integers:

82, 901, 100, 12, 150, 77, 55, 23

Step 1: Define 10 queues each represents a bucket for digits from 0 to 9.
image::randix-1.png[]
Step 2: Insert all the numbers of the list into respective queue based on the least significant digit (ones placed digit) of every number.
image::randix-2.png[]
Group all the numbers from queue 0 to 9 in the order they haved inserted & consider the list for next step as input list.
100, 150, 901, 82, 12, 23, 55, 77
Step 3: Insert all the numbers of the lsit into respective queue based on the next least significant digit (tens placed digit) of every number.
image::randix-3.png[]
Group all the numbers from queue 0 to 9 in the order they haved inserted & consider the list for next step as input list.
100, 901, 12, 23, 150, 55, 77, 82
Step 4: Insert all the numbers of the lsit into respective queue based on the next least significant digit (hundreds placed digit) of every number.
image::randix-4.png[]
Group all the numbers from queue 0 to 9 in the order they haved inserted & consider the list for next step as input list.
12, 23, 55, 77, 82, 100, 150, 901
List got sorted in the increasing order.

*Algorithm*
+
Step 1 - Define 10 queues each represents a bucket for digits from 0 to 9.
Step 2 - Consider the least significant digit of every number in the list which is to be sorted.
Step 3 - Insert each number into respective queue based on the least significant digit.
Step 4 - Group all the numbers from queue 0 to 9 in the order they have inserted into their respective queues.
Step 5 - Repeat from step 3 based on the next least significant digit.
Step 6 - Repeat from step 2 until all the nunmbers are grouped based on the most significant digit.

*Program*
include::/programs/ds/distribution_sort.c

==== Merge Sort

It divides input array into two halves, calls itself for the two halves and then sorted and merged that two halves.

*Example*

For example consider the arry of elements: 38, 27, 43, 3, 9, 82, 10

Now the array is recursively divided into two halves till the size becomes one which is shown in the following figure.
image::merge_sort-1.png[]

Once the size becomes one, the merge process comes into action and starts merging with sorted array till the complete array is merged.
image::merge_sort-2.png[]

*Algorithm*
+
Step 1: If it is only one element in the list then it is already sorted.
Step 2: Divide the list recursively into two halves till the size becomes one.
Step 3: Once the size becomes 1, the merge process comes into action and starts merging with sorted array till the complete array is merged.
image::merge_sort-3.png[]

*Program*
include::/programs/ds/merge_sort.c


===== Time Complexity

O(n^2) means that for every insert, it takes n*n operations. i.e. 1 operation for 1 item, 4 operations for 2 items, 9 operations for 3 items.

.Comparison of Sorting Algorithms
[cols="1,1,1,1,1"]
|===
|Algorithm|Data Structure 3+^.^|Time Complexity

|
|
|Best
|Average
|Worst

|Quick sort
|Array
|O(n log n)
|O(n log n)
|O(n^2)

|Merge sort
|Array
|O(n log n)
|O(n log n)
|O(n log n)

|Bubble sort
|Array
|O(n)
|O(n^2)
|O(n^2)

|Insertion sort
|Array
|O(n)
|O(n^2)
|O(n^2)

|Selection sort
|Array
|O(n^2)
|O(n^2)
|O(n^2)
|===

== Linked Lists

=== Introduction

A linked list is a collection of data elements called nodes in which the linear representation is given by links from one node to the next node. 
A linked list does not store its elements in consecutive memory locations and the user can add any number of nodes to the list.

The elements in a linked list can be accessed only in a sequential manner. 
But like an array, insertions and deletions can be done at any point in the list in a constant time.

A linked list, in simple terms, is a linear collection of data elements. 
These data elements are called nodes. 
Linked list a data structure which in turn can be used to implement other data structures.

Thus, it acts as a building block to implement data structures like stacks, queues and their variations.

==== Basic Terminology

A linked list can be perceived as a train or a sequence of nodes in which each node contains one or more data fields and a pointer to the next node.
image::linked_lists.png[]

We can see a linked list in which every node contains two parts, an integer and a pointer to the next node. 
The last node will have no next node connected to it, so it will store a special value called `NULL`.

Since in a linked list, every node contains a pointer to another node which is of the same type, it is also called a self-referential data type.

Let us see how a linked list is maintained in the memory. 
When we traverse `DATA` and `NEXT` in this manner, we finally see that the linked list in the above example stores characters that when put together form the `HELLO`.

image::linked_list-memory.png[]

==== Linked List vs. Array

Both arrays and linked lists are a linear collection of data elements. 
But unlike an array, a linked list does not stores its nodes in consecutive memory locations. 
Another point of difference between an array and a linked list is that a linked list does not allow random access to data. 
Nodes in a linked list can be accessed only in a sequential manner.

Another advantage of a linked list over an array is that we can add any number of elements in the list. 
This is not possible in case of an array.

==== Memeory Allocation and De-allocation for a Linked List

If we want to add a node to an already existing linked list in the memory, we first find free space in the memory and then use it to store the information.

Now, the question is which part of the membory is available and which part is occupied? 
When we delete a node from a linked list, then who changes the status of the memory occupied by it from occupied to available? 
The answer is the operating system.

The operating system scans through all the memory cells and marks those cells that are being used by some program. 
Then it collects all the cells which are not being used adds their address to the free pool, so that these cells can be reused by other programs. 
The process is called grabage collection.

=== Single Linked Lists

A singly linked list is the simplest type of linked list in which every node contains some data and a pointer to the next node of the same data type.

image::single_linked_lists.png[]

Traversing a linked list means accessing the nodes of the list in order to perform some processing on them. 
Remember a linked list always contains a pointer variable `START` which stores the address of the first node of the list. 
End of the list is marked by storing `NULL` or -1 in the `NEXT` field of the last node.

==== Operations

===== Traversing a Linked List

For traversing a linked list, we also make use of another pointer variable `PTR` which points to the node that is currently being accessed. 
Algorithm for traversing a linked list.

----
Step 1: [INITIALIZE] SET `PTR` to `START`
Step 2: Repeat Steps 3 & 4 [LOOP] WHILE `PTR` is not `NULL`
Step 3: [PROCESS] PROCESS `PTR` -> `DATA`
Step 4: [UPDATE] SET `PTR` to `NEXT`
Step 5: [TERMINATE] END
----

image::linked_lists.png[]

===== Searching for a value in a Linked List

Searching a linked list means to find a particular element in the linked list. 
So searching means finding whether a given value is present in the information part of the node or not. 
If it is present, the algroithm returns the address of the node that contains the value. 
However, if the search is unsuccessful, `POS` is set to `NULL` which indicates that `VAL` is not present in the linked list.

Consider the linked list shown below. 
If we have `VAL = 4`, then the flow of algorithm can be explained as shown in the figure.

image::linked_list-search.png[]

*Algorithm*
----
Step 1: [INITIALIZE] SET `PTR` to `START`
Step 2: Repeat Steps 3  [LOOP] WHILE `PTR` is not `NULL`
Step 3: [PROCESS]                       IF `PTR` -> `DATA` = `VAL`
        [UPDATE]                                SET `POS` to `PTR`
                                                GOTO Step 5
                                        ELSE
                                                SET `PTR` to `NEXT`
                                        [END OF IF]
                                [END OF LOOP]
Step 4: [UPDATE] SET `POS` to `NULL`
Step 4: [TERMINATE] EXIT
----

===== Inserting a new node in a Linked List

We will see how a new node is added into an existing linked list. 
We will take four cases and then see how insertion is done in each.

* Case 1: New node is inserted at the beginning
* Case 2: New node is inserted at the end
* Case 3: New node is inserted after given node
* Case 4: New node is inserted before given node

Let us first discuss an important term called `OVERFLOW`. 
Overflow is a condition that occurs when AVAIL = NULL or no free memory cell is present in the system. 
when this condition occurs, the program must give an appropriate message.

===== Case 1: New node is inserted at the beginning

Inserting a node at the begining of a Linked List. 
Consider the linked list shown in the below figure. 
Suppose we want to add a new node with data 9 and add it as the first node of the list.

image::linked_list-insert-case1.png[]

*Algorithm*
----
Step 1: IF AVAIL = NULL
                [PROCESS] Write OVERFLOW
                [TERMINATE] GOTO Step 7
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET NEW_NODE -> NEXT = START
Step 6: SET START = NEW_NODE
Step 7: [TERMINATE] EXIT
----
===== Case 2: New node is inserted at the end
image::linked_list-insert-case2.png[]
*Algorithm*
----
Step 1: IF AVAIL = NULL
                [PROCESS] Write OVERFLOW
                [TERMINATE] GOTO Step 9
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET NEW_NODE -> NEXT = NULL
Step 6: SET PTR = START
Step 7: WHILE PTR -> NEXT != NULL
                [PROCESS] SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 8: SET PTR -> NEXT = NEW_NODE
Step 9: [TERMINATE] EXIT
----

===== Case 3: New node is inserted after given node
Consider the liked list shown in the below figure. 
Suppose we want to add a new node with value 9 after the node with value 3.
image::linked_list-insert-case3.png[]
*Algorithm*
----
Step 1: IF AVAIL = NULL
                [PROCESS] Write OVERFLOW
                [TERMINATE] GOTO Step 12
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET PTR = START
Step 6: SET PREPTR = PTR
Step 7: WHILE PREPTR -> DATA != NUM
Step 8:         [PROCESS] SET PREPTR = PTR
Step 9:         [PROCESS] SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 10: SET NEW_NODE -> NEXT = PREPTR -> NEXT
Step 11: SET PREPTR -> NEXT = NEW_NODE
Step 12: [TERMINATE] EXIT
----

===== Case 4: New node is inserted before given node

Consider the linked list shown in the below figure. 
Suppose we want to add a new node with value 9 before the node with value 3.
image::linked_list-insert-case4.png[]
*Algorithm*
----
Step 1: IF AVAIL = NULL
                [PROCESS] Write OVERFLOW
                [TERMINATE] GOTO Step 12
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET PTR = START
Step 6: SET PREPTR = PTR
Step 7: WHILE PTR -> DATA != NUM
Step 8:         [PROCESS] SET PREPTR = PTR
Step 9:         [PROCESS] SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 10: SET PREPTR -> NEXT = NEW_NODE
Step 11: SET NEW_NODE -> NEXT = PTR
Step 12: [TERMINATE] EXIT
----

==== Deleting a node from a Linked List

We will discuss how a node is deleted from an already existing linked list. 
We will consider 3 cases and then see how deletion is done in each case.

* Case 1: Delete the first node
* Case 2: Delete the last node
* Case 3: Delete a node after a given node

===== Case 1: Deleting a First Node from a Linked List
image::linked_list-delete-case1.png[]
*Algorithm*
----
Step 1: IF START = NULL
                [PROCESS] Write UNDERFLOW
                [TERMINATE] GOTO Step 5
        [END OF IF]
Step 2: SET PTR = START
Step 3: SET START = START -> NEXT
Step 4: FREE PTR
Step 5: [TERMINATE] EXIT
----

===== Case 2: Deleting the Last Node from a Linked List
image::linked_list-delete-case2_1.png[]
image::linked_list-delete-case2_2.png[]
*Algorithm*
----
Step 1: IF START = NULL
                [PROCESS] Write UNDERFLOW
                [TERMINATE] GOTO Step 8
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> NEXT != NULL
Step 4:         [PROCESS] SET PREPTR = PTR
Step 5:         [PROCESS] SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 6: SET PREPTR -> NEXT = NULL
Step 7: FREE PTR
Step 8: [TERMINATE] EXIT
----

===== Case 3: Deleting After a Given Node in a Linked List

Consider the linked list shown in the below figure. 
Suppose we want to delete the node that succeeds the node with value 4.
image::linked_list-delete-case3.png[]
*Algorithm*
----
Step 1: IF START = NULL
                [PROCESS] Write UNDERFLOW
                [TERMINATE] GOTO Step 
        [END OF IF]
Step 2: SET PTR = START
Step 3: SET PREPTR = PTR
Step 4: WHILE PREPTR -> DATA != NUM
Step 5:         [PROCESS] SET PREPTR = PTR
Step 6:         [PROCESS] SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 7: SET PREPTR -> NEXT = PTR -> NEXT
Step 8: FREE PTR
Step 9: [TERMINATE] EXIT
----

=== Reversing Single Linked Lists
todo::

=== Applications on Single Linked List

* Implementations of stacks and queues.
* Implementation of graphs: Adjacency list representation of graphs is most popular which uses linked list to store adjacent vertices.
* Dynamic memory allocation: we use linked list of free blocks.
* Maintaining directory of names. 
Performing arithmetic operations on long integers.
* Manipulation of polynomials by storing constants in the nodes of a linked list. 
Representing sparse matrices.

==== Polynomial Expression Representation

A polynomial is composed of different terms where each of them holds a coefficient and an exponent. 
An essential characteristic of the polynomial is that each term in the polynomial expression consists of two parts: one is the coefficient and other is the exponent.

*Example*
10x^2 + 26x, here 10 and 26 are coefficients and 2, 1 are its exponential values.
image::polynomial.png[]

===== Addition of two polynomials

----
Input:
        poly1 = 5x^2 + 4x^1 + 2x^0
        poly2 = 5x^1 + 5x^0
Output:
        Sum = 5x^2 + 9x^1 + 7x^0

Input:
        poly2 = 5x^3 + 4x^2 + 2x^0
        poly2 = 5x^1 + 5x^0
Output:
        Sum = 5x^3 + 4x^2 + 5x^1 + 7x^0
----

image::poly-addition.png[]

===== Multiplication of two polynomials

----
Input:
        poly1 = 3x^2 + 5x^1 + 6
        poly2 = 6x^1 + 8
Output: 
        Product = 18x^3 + 54x^2 + 76x^1 + 48
On multiplying each element of poly1 with elements of poly2, we get:
        18x^3 + 30x^2 + 36x^1 + 24x^2 + 40x^1 + 48
        On adding values with same power of x, we get:
        18x^3 + 54x^2 + 76x^1 + 48

Input:
        poly1 = 3x^3 + 6x^1 + 9
        poly2 = 9x^3 + 8x^2 + 7x^1 + 2
Output: 
        Product = 27x^6 + 24x^5 + 75x^4 + 135x^3 + 114x^2 + 75x^1 + 18
----
image::poly-multiplication.png[]

==== Sparse Matrix Representation using Linked List

A matrix is a two-dimensional data object made of m rows and n columns, therefore having total m x n elements. 
If most of the elements of the matrix have 0 value, then it is called a sparse matrix.

Example:
0 0 3 0 4
0 0 5 7 0
0 0 0 0 0
0 2 6 0 0

===== Sparse Matrix Representation using arrays

Method 1: Using Arrays
2D array is used to represent a sparse matrix in which there are 3 rows named as
Row: Index of row, where non-zero element is located.
Column: Index of column, where non-zero element is located.
Value: Value of non-zero element located at index - (row, column)

image::sparse-matrix-array.png[]

===== Sparse Matrix Representation using Linked List

Method 2: Using Linked List
In linked list, each node has four fields:
Row: Index of row, where non-zero element is located.
Column: Index of column, where non-zero element is located.
Value: Value of non-zero element located at index - (row, column)
Next node: Address of the next node.

image::sparse-matrix-linked-list.png[]

==== Advantages of Single Linked list

* Insertion and deletions can be done easily
* It does not need movement of elements for insertion and deletion
* Space is not wasted as we can get space according to our requirements.
* Its size is not fixed. 
It can be extended or reduced according to requirements.
* Elements may or may not be stored in consecutive memory available, even then we can store the data in computer.
* It is less expensive.

==== Disadvantages of Single Linked list

* It requires more space as pointers are also stored with information.
* Different amount of time is required to access each element.
* If we have to go to a particular element the we have to go through all those elements that come before it.
* We cannot traverse it from last and only from the beginning.
* It is not easy to sort the elements stored in the linear linked list.

=== Doubly Linked Lists

A doubly linked list or a two-way linked list is a more complex type of linked list which contains a pointer to next as well as the previous node in the sequence.

Therefore, it consists of 3 parts - data, a pointer to the next node and a pointer to the previous node.

image::doubly-linked_list.png[]


A doubly linked list provides the ease to manipulate the elements in the list as it maintains pointers to nodes in both the directions (forward and backward).

The main advantage of using a doubly linked list is that it makes searching twice as efficient.

Let us view how a doubly linked list is maintained in the memory.
image::doubly-linked_list-memory.png[]

==== Inserting a New Node in a Doubly Linked List

In this section, we will discuss how a new node is added into an already existing doubly linked list. 
We will take four cases and then see how insertion is done in each case.

* Case 1: The new node is inserted at the begining
* Case 2: The new node is inserted at the end
* Case 3: The new node is inserted after a given node
* Case 4: The new node is inserted before a given node

===== Case 1: Inserting a Node at the Beginning of a Doubly Linked List

image::doubly-linked_list-insert-case1_1.png[]
image::doubly-linked_list-insert-case1_2.png[]

*Algorithm*
+
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step 9
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET NEW_NODE -> PREV = NULL
Step 6: SET NEW_NODE -> NEXT = START
Step 7: SET START -> PREV = NEW_NODE
Step 8: SET START = NEW_NODE
Step 9: EXIT
----

===== Case 2: Inserting a Node at the end of a Doubly Linked List

image::doubly-linked_list-insert-case2.png[]
*Algorithm*
+
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET NEW_NODE -> NEXT = NULL
Step 6: SET PTR = START
Step 7: WHILE PTR -> NEXT != NULL
Step 8:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 9: SET PTR -> NEXT = NEW_NODE
Step 10: SET NEW_NODE -> PREV = PTR
Step 11: EXIT
----

===== Case 3: Inserting a Node After a Given Node in a Doubly Linked List
image::doubly-linked_list-insert-case3.png[]
*Algorithm*
+
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step 12
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET PTR = START
Step 6: WHILE PTR -> DATA != NUM
Step 7:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 8: SET NEW_NODE -> NEXT = PTR -> NEXT
Step 9: SET NEW_NODE -> PREV = PTR
Step 10: SET PTR -> NEXT -> PREV = NEW_NODE
Step 11: SET PTR -> NEXT = NEW_NODE
Step 12: EXIT
----

===== Case 4: Inserting a Node Before a Given Node in a Doubly Linked List
image::doubly-linked_list-insert-case4.png[]
*Algorithm*
+
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step 12
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET PTR = START
Step 6: WHILE PTR -> DATA != NUM
Step 7:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 8: SET NEW_NODE -> NEXT = PTR
Step 9: SET NEW_NODE -> PREV = PTR -> PREV
Step 10: SET PTR -> PREV = NEW_NODE
Step 11: SET PTR -> PREV -> NEXT = NEW_NODE
Step 12: EXIT
----

==== Deleting a Node from a Doubly Linked List

In this section, we will see how a node is deleted from an already existing doubly linked list. 
We will take four cases and then see how deletion is done in each case.

* Case 1: The first node is deleted
* Case 2: The last node is deleted
* Case 3: The node after a given node is deleted
* Case 4: The node before a given node is deleted

===== Case 1: Deleting the First Node from a Doubly Linked List

image::doubly-linked_list-delete-case1.png[]
*Algorithm*
+
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 6
        [END OF IF]
Step 2: SET PTR = START
Step 3: SET START = START -> NEXT
Step 4: SET START -> PREV = NULL
Step 5: FREE PTR
Step 6: EXIT
----

===== Case 2: Deleting the Last Node from a Doubly Linked List

image::doubly-linked_list-delete-case2_1.png[]
image::doubly-linked_list-delete-case2_2.png[]
*Algorithm*
+
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 6
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> NEXT != NULL
Step 4:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 5: SET PRT -> PREV -> NEXT = NULL
Step 6: FREE PTR
Step 7: EXIT
----

===== Case 3: Deleting the Node After a Given Node in a Doubly Linked List

image::doubly-linked_list-delete-case3.png[]
*Algorithm*
+
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 9
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> DATA != NUM
Step 4:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 5: SET TEMP = PTR -> NEXT
Step 6: SET PTR -> NEXT = TEMP -> NEXT
Step 7: SET TEMP -> NEXT -> PREV = PTR
Step 8: FREE TEMP
Step 9: EXIT
----

===== Case 4: Deleting the Node Before a Given Node in a Doubly Linked List

image::doubly-linked_list-delete-case4.png[]
*Algorithm*
+
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 9
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> DATA != NUM
Step 4:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 5: SET TEMP = PTR -> PREV
Step 6: SET TEMP -> PREV -> NEXT = PTR
Step 7: SET PTR -> PREV = TEMP -> PREV
Step 8: FREE TEMP
Step 9: EXIT
----

=== Circular Linked Lists

In a circular linked list, the last node contains a pointer to the first node of the list. 
We can have a circular singly linked list as well as a circular doubly linked list.

While traversing a circular linked list, we can begin at any node and traverse the list in any direction, forward or backward, until we reach the same node where we startd. 
Thus a circular linked list has no begining or no ending.

Note that there are no NULL values in the NEXT part of any of the nodes of list.

==== Operation

===== Inserting a New Node in a Circular Linked List

In this section, we will seehow a new node is added into an already existing linked list. 
We will take two cases and then see how insertion is done in each case.

* Case 1: The new node is inserted at the beginning of the circular linked list
* Case 2: The new node is inserted at the end of the circular linked list

====== Case 1: Inserting a Node at the Beginning of a Circular Linked List

image::circular-linked_list-insert-before-1.png[]
image::circular-linked_list-insert-before-2.png[]
*Algorithm*
+
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step 11
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET PTR = START
Step 6: WHILE PTR -> NEXT != START
Step 7:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 8: SET NEW_NODE -> NEXT = START
Step 9: SET PTR -> NEXT = NEW_NODE
Step 10: SET START = NEW_NODE
Step 11: EXIT
----

====== Case 2: Inserting a Node at the End of a Circular Linked List

image::circular-linked_list-insert-end-1.png[]
image::circular-linked_list-insert-end-2.png[]
*Algorithm*
+
----
Step 1: IF AVAIL = NULL
                Write OVERFLOW
                GOTO Step 10
        [END OF IF]
Step 2: SET NEW_NODE = AVAIL
Step 3: SET AVAIL = AVAIL -> NEXT
Step 4: SET NEW_NODE -> DATA = VAL
Step 5: SET NEW_NODE -> NEXT = START
Step 6: SET PTR = START
Step 7: WHILE PTR -> NEXT != START
Step 8:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 9: SET PTR -> NEXT = NEW_NODE
Step 10: EXIT
----

===== Deleting a Node from a Circular Linked List

In this section, we will discuss how a node is deleted from an already existing circular linked list. 
We will tabke 2 cases and then see how deletion is done in each case. 
Rest of the cases of deletion are same as that givn for singly linked lists.

* Case 1: The first node is deleted
* Case 2: The last node is deleted

===== Case 1: Deleting the First Node from a Circular Linked List

image::circular-linked_list-delete-first.png[]
+
*Algorithm*
+
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 8
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> NEXT != START
Step 4:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 5: SET PTR -> NEXT = START -> NEXT
Step 6: FREE START
Step 7: SET START = PTR -> NEXT
Step 8: EXIT
----

===== Case 2: Deleting the Last Node from a Circular Linked List

image::circular-linked_list-delete-last.png[]
+
*Algorithm*
+
----
Step 1: IF START = NULL
                Write UNDERFLOW
                GOTO Step 8
        [END OF IF]
Step 2: SET PTR = START
Step 3: WHILE PTR -> NEXT != START
Step 4:         SET PREPTR = PTR
Step 5:         SET PTR = PTR -> NEXT
        [END OF WHILE]
Step 6: SET PREPTR -> NEXT = START
Step 7: FREE PTR
Step 8: EXIT
----

== Queues & Stacks

=== Queues

==== Introduction to Queues

Let us explain the concept of queues using the analogies given below.

* People moving on an escalator. 
The opeople who got on the escalator first will be the first one to step out of it.
* People waiting for a bus. 
The first person standing in the line will be the first oe to get into the bus.
* People standing outside the ticketing window of a cinema hall. 
The first person in the line will get the ticket first and thus will be the first one to move out of it.
* Laguage kept on coveyour belts. 
The bag which was placed first will be the first to come out at the other end.
* Cars lined at a toll bridge. 
The first car to reach the bridge will be the first to leave.

In all these examples, we see that the element at the first position is served first. 
Same is the case with queue data structure. 
A queue is FIFO (First In First Out) data structure in which the element that is inserted first is the first one to be taken out. 
The elements in a queue are added at one end called the `REAR` and removed from the other end called the `FRONT`. 
Queues can be implemented by using either array or linked list. 
In this section we will see how queues are implemented using each of these data structures.

==== Array Representation and Implementation of Queues

Queues can be easily represented using linear arrays. 
As stated earlier, every queue has front and rear variables that point to the position from where deletions and insertions can be done, respectively.

The array representation of a queue is shown in Fig. 3.1.

image::queues-array.png[]

===== Operations on Queues

In Fig.3.1, FRONT = 0 and REAR = 5. 
Suppose we want to add another element with value 45, the REAR would be incremented by 1 and the value would be stored at the position pointed by REAR.

The queue after addition would be as shown in Fig. 3.2. 
Here, FRONT = 0 and REAR = 6. 
Every time  new element has to be added, we repeat the same procedure.

If we want to delete an element from the queue, then the value of FRONT will be incremented. 
Deletions are done from onl this end of the queue.      
The queue after deletion would be as shown in Fig. 3.3. 
Here, FRONT = 1 and REAR = 6.

However, before inserting an element in a queue, we must check for overflow conditions. 
An overflow will occur when we try to insert an element into a queue that is already full. 
When REAR = MAX - 1, where MAX is the size of the queue, then we have an overflow condition. 
Note that we have written MAX -1 because the index starts from 0. 
Similarly, before deleting an element from a queue, we must check for underflow conditions. 
An underflow condition occurs when we try to delete an element from a queue that is already empty. 
If FRONT = -1 and REAR = -1, it means ther is no element in the queue.

* Algorithm for Insertion in Queues*
+
----
Step 1: IF REAR = MAX - 1
                Write OVERFLOW
                GOTO Step 4
        [END OF IF]
Step 2: IF FRONT = -1 and REAR = -1
                SET FRONT = REAR = 0
        ELSE
                SET REAR = REAR + 1
        [END OF IF]
Step 3: SET QUEUE[REAR] = NUM
Step 4: EXIT
----

* Algorithm for Deletion in Queues*
+
----
Step 1: IF FRONT = -1 and FRONT > REAR
                Write UNDERFLOW
        ELSE
                SET VAL = QUEUE[FRONT]
                SET FRONT = FRONT + 1
        [END OF IF]
Step 2: EXIT
----

Note: The process of inserting an element in the queue is called enqueue and the process of deleting an element from the queue is called dequeue.

==== Linked List Representation and Implementation of Queues

===== Insert Operation

===== Delete Operation

==== Applications of Queues

==== Types of Queues

===== Circular Queues

===== Deques

===== Priority Queues

===== Multiple Queues

=== Stacks

==== Introduction to Stacks

==== Array Representation of Stacks

=== Operations on Stacks

==== Push Operation

==== Pop Operation

==== Peek Operation

=== Linked Representation of Stacks

=== Applications of Stacks

==== Reversing List




